
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ExternalAccount
 * 
 */
export type ExternalAccount = $Result.DefaultSelection<Prisma.$ExternalAccountPayload>
/**
 * Model EmailVerification
 * 
 */
export type EmailVerification = $Result.DefaultSelection<Prisma.$EmailVerificationPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model MultiFactorAuthentication
 * 
 */
export type MultiFactorAuthentication = $Result.DefaultSelection<Prisma.$MultiFactorAuthenticationPayload>
/**
 * Model Totp
 * 
 */
export type Totp = $Result.DefaultSelection<Prisma.$TotpPayload>
/**
 * Model Passkey
 * 
 */
export type Passkey = $Result.DefaultSelection<Prisma.$PasskeyPayload>
/**
 * Model Restriction
 * 
 */
export type Restriction = $Result.DefaultSelection<Prisma.$RestrictionPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Portal
 * 
 */
export type Portal = $Result.DefaultSelection<Prisma.$PortalPayload>
/**
 * Model UserPortalRole
 * 
 */
export type UserPortalRole = $Result.DefaultSelection<Prisma.$UserPortalRolePayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model CustomField
 * 
 */
export type CustomField = $Result.DefaultSelection<Prisma.$CustomFieldPayload>
/**
 * Model CustomFieldValue
 * 
 */
export type CustomFieldValue = $Result.DefaultSelection<Prisma.$CustomFieldValuePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SeoKeyword
 * 
 */
export type SeoKeyword = $Result.DefaultSelection<Prisma.$SeoKeywordPayload>
/**
 * Model SeoArticle
 * 
 */
export type SeoArticle = $Result.DefaultSelection<Prisma.$SeoArticlePayload>
/**
 * Model SerpPosition
 * 
 */
export type SerpPosition = $Result.DefaultSelection<Prisma.$SerpPositionPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  PORTAL_USER: 'PORTAL_USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccountProvider: {
  GOOGLE: 'GOOGLE',
  GITHUB: 'GITHUB'
};

export type AccountProvider = (typeof AccountProvider)[keyof typeof AccountProvider]


export const EmailVerificationStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED'
};

export type EmailVerificationStatus = (typeof EmailVerificationStatus)[keyof typeof EmailVerificationStatus]


export const TotpStatus: {
  DISABLED: 'DISABLED',
  PENDING: 'PENDING',
  ENABLED: 'ENABLED'
};

export type TotpStatus = (typeof TotpStatus)[keyof typeof TotpStatus]


export const RestrictionReason: {
  INAPPROPRIATE_USERNAME: 'INAPPROPRIATE_USERNAME',
  SPAM: 'SPAM',
  OFFENSIVE_BEHAVIOR: 'OFFENSIVE_BEHAVIOR'
};

export type RestrictionReason = (typeof RestrictionReason)[keyof typeof RestrictionReason]


export const RestrictionStatus: {
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  CANCELED: 'CANCELED'
};

export type RestrictionStatus = (typeof RestrictionStatus)[keyof typeof RestrictionStatus]


export const AuthMethod: {
  EMAIL: 'EMAIL',
  GOOGLE: 'GOOGLE',
  GITHUB: 'GITHUB'
};

export type AuthMethod = (typeof AuthMethod)[keyof typeof AuthMethod]


export const PortalRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  EMPLOYEE: 'EMPLOYEE',
  ACCOUNTANT: 'ACCOUNTANT'
};

export type PortalRole = (typeof PortalRole)[keyof typeof PortalRole]


export const SubscriptionStatus: {
  TRIAL: 'TRIAL',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const LeadSource: {
  WEBSITE: 'WEBSITE',
  INSTAGRAM: 'INSTAGRAM',
  FACEBOOK: 'FACEBOOK',
  GOOGLE_ADS: 'GOOGLE_ADS',
  REFERRAL: 'REFERRAL',
  PHONE: 'PHONE',
  EMAIL: 'EMAIL',
  OTHER: 'OTHER'
};

export type LeadSource = (typeof LeadSource)[keyof typeof LeadSource]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  CONVERTED: 'CONVERTED',
  LOST: 'LOST'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const EntityType: {
  CLIENT: 'CLIENT',
  LEAD: 'LEAD',
  DEAL: 'DEAL'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const FieldType: {
  TEXT: 'TEXT',
  NUMBER: 'NUMBER',
  DATE: 'DATE',
  SELECT: 'SELECT',
  MULTISELECT: 'MULTISELECT',
  BOOLEAN: 'BOOLEAN',
  EMAIL: 'EMAIL',
  PHONE: 'PHONE',
  URL: 'URL'
};

export type FieldType = (typeof FieldType)[keyof typeof FieldType]


export const IntegrationType: {
  INSTAGRAM: 'INSTAGRAM',
  GOOGLE_CALENDAR: 'GOOGLE_CALENDAR',
  STRIPE: 'STRIPE',
  MOLLIE: 'MOLLIE',
  PAYPAL: 'PAYPAL',
  TWILIO: 'TWILIO',
  SENDGRID: 'SENDGRID',
  GOOGLE_SEARCH_CONSOLE: 'GOOGLE_SEARCH_CONSOLE'
};

export type IntegrationType = (typeof IntegrationType)[keyof typeof IntegrationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccountProvider = $Enums.AccountProvider

export const AccountProvider: typeof $Enums.AccountProvider

export type EmailVerificationStatus = $Enums.EmailVerificationStatus

export const EmailVerificationStatus: typeof $Enums.EmailVerificationStatus

export type TotpStatus = $Enums.TotpStatus

export const TotpStatus: typeof $Enums.TotpStatus

export type RestrictionReason = $Enums.RestrictionReason

export const RestrictionReason: typeof $Enums.RestrictionReason

export type RestrictionStatus = $Enums.RestrictionStatus

export const RestrictionStatus: typeof $Enums.RestrictionStatus

export type AuthMethod = $Enums.AuthMethod

export const AuthMethod: typeof $Enums.AuthMethod

export type PortalRole = $Enums.PortalRole

export const PortalRole: typeof $Enums.PortalRole

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type LeadSource = $Enums.LeadSource

export const LeadSource: typeof $Enums.LeadSource

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type FieldType = $Enums.FieldType

export const FieldType: typeof $Enums.FieldType

export type IntegrationType = $Enums.IntegrationType

export const IntegrationType: typeof $Enums.IntegrationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalAccount`: Exposes CRUD operations for the **ExternalAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalAccounts
    * const externalAccounts = await prisma.externalAccount.findMany()
    * ```
    */
  get externalAccount(): Prisma.ExternalAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerification`: Exposes CRUD operations for the **EmailVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerifications
    * const emailVerifications = await prisma.emailVerification.findMany()
    * ```
    */
  get emailVerification(): Prisma.EmailVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multiFactorAuthentication`: Exposes CRUD operations for the **MultiFactorAuthentication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultiFactorAuthentications
    * const multiFactorAuthentications = await prisma.multiFactorAuthentication.findMany()
    * ```
    */
  get multiFactorAuthentication(): Prisma.MultiFactorAuthenticationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.totp`: Exposes CRUD operations for the **Totp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Totps
    * const totps = await prisma.totp.findMany()
    * ```
    */
  get totp(): Prisma.TotpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passkey`: Exposes CRUD operations for the **Passkey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passkeys
    * const passkeys = await prisma.passkey.findMany()
    * ```
    */
  get passkey(): Prisma.PasskeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restriction`: Exposes CRUD operations for the **Restriction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restrictions
    * const restrictions = await prisma.restriction.findMany()
    * ```
    */
  get restriction(): Prisma.RestrictionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portal`: Exposes CRUD operations for the **Portal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portals
    * const portals = await prisma.portal.findMany()
    * ```
    */
  get portal(): Prisma.PortalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPortalRole`: Exposes CRUD operations for the **UserPortalRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPortalRoles
    * const userPortalRoles = await prisma.userPortalRole.findMany()
    * ```
    */
  get userPortalRole(): Prisma.UserPortalRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customField`: Exposes CRUD operations for the **CustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFields
    * const customFields = await prisma.customField.findMany()
    * ```
    */
  get customField(): Prisma.CustomFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customFieldValue`: Exposes CRUD operations for the **CustomFieldValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFieldValues
    * const customFieldValues = await prisma.customFieldValue.findMany()
    * ```
    */
  get customFieldValue(): Prisma.CustomFieldValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seoKeyword`: Exposes CRUD operations for the **SeoKeyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeoKeywords
    * const seoKeywords = await prisma.seoKeyword.findMany()
    * ```
    */
  get seoKeyword(): Prisma.SeoKeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seoArticle`: Exposes CRUD operations for the **SeoArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeoArticles
    * const seoArticles = await prisma.seoArticle.findMany()
    * ```
    */
  get seoArticle(): Prisma.SeoArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serpPosition`: Exposes CRUD operations for the **SerpPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SerpPositions
    * const serpPositions = await prisma.serpPosition.findMany()
    * ```
    */
  get serpPosition(): Prisma.SerpPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ExternalAccount: 'ExternalAccount',
    EmailVerification: 'EmailVerification',
    PasswordReset: 'PasswordReset',
    MultiFactorAuthentication: 'MultiFactorAuthentication',
    Totp: 'Totp',
    Passkey: 'Passkey',
    Restriction: 'Restriction',
    Post: 'Post',
    Comment: 'Comment',
    Portal: 'Portal',
    UserPortalRole: 'UserPortalRole',
    Client: 'Client',
    Lead: 'Lead',
    Deal: 'Deal',
    Appointment: 'Appointment',
    Product: 'Product',
    CustomField: 'CustomField',
    CustomFieldValue: 'CustomFieldValue',
    AuditLog: 'AuditLog',
    SeoKeyword: 'SeoKeyword',
    SeoArticle: 'SeoArticle',
    SerpPosition: 'SerpPosition',
    Integration: 'Integration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "externalAccount" | "emailVerification" | "passwordReset" | "multiFactorAuthentication" | "totp" | "passkey" | "restriction" | "post" | "comment" | "portal" | "userPortalRole" | "client" | "lead" | "deal" | "appointment" | "product" | "customField" | "customFieldValue" | "auditLog" | "seoKeyword" | "seoArticle" | "serpPosition" | "integration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ExternalAccount: {
        payload: Prisma.$ExternalAccountPayload<ExtArgs>
        fields: Prisma.ExternalAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>
          }
          findFirst: {
            args: Prisma.ExternalAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>
          }
          findMany: {
            args: Prisma.ExternalAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>[]
          }
          create: {
            args: Prisma.ExternalAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>
          }
          createMany: {
            args: Prisma.ExternalAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExternalAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>
          }
          update: {
            args: Prisma.ExternalAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>
          }
          deleteMany: {
            args: Prisma.ExternalAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExternalAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalAccountPayload>
          }
          aggregate: {
            args: Prisma.ExternalAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalAccount>
          }
          groupBy: {
            args: Prisma.ExternalAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalAccountCountAggregateOutputType> | number
          }
        }
      }
      EmailVerification: {
        payload: Prisma.$EmailVerificationPayload<ExtArgs>
        fields: Prisma.EmailVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          update: {
            args: Prisma.EmailVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerification>
          }
          groupBy: {
            args: Prisma.EmailVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      MultiFactorAuthentication: {
        payload: Prisma.$MultiFactorAuthenticationPayload<ExtArgs>
        fields: Prisma.MultiFactorAuthenticationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultiFactorAuthenticationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultiFactorAuthenticationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>
          }
          findFirst: {
            args: Prisma.MultiFactorAuthenticationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultiFactorAuthenticationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>
          }
          findMany: {
            args: Prisma.MultiFactorAuthenticationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>[]
          }
          create: {
            args: Prisma.MultiFactorAuthenticationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>
          }
          createMany: {
            args: Prisma.MultiFactorAuthenticationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MultiFactorAuthenticationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>
          }
          update: {
            args: Prisma.MultiFactorAuthenticationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>
          }
          deleteMany: {
            args: Prisma.MultiFactorAuthenticationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultiFactorAuthenticationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MultiFactorAuthenticationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultiFactorAuthenticationPayload>
          }
          aggregate: {
            args: Prisma.MultiFactorAuthenticationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultiFactorAuthentication>
          }
          groupBy: {
            args: Prisma.MultiFactorAuthenticationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultiFactorAuthenticationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultiFactorAuthenticationCountArgs<ExtArgs>
            result: $Utils.Optional<MultiFactorAuthenticationCountAggregateOutputType> | number
          }
        }
      }
      Totp: {
        payload: Prisma.$TotpPayload<ExtArgs>
        fields: Prisma.TotpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TotpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TotpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>
          }
          findFirst: {
            args: Prisma.TotpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TotpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>
          }
          findMany: {
            args: Prisma.TotpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>[]
          }
          create: {
            args: Prisma.TotpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>
          }
          createMany: {
            args: Prisma.TotpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TotpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>
          }
          update: {
            args: Prisma.TotpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>
          }
          deleteMany: {
            args: Prisma.TotpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TotpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TotpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotpPayload>
          }
          aggregate: {
            args: Prisma.TotpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTotp>
          }
          groupBy: {
            args: Prisma.TotpGroupByArgs<ExtArgs>
            result: $Utils.Optional<TotpGroupByOutputType>[]
          }
          count: {
            args: Prisma.TotpCountArgs<ExtArgs>
            result: $Utils.Optional<TotpCountAggregateOutputType> | number
          }
        }
      }
      Passkey: {
        payload: Prisma.$PasskeyPayload<ExtArgs>
        fields: Prisma.PasskeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasskeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasskeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          findFirst: {
            args: Prisma.PasskeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasskeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          findMany: {
            args: Prisma.PasskeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>[]
          }
          create: {
            args: Prisma.PasskeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          createMany: {
            args: Prisma.PasskeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PasskeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          update: {
            args: Prisma.PasskeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          deleteMany: {
            args: Prisma.PasskeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasskeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasskeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasskeyPayload>
          }
          aggregate: {
            args: Prisma.PasskeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasskey>
          }
          groupBy: {
            args: Prisma.PasskeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasskeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasskeyCountArgs<ExtArgs>
            result: $Utils.Optional<PasskeyCountAggregateOutputType> | number
          }
        }
      }
      Restriction: {
        payload: Prisma.$RestrictionPayload<ExtArgs>
        fields: Prisma.RestrictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestrictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestrictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          findFirst: {
            args: Prisma.RestrictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestrictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          findMany: {
            args: Prisma.RestrictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>[]
          }
          create: {
            args: Prisma.RestrictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          createMany: {
            args: Prisma.RestrictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RestrictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          update: {
            args: Prisma.RestrictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          deleteMany: {
            args: Prisma.RestrictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestrictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestrictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestrictionPayload>
          }
          aggregate: {
            args: Prisma.RestrictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestriction>
          }
          groupBy: {
            args: Prisma.RestrictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestrictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestrictionCountArgs<ExtArgs>
            result: $Utils.Optional<RestrictionCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Portal: {
        payload: Prisma.$PortalPayload<ExtArgs>
        fields: Prisma.PortalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>
          }
          findFirst: {
            args: Prisma.PortalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>
          }
          findMany: {
            args: Prisma.PortalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>[]
          }
          create: {
            args: Prisma.PortalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>
          }
          createMany: {
            args: Prisma.PortalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PortalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>
          }
          update: {
            args: Prisma.PortalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>
          }
          deleteMany: {
            args: Prisma.PortalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalPayload>
          }
          aggregate: {
            args: Prisma.PortalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortal>
          }
          groupBy: {
            args: Prisma.PortalGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortalGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortalCountArgs<ExtArgs>
            result: $Utils.Optional<PortalCountAggregateOutputType> | number
          }
        }
      }
      UserPortalRole: {
        payload: Prisma.$UserPortalRolePayload<ExtArgs>
        fields: Prisma.UserPortalRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPortalRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPortalRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>
          }
          findFirst: {
            args: Prisma.UserPortalRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPortalRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>
          }
          findMany: {
            args: Prisma.UserPortalRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>[]
          }
          create: {
            args: Prisma.UserPortalRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>
          }
          createMany: {
            args: Prisma.UserPortalRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPortalRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>
          }
          update: {
            args: Prisma.UserPortalRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>
          }
          deleteMany: {
            args: Prisma.UserPortalRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPortalRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPortalRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPortalRolePayload>
          }
          aggregate: {
            args: Prisma.UserPortalRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPortalRole>
          }
          groupBy: {
            args: Prisma.UserPortalRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPortalRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPortalRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserPortalRoleCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      CustomField: {
        payload: Prisma.$CustomFieldPayload<ExtArgs>
        fields: Prisma.CustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findFirst: {
            args: Prisma.CustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findMany: {
            args: Prisma.CustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          create: {
            args: Prisma.CustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          createMany: {
            args: Prisma.CustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          update: {
            args: Prisma.CustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          aggregate: {
            args: Prisma.CustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomField>
          }
          groupBy: {
            args: Prisma.CustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldCountAggregateOutputType> | number
          }
        }
      }
      CustomFieldValue: {
        payload: Prisma.$CustomFieldValuePayload<ExtArgs>
        fields: Prisma.CustomFieldValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          findFirst: {
            args: Prisma.CustomFieldValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          findMany: {
            args: Prisma.CustomFieldValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>[]
          }
          create: {
            args: Prisma.CustomFieldValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          createMany: {
            args: Prisma.CustomFieldValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomFieldValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          update: {
            args: Prisma.CustomFieldValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomFieldValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          aggregate: {
            args: Prisma.CustomFieldValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomFieldValue>
          }
          groupBy: {
            args: Prisma.CustomFieldValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomFieldValueCountArgs<ExtArgs>
            result: $Utils.Optional<CustomFieldValueCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SeoKeyword: {
        payload: Prisma.$SeoKeywordPayload<ExtArgs>
        fields: Prisma.SeoKeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoKeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoKeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>
          }
          findFirst: {
            args: Prisma.SeoKeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoKeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>
          }
          findMany: {
            args: Prisma.SeoKeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>[]
          }
          create: {
            args: Prisma.SeoKeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>
          }
          createMany: {
            args: Prisma.SeoKeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeoKeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>
          }
          update: {
            args: Prisma.SeoKeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>
          }
          deleteMany: {
            args: Prisma.SeoKeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoKeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeoKeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoKeywordPayload>
          }
          aggregate: {
            args: Prisma.SeoKeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeoKeyword>
          }
          groupBy: {
            args: Prisma.SeoKeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoKeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoKeywordCountArgs<ExtArgs>
            result: $Utils.Optional<SeoKeywordCountAggregateOutputType> | number
          }
        }
      }
      SeoArticle: {
        payload: Prisma.$SeoArticlePayload<ExtArgs>
        fields: Prisma.SeoArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>
          }
          findFirst: {
            args: Prisma.SeoArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>
          }
          findMany: {
            args: Prisma.SeoArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>[]
          }
          create: {
            args: Prisma.SeoArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>
          }
          createMany: {
            args: Prisma.SeoArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeoArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>
          }
          update: {
            args: Prisma.SeoArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>
          }
          deleteMany: {
            args: Prisma.SeoArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeoArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoArticlePayload>
          }
          aggregate: {
            args: Prisma.SeoArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeoArticle>
          }
          groupBy: {
            args: Prisma.SeoArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoArticleCountArgs<ExtArgs>
            result: $Utils.Optional<SeoArticleCountAggregateOutputType> | number
          }
        }
      }
      SerpPosition: {
        payload: Prisma.$SerpPositionPayload<ExtArgs>
        fields: Prisma.SerpPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SerpPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SerpPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>
          }
          findFirst: {
            args: Prisma.SerpPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SerpPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>
          }
          findMany: {
            args: Prisma.SerpPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>[]
          }
          create: {
            args: Prisma.SerpPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>
          }
          createMany: {
            args: Prisma.SerpPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SerpPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>
          }
          update: {
            args: Prisma.SerpPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>
          }
          deleteMany: {
            args: Prisma.SerpPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SerpPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SerpPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SerpPositionPayload>
          }
          aggregate: {
            args: Prisma.SerpPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSerpPosition>
          }
          groupBy: {
            args: Prisma.SerpPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SerpPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SerpPositionCountArgs<ExtArgs>
            result: $Utils.Optional<SerpPositionCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    externalAccount?: ExternalAccountOmit
    emailVerification?: EmailVerificationOmit
    passwordReset?: PasswordResetOmit
    multiFactorAuthentication?: MultiFactorAuthenticationOmit
    totp?: TotpOmit
    passkey?: PasskeyOmit
    restriction?: RestrictionOmit
    post?: PostOmit
    comment?: CommentOmit
    portal?: PortalOmit
    userPortalRole?: UserPortalRoleOmit
    client?: ClientOmit
    lead?: LeadOmit
    deal?: DealOmit
    appointment?: AppointmentOmit
    product?: ProductOmit
    customField?: CustomFieldOmit
    customFieldValue?: CustomFieldValueOmit
    auditLog?: AuditLogOmit
    seoKeyword?: SeoKeywordOmit
    seoArticle?: SeoArticleOmit
    serpPosition?: SerpPositionOmit
    integration?: IntegrationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    externalAccounts: number
    comments: number
    restrictions: number
    portalRoles: number
    createdClients: number
    assignedLeads: number
    createdLeads: number
    assignedDeals: number
    createdDeals: number
    appointments: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externalAccounts?: boolean | UserCountOutputTypeCountExternalAccountsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    restrictions?: boolean | UserCountOutputTypeCountRestrictionsArgs
    portalRoles?: boolean | UserCountOutputTypeCountPortalRolesArgs
    createdClients?: boolean | UserCountOutputTypeCountCreatedClientsArgs
    assignedLeads?: boolean | UserCountOutputTypeCountAssignedLeadsArgs
    createdLeads?: boolean | UserCountOutputTypeCountCreatedLeadsArgs
    assignedDeals?: boolean | UserCountOutputTypeCountAssignedDealsArgs
    createdDeals?: boolean | UserCountOutputTypeCountCreatedDealsArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExternalAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestrictionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPortalRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPortalRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type MultiFactorAuthenticationCountOutputType
   */

  export type MultiFactorAuthenticationCountOutputType = {
    passkeys: number
  }

  export type MultiFactorAuthenticationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passkeys?: boolean | MultiFactorAuthenticationCountOutputTypeCountPasskeysArgs
  }

  // Custom InputTypes
  /**
   * MultiFactorAuthenticationCountOutputType without action
   */
  export type MultiFactorAuthenticationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthenticationCountOutputType
     */
    select?: MultiFactorAuthenticationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultiFactorAuthenticationCountOutputType without action
   */
  export type MultiFactorAuthenticationCountOutputTypeCountPasskeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasskeyWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type PortalCountOutputType
   */

  export type PortalCountOutputType = {
    userRoles: number
    clients: number
    leads: number
    deals: number
    appointments: number
    products: number
    customFields: number
    auditLogs: number
    seoKeywords: number
    seoArticles: number
    serpPositions: number
    integrations: number
  }

  export type PortalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | PortalCountOutputTypeCountUserRolesArgs
    clients?: boolean | PortalCountOutputTypeCountClientsArgs
    leads?: boolean | PortalCountOutputTypeCountLeadsArgs
    deals?: boolean | PortalCountOutputTypeCountDealsArgs
    appointments?: boolean | PortalCountOutputTypeCountAppointmentsArgs
    products?: boolean | PortalCountOutputTypeCountProductsArgs
    customFields?: boolean | PortalCountOutputTypeCountCustomFieldsArgs
    auditLogs?: boolean | PortalCountOutputTypeCountAuditLogsArgs
    seoKeywords?: boolean | PortalCountOutputTypeCountSeoKeywordsArgs
    seoArticles?: boolean | PortalCountOutputTypeCountSeoArticlesArgs
    serpPositions?: boolean | PortalCountOutputTypeCountSerpPositionsArgs
    integrations?: boolean | PortalCountOutputTypeCountIntegrationsArgs
  }

  // Custom InputTypes
  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCountOutputType
     */
    select?: PortalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPortalRoleWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountSeoKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoKeywordWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountSeoArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoArticleWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountSerpPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SerpPositionWhereInput
  }

  /**
   * PortalCountOutputType without action
   */
  export type PortalCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    deals: number
    appointments: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deals?: boolean | ClientCountOutputTypeCountDealsArgs
    appointments?: boolean | ClientCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    deals: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deals?: boolean | LeadCountOutputTypeCountDealsArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    appointments: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | DealCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    appointments: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ProductCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type CustomFieldCountOutputType
   */

  export type CustomFieldCountOutputType = {
    values: number
  }

  export type CustomFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | CustomFieldCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldCountOutputType
     */
    select?: CustomFieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
  }


  /**
   * Count Type SeoKeywordCountOutputType
   */

  export type SeoKeywordCountOutputType = {
    serpPositions: number
  }

  export type SeoKeywordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serpPositions?: boolean | SeoKeywordCountOutputTypeCountSerpPositionsArgs
  }

  // Custom InputTypes
  /**
   * SeoKeywordCountOutputType without action
   */
  export type SeoKeywordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeywordCountOutputType
     */
    select?: SeoKeywordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeoKeywordCountOutputType without action
   */
  export type SeoKeywordCountOutputTypeCountSerpPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SerpPositionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    surname: string | null
    password: string | null
    displayName: string | null
    avatar: string | null
    points: number | null
    role: $Enums.UserRole | null
    method: $Enums.AuthMethod | null
    emailVerified: Date | null
    isEmailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    surname: string | null
    password: string | null
    displayName: string | null
    avatar: string | null
    points: number | null
    role: $Enums.UserRole | null
    method: $Enums.AuthMethod | null
    emailVerified: Date | null
    isEmailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    surname: number
    password: number
    displayName: number
    avatar: number
    points: number
    role: number
    method: number
    emailVerified: number
    isEmailVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    surname?: true
    password?: true
    displayName?: true
    avatar?: true
    points?: true
    role?: true
    method?: true
    emailVerified?: true
    isEmailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    surname?: true
    password?: true
    displayName?: true
    avatar?: true
    points?: true
    role?: true
    method?: true
    emailVerified?: true
    isEmailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    surname?: true
    password?: true
    displayName?: true
    avatar?: true
    points?: true
    role?: true
    method?: true
    emailVerified?: true
    isEmailVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    surname: string | null
    password: string | null
    displayName: string
    avatar: string | null
    points: number
    role: $Enums.UserRole
    method: $Enums.AuthMethod
    emailVerified: Date | null
    isEmailVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    surname?: boolean
    password?: boolean
    displayName?: boolean
    avatar?: boolean
    points?: boolean
    role?: boolean
    method?: boolean
    emailVerified?: boolean
    isEmailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    passwordReset?: boolean | User$passwordResetArgs<ExtArgs>
    externalAccounts?: boolean | User$externalAccountsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    mfa?: boolean | User$mfaArgs<ExtArgs>
    restrictions?: boolean | User$restrictionsArgs<ExtArgs>
    emailVerification?: boolean | User$emailVerificationArgs<ExtArgs>
    portalRoles?: boolean | User$portalRolesArgs<ExtArgs>
    createdClients?: boolean | User$createdClientsArgs<ExtArgs>
    assignedLeads?: boolean | User$assignedLeadsArgs<ExtArgs>
    createdLeads?: boolean | User$createdLeadsArgs<ExtArgs>
    assignedDeals?: boolean | User$assignedDealsArgs<ExtArgs>
    createdDeals?: boolean | User$createdDealsArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    surname?: boolean
    password?: boolean
    displayName?: boolean
    avatar?: boolean
    points?: boolean
    role?: boolean
    method?: boolean
    emailVerified?: boolean
    isEmailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "surname" | "password" | "displayName" | "avatar" | "points" | "role" | "method" | "emailVerified" | "isEmailVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordReset?: boolean | User$passwordResetArgs<ExtArgs>
    externalAccounts?: boolean | User$externalAccountsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    mfa?: boolean | User$mfaArgs<ExtArgs>
    restrictions?: boolean | User$restrictionsArgs<ExtArgs>
    emailVerification?: boolean | User$emailVerificationArgs<ExtArgs>
    portalRoles?: boolean | User$portalRolesArgs<ExtArgs>
    createdClients?: boolean | User$createdClientsArgs<ExtArgs>
    assignedLeads?: boolean | User$assignedLeadsArgs<ExtArgs>
    createdLeads?: boolean | User$createdLeadsArgs<ExtArgs>
    assignedDeals?: boolean | User$assignedDealsArgs<ExtArgs>
    createdDeals?: boolean | User$createdDealsArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      passwordReset: Prisma.$PasswordResetPayload<ExtArgs> | null
      externalAccounts: Prisma.$ExternalAccountPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      mfa: Prisma.$MultiFactorAuthenticationPayload<ExtArgs> | null
      restrictions: Prisma.$RestrictionPayload<ExtArgs>[]
      emailVerification: Prisma.$EmailVerificationPayload<ExtArgs> | null
      portalRoles: Prisma.$UserPortalRolePayload<ExtArgs>[]
      createdClients: Prisma.$ClientPayload<ExtArgs>[]
      assignedLeads: Prisma.$LeadPayload<ExtArgs>[]
      createdLeads: Prisma.$LeadPayload<ExtArgs>[]
      assignedDeals: Prisma.$DealPayload<ExtArgs>[]
      createdDeals: Prisma.$DealPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      surname: string | null
      password: string | null
      displayName: string
      avatar: string | null
      points: number
      role: $Enums.UserRole
      method: $Enums.AuthMethod
      emailVerified: Date | null
      isEmailVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passwordReset<T extends User$passwordResetArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    externalAccounts<T extends User$externalAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$externalAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mfa<T extends User$mfaArgs<ExtArgs> = {}>(args?: Subset<T, User$mfaArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    restrictions<T extends User$restrictionsArgs<ExtArgs> = {}>(args?: Subset<T, User$restrictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailVerification<T extends User$emailVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$emailVerificationArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    portalRoles<T extends User$portalRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$portalRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdClients<T extends User$createdClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedLeads<T extends User$assignedLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdLeads<T extends User$createdLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedDeals<T extends User$assignedDealsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedDealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdDeals<T extends User$createdDealsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdDealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly surname: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly points: FieldRef<"User", 'Int'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly method: FieldRef<"User", 'AuthMethod'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.passwordReset
   */
  export type User$passwordResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
  }

  /**
   * User.externalAccounts
   */
  export type User$externalAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    where?: ExternalAccountWhereInput
    orderBy?: ExternalAccountOrderByWithRelationInput | ExternalAccountOrderByWithRelationInput[]
    cursor?: ExternalAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalAccountScalarFieldEnum | ExternalAccountScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.mfa
   */
  export type User$mfaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    where?: MultiFactorAuthenticationWhereInput
  }

  /**
   * User.restrictions
   */
  export type User$restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    where?: RestrictionWhereInput
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    cursor?: RestrictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * User.emailVerification
   */
  export type User$emailVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    where?: EmailVerificationWhereInput
  }

  /**
   * User.portalRoles
   */
  export type User$portalRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    where?: UserPortalRoleWhereInput
    orderBy?: UserPortalRoleOrderByWithRelationInput | UserPortalRoleOrderByWithRelationInput[]
    cursor?: UserPortalRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPortalRoleScalarFieldEnum | UserPortalRoleScalarFieldEnum[]
  }

  /**
   * User.createdClients
   */
  export type User$createdClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.assignedLeads
   */
  export type User$assignedLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.createdLeads
   */
  export type User$createdLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.assignedDeals
   */
  export type User$assignedDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * User.createdDeals
   */
  export type User$createdDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ExternalAccount
   */

  export type AggregateExternalAccount = {
    _count: ExternalAccountCountAggregateOutputType | null
    _avg: ExternalAccountAvgAggregateOutputType | null
    _sum: ExternalAccountSumAggregateOutputType | null
    _min: ExternalAccountMinAggregateOutputType | null
    _max: ExternalAccountMaxAggregateOutputType | null
  }

  export type ExternalAccountAvgAggregateOutputType = {
    expiry: number | null
  }

  export type ExternalAccountSumAggregateOutputType = {
    expiry: number | null
  }

  export type ExternalAccountMinAggregateOutputType = {
    id: string | null
    provider: $Enums.AccountProvider | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    expiry: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalAccountMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.AccountProvider | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    expiry: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalAccountCountAggregateOutputType = {
    id: number
    provider: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    expiry: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalAccountAvgAggregateInputType = {
    expiry?: true
  }

  export type ExternalAccountSumAggregateInputType = {
    expiry?: true
  }

  export type ExternalAccountMinAggregateInputType = {
    id?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalAccountMaxAggregateInputType = {
    id?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalAccountCountAggregateInputType = {
    id?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalAccount to aggregate.
     */
    where?: ExternalAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAccounts to fetch.
     */
    orderBy?: ExternalAccountOrderByWithRelationInput | ExternalAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalAccounts
    **/
    _count?: true | ExternalAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalAccountMaxAggregateInputType
  }

  export type GetExternalAccountAggregateType<T extends ExternalAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalAccount[P]>
      : GetScalarType<T[P], AggregateExternalAccount[P]>
  }




  export type ExternalAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalAccountWhereInput
    orderBy?: ExternalAccountOrderByWithAggregationInput | ExternalAccountOrderByWithAggregationInput[]
    by: ExternalAccountScalarFieldEnum[] | ExternalAccountScalarFieldEnum
    having?: ExternalAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalAccountCountAggregateInputType | true
    _avg?: ExternalAccountAvgAggregateInputType
    _sum?: ExternalAccountSumAggregateInputType
    _min?: ExternalAccountMinAggregateInputType
    _max?: ExternalAccountMaxAggregateInputType
  }

  export type ExternalAccountGroupByOutputType = {
    id: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    expiry: number | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ExternalAccountCountAggregateOutputType | null
    _avg: ExternalAccountAvgAggregateOutputType | null
    _sum: ExternalAccountSumAggregateOutputType | null
    _min: ExternalAccountMinAggregateOutputType | null
    _max: ExternalAccountMaxAggregateOutputType | null
  }

  type GetExternalAccountGroupByPayload<T extends ExternalAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalAccountGroupByOutputType[P]>
        }
      >
    >


  export type ExternalAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiry?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalAccount"]>



  export type ExternalAccountSelectScalar = {
    id?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiry?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "providerAccountId" | "refreshToken" | "accessToken" | "expiry" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["externalAccount"]>
  export type ExternalAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExternalAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.AccountProvider
      providerAccountId: string
      refreshToken: string | null
      accessToken: string | null
      expiry: number | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalAccount"]>
    composites: {}
  }

  type ExternalAccountGetPayload<S extends boolean | null | undefined | ExternalAccountDefaultArgs> = $Result.GetResult<Prisma.$ExternalAccountPayload, S>

  type ExternalAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExternalAccountCountAggregateInputType | true
    }

  export interface ExternalAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalAccount'], meta: { name: 'ExternalAccount' } }
    /**
     * Find zero or one ExternalAccount that matches the filter.
     * @param {ExternalAccountFindUniqueArgs} args - Arguments to find a ExternalAccount
     * @example
     * // Get one ExternalAccount
     * const externalAccount = await prisma.externalAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalAccountFindUniqueArgs>(args: SelectSubset<T, ExternalAccountFindUniqueArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExternalAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalAccountFindUniqueOrThrowArgs} args - Arguments to find a ExternalAccount
     * @example
     * // Get one ExternalAccount
     * const externalAccount = await prisma.externalAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountFindFirstArgs} args - Arguments to find a ExternalAccount
     * @example
     * // Get one ExternalAccount
     * const externalAccount = await prisma.externalAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalAccountFindFirstArgs>(args?: SelectSubset<T, ExternalAccountFindFirstArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountFindFirstOrThrowArgs} args - Arguments to find a ExternalAccount
     * @example
     * // Get one ExternalAccount
     * const externalAccount = await prisma.externalAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExternalAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalAccounts
     * const externalAccounts = await prisma.externalAccount.findMany()
     * 
     * // Get first 10 ExternalAccounts
     * const externalAccounts = await prisma.externalAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalAccountWithIdOnly = await prisma.externalAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalAccountFindManyArgs>(args?: SelectSubset<T, ExternalAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExternalAccount.
     * @param {ExternalAccountCreateArgs} args - Arguments to create a ExternalAccount.
     * @example
     * // Create one ExternalAccount
     * const ExternalAccount = await prisma.externalAccount.create({
     *   data: {
     *     // ... data to create a ExternalAccount
     *   }
     * })
     * 
     */
    create<T extends ExternalAccountCreateArgs>(args: SelectSubset<T, ExternalAccountCreateArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExternalAccounts.
     * @param {ExternalAccountCreateManyArgs} args - Arguments to create many ExternalAccounts.
     * @example
     * // Create many ExternalAccounts
     * const externalAccount = await prisma.externalAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalAccountCreateManyArgs>(args?: SelectSubset<T, ExternalAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExternalAccount.
     * @param {ExternalAccountDeleteArgs} args - Arguments to delete one ExternalAccount.
     * @example
     * // Delete one ExternalAccount
     * const ExternalAccount = await prisma.externalAccount.delete({
     *   where: {
     *     // ... filter to delete one ExternalAccount
     *   }
     * })
     * 
     */
    delete<T extends ExternalAccountDeleteArgs>(args: SelectSubset<T, ExternalAccountDeleteArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExternalAccount.
     * @param {ExternalAccountUpdateArgs} args - Arguments to update one ExternalAccount.
     * @example
     * // Update one ExternalAccount
     * const externalAccount = await prisma.externalAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalAccountUpdateArgs>(args: SelectSubset<T, ExternalAccountUpdateArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExternalAccounts.
     * @param {ExternalAccountDeleteManyArgs} args - Arguments to filter ExternalAccounts to delete.
     * @example
     * // Delete a few ExternalAccounts
     * const { count } = await prisma.externalAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalAccountDeleteManyArgs>(args?: SelectSubset<T, ExternalAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalAccounts
     * const externalAccount = await prisma.externalAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalAccountUpdateManyArgs>(args: SelectSubset<T, ExternalAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalAccount.
     * @param {ExternalAccountUpsertArgs} args - Arguments to update or create a ExternalAccount.
     * @example
     * // Update or create a ExternalAccount
     * const externalAccount = await prisma.externalAccount.upsert({
     *   create: {
     *     // ... data to create a ExternalAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalAccount we want to update
     *   }
     * })
     */
    upsert<T extends ExternalAccountUpsertArgs>(args: SelectSubset<T, ExternalAccountUpsertArgs<ExtArgs>>): Prisma__ExternalAccountClient<$Result.GetResult<Prisma.$ExternalAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExternalAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountCountArgs} args - Arguments to filter ExternalAccounts to count.
     * @example
     * // Count the number of ExternalAccounts
     * const count = await prisma.externalAccount.count({
     *   where: {
     *     // ... the filter for the ExternalAccounts we want to count
     *   }
     * })
    **/
    count<T extends ExternalAccountCountArgs>(
      args?: Subset<T, ExternalAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalAccountAggregateArgs>(args: Subset<T, ExternalAccountAggregateArgs>): Prisma.PrismaPromise<GetExternalAccountAggregateType<T>>

    /**
     * Group by ExternalAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalAccountGroupByArgs['orderBy'] }
        : { orderBy?: ExternalAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalAccount model
   */
  readonly fields: ExternalAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalAccount model
   */
  interface ExternalAccountFieldRefs {
    readonly id: FieldRef<"ExternalAccount", 'String'>
    readonly provider: FieldRef<"ExternalAccount", 'AccountProvider'>
    readonly providerAccountId: FieldRef<"ExternalAccount", 'String'>
    readonly refreshToken: FieldRef<"ExternalAccount", 'String'>
    readonly accessToken: FieldRef<"ExternalAccount", 'String'>
    readonly expiry: FieldRef<"ExternalAccount", 'Int'>
    readonly userId: FieldRef<"ExternalAccount", 'String'>
    readonly createdAt: FieldRef<"ExternalAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalAccount findUnique
   */
  export type ExternalAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAccount to fetch.
     */
    where: ExternalAccountWhereUniqueInput
  }

  /**
   * ExternalAccount findUniqueOrThrow
   */
  export type ExternalAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAccount to fetch.
     */
    where: ExternalAccountWhereUniqueInput
  }

  /**
   * ExternalAccount findFirst
   */
  export type ExternalAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAccount to fetch.
     */
    where?: ExternalAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAccounts to fetch.
     */
    orderBy?: ExternalAccountOrderByWithRelationInput | ExternalAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAccounts.
     */
    cursor?: ExternalAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAccounts.
     */
    distinct?: ExternalAccountScalarFieldEnum | ExternalAccountScalarFieldEnum[]
  }

  /**
   * ExternalAccount findFirstOrThrow
   */
  export type ExternalAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAccount to fetch.
     */
    where?: ExternalAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAccounts to fetch.
     */
    orderBy?: ExternalAccountOrderByWithRelationInput | ExternalAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalAccounts.
     */
    cursor?: ExternalAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalAccounts.
     */
    distinct?: ExternalAccountScalarFieldEnum | ExternalAccountScalarFieldEnum[]
  }

  /**
   * ExternalAccount findMany
   */
  export type ExternalAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * Filter, which ExternalAccounts to fetch.
     */
    where?: ExternalAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalAccounts to fetch.
     */
    orderBy?: ExternalAccountOrderByWithRelationInput | ExternalAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalAccounts.
     */
    cursor?: ExternalAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalAccounts.
     */
    skip?: number
    distinct?: ExternalAccountScalarFieldEnum | ExternalAccountScalarFieldEnum[]
  }

  /**
   * ExternalAccount create
   */
  export type ExternalAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalAccount.
     */
    data: XOR<ExternalAccountCreateInput, ExternalAccountUncheckedCreateInput>
  }

  /**
   * ExternalAccount createMany
   */
  export type ExternalAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalAccounts.
     */
    data: ExternalAccountCreateManyInput | ExternalAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalAccount update
   */
  export type ExternalAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalAccount.
     */
    data: XOR<ExternalAccountUpdateInput, ExternalAccountUncheckedUpdateInput>
    /**
     * Choose, which ExternalAccount to update.
     */
    where: ExternalAccountWhereUniqueInput
  }

  /**
   * ExternalAccount updateMany
   */
  export type ExternalAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalAccounts.
     */
    data: XOR<ExternalAccountUpdateManyMutationInput, ExternalAccountUncheckedUpdateManyInput>
    /**
     * Filter which ExternalAccounts to update
     */
    where?: ExternalAccountWhereInput
    /**
     * Limit how many ExternalAccounts to update.
     */
    limit?: number
  }

  /**
   * ExternalAccount upsert
   */
  export type ExternalAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalAccount to update in case it exists.
     */
    where: ExternalAccountWhereUniqueInput
    /**
     * In case the ExternalAccount found by the `where` argument doesn't exist, create a new ExternalAccount with this data.
     */
    create: XOR<ExternalAccountCreateInput, ExternalAccountUncheckedCreateInput>
    /**
     * In case the ExternalAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalAccountUpdateInput, ExternalAccountUncheckedUpdateInput>
  }

  /**
   * ExternalAccount delete
   */
  export type ExternalAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
    /**
     * Filter which ExternalAccount to delete.
     */
    where: ExternalAccountWhereUniqueInput
  }

  /**
   * ExternalAccount deleteMany
   */
  export type ExternalAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalAccounts to delete
     */
    where?: ExternalAccountWhereInput
    /**
     * Limit how many ExternalAccounts to delete.
     */
    limit?: number
  }

  /**
   * ExternalAccount without action
   */
  export type ExternalAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalAccount
     */
    select?: ExternalAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalAccount
     */
    omit?: ExternalAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalAccountInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerification
   */

  export type AggregateEmailVerification = {
    _count: EmailVerificationCountAggregateOutputType | null
    _min: EmailVerificationMinAggregateOutputType | null
    _max: EmailVerificationMaxAggregateOutputType | null
  }

  export type EmailVerificationMinAggregateOutputType = {
    id: string | null
    token: string | null
    expiry: Date | null
    status: $Enums.EmailVerificationStatus | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailVerificationMaxAggregateOutputType = {
    id: string | null
    token: string | null
    expiry: Date | null
    status: $Enums.EmailVerificationStatus | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailVerificationCountAggregateOutputType = {
    id: number
    token: number
    expiry: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailVerificationMinAggregateInputType = {
    id?: true
    token?: true
    expiry?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailVerificationMaxAggregateInputType = {
    id?: true
    token?: true
    expiry?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailVerificationCountAggregateInputType = {
    id?: true
    token?: true
    expiry?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerification to aggregate.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerifications
    **/
    _count?: true | EmailVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationMaxAggregateInputType
  }

  export type GetEmailVerificationAggregateType<T extends EmailVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerification[P]>
      : GetScalarType<T[P], AggregateEmailVerification[P]>
  }




  export type EmailVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationWhereInput
    orderBy?: EmailVerificationOrderByWithAggregationInput | EmailVerificationOrderByWithAggregationInput[]
    by: EmailVerificationScalarFieldEnum[] | EmailVerificationScalarFieldEnum
    having?: EmailVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationCountAggregateInputType | true
    _min?: EmailVerificationMinAggregateInputType
    _max?: EmailVerificationMaxAggregateInputType
  }

  export type EmailVerificationGroupByOutputType = {
    id: string
    token: string
    expiry: Date | null
    status: $Enums.EmailVerificationStatus
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailVerificationCountAggregateOutputType | null
    _min: EmailVerificationMinAggregateOutputType | null
    _max: EmailVerificationMaxAggregateOutputType | null
  }

  type GetEmailVerificationGroupByPayload<T extends EmailVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiry?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>



  export type EmailVerificationSelectScalar = {
    id?: boolean
    token?: boolean
    expiry?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiry" | "status" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailVerification"]>
  export type EmailVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      expiry: Date | null
      status: $Enums.EmailVerificationStatus
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailVerification"]>
    composites: {}
  }

  type EmailVerificationGetPayload<S extends boolean | null | undefined | EmailVerificationDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationPayload, S>

  type EmailVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationCountAggregateInputType | true
    }

  export interface EmailVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerification'], meta: { name: 'EmailVerification' } }
    /**
     * Find zero or one EmailVerification that matches the filter.
     * @param {EmailVerificationFindUniqueArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationFindUniqueArgs>(args: SelectSubset<T, EmailVerificationFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationFindUniqueOrThrowArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindFirstArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationFindFirstArgs>(args?: SelectSubset<T, EmailVerificationFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindFirstOrThrowArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerifications
     * const emailVerifications = await prisma.emailVerification.findMany()
     * 
     * // Get first 10 EmailVerifications
     * const emailVerifications = await prisma.emailVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationFindManyArgs>(args?: SelectSubset<T, EmailVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerification.
     * @param {EmailVerificationCreateArgs} args - Arguments to create a EmailVerification.
     * @example
     * // Create one EmailVerification
     * const EmailVerification = await prisma.emailVerification.create({
     *   data: {
     *     // ... data to create a EmailVerification
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationCreateArgs>(args: SelectSubset<T, EmailVerificationCreateArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerifications.
     * @param {EmailVerificationCreateManyArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerification = await prisma.emailVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationCreateManyArgs>(args?: SelectSubset<T, EmailVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailVerification.
     * @param {EmailVerificationDeleteArgs} args - Arguments to delete one EmailVerification.
     * @example
     * // Delete one EmailVerification
     * const EmailVerification = await prisma.emailVerification.delete({
     *   where: {
     *     // ... filter to delete one EmailVerification
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationDeleteArgs>(args: SelectSubset<T, EmailVerificationDeleteArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerification.
     * @param {EmailVerificationUpdateArgs} args - Arguments to update one EmailVerification.
     * @example
     * // Update one EmailVerification
     * const emailVerification = await prisma.emailVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationUpdateArgs>(args: SelectSubset<T, EmailVerificationUpdateArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerifications.
     * @param {EmailVerificationDeleteManyArgs} args - Arguments to filter EmailVerifications to delete.
     * @example
     * // Delete a few EmailVerifications
     * const { count } = await prisma.emailVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerifications
     * const emailVerification = await prisma.emailVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationUpdateManyArgs>(args: SelectSubset<T, EmailVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailVerification.
     * @param {EmailVerificationUpsertArgs} args - Arguments to update or create a EmailVerification.
     * @example
     * // Update or create a EmailVerification
     * const emailVerification = await prisma.emailVerification.upsert({
     *   create: {
     *     // ... data to create a EmailVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerification we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationUpsertArgs>(args: SelectSubset<T, EmailVerificationUpsertArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationCountArgs} args - Arguments to filter EmailVerifications to count.
     * @example
     * // Count the number of EmailVerifications
     * const count = await prisma.emailVerification.count({
     *   where: {
     *     // ... the filter for the EmailVerifications we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationCountArgs>(
      args?: Subset<T, EmailVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationAggregateArgs>(args: Subset<T, EmailVerificationAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationAggregateType<T>>

    /**
     * Group by EmailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerification model
   */
  readonly fields: EmailVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerification model
   */
  interface EmailVerificationFieldRefs {
    readonly id: FieldRef<"EmailVerification", 'String'>
    readonly token: FieldRef<"EmailVerification", 'String'>
    readonly expiry: FieldRef<"EmailVerification", 'DateTime'>
    readonly status: FieldRef<"EmailVerification", 'EmailVerificationStatus'>
    readonly userId: FieldRef<"EmailVerification", 'String'>
    readonly createdAt: FieldRef<"EmailVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerification findUnique
   */
  export type EmailVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification findUniqueOrThrow
   */
  export type EmailVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification findFirst
   */
  export type EmailVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification findFirstOrThrow
   */
  export type EmailVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification findMany
   */
  export type EmailVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification create
   */
  export type EmailVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerification.
     */
    data: XOR<EmailVerificationCreateInput, EmailVerificationUncheckedCreateInput>
  }

  /**
   * EmailVerification createMany
   */
  export type EmailVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationCreateManyInput | EmailVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerification update
   */
  export type EmailVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerification.
     */
    data: XOR<EmailVerificationUpdateInput, EmailVerificationUncheckedUpdateInput>
    /**
     * Choose, which EmailVerification to update.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification updateMany
   */
  export type EmailVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerifications.
     */
    data: XOR<EmailVerificationUpdateManyMutationInput, EmailVerificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerifications to update
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to update.
     */
    limit?: number
  }

  /**
   * EmailVerification upsert
   */
  export type EmailVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerification to update in case it exists.
     */
    where: EmailVerificationWhereUniqueInput
    /**
     * In case the EmailVerification found by the `where` argument doesn't exist, create a new EmailVerification with this data.
     */
    create: XOR<EmailVerificationCreateInput, EmailVerificationUncheckedCreateInput>
    /**
     * In case the EmailVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationUpdateInput, EmailVerificationUncheckedUpdateInput>
  }

  /**
   * EmailVerification delete
   */
  export type EmailVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter which EmailVerification to delete.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification deleteMany
   */
  export type EmailVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerifications to delete
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to delete.
     */
    limit?: number
  }

  /**
   * EmailVerification without action
   */
  export type EmailVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: string | null
    token: string | null
    expiry: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: string | null
    token: string | null
    expiry: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    token: number
    expiry: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordResetMinAggregateInputType = {
    id?: true
    token?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    token?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    token?: true
    expiry?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: string
    token: string
    expiry: Date
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiry?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>



  export type PasswordResetSelectScalar = {
    id?: boolean
    token?: boolean
    expiry?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordResetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiry" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordReset"]>
  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      expiry: Date
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'String'>
    readonly token: FieldRef<"PasswordReset", 'String'>
    readonly expiry: FieldRef<"PasswordReset", 'DateTime'>
    readonly userId: FieldRef<"PasswordReset", 'String'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to update.
     */
    limit?: number
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
    /**
     * Limit how many PasswordResets to delete.
     */
    limit?: number
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordReset
     */
    omit?: PasswordResetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model MultiFactorAuthentication
   */

  export type AggregateMultiFactorAuthentication = {
    _count: MultiFactorAuthenticationCountAggregateOutputType | null
    _min: MultiFactorAuthenticationMinAggregateOutputType | null
    _max: MultiFactorAuthenticationMaxAggregateOutputType | null
  }

  export type MultiFactorAuthenticationMinAggregateOutputType = {
    id: string | null
    totpId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MultiFactorAuthenticationMaxAggregateOutputType = {
    id: string | null
    totpId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MultiFactorAuthenticationCountAggregateOutputType = {
    id: number
    totpId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MultiFactorAuthenticationMinAggregateInputType = {
    id?: true
    totpId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MultiFactorAuthenticationMaxAggregateInputType = {
    id?: true
    totpId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MultiFactorAuthenticationCountAggregateInputType = {
    id?: true
    totpId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MultiFactorAuthenticationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiFactorAuthentication to aggregate.
     */
    where?: MultiFactorAuthenticationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuthentications to fetch.
     */
    orderBy?: MultiFactorAuthenticationOrderByWithRelationInput | MultiFactorAuthenticationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultiFactorAuthenticationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuthentications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuthentications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultiFactorAuthentications
    **/
    _count?: true | MultiFactorAuthenticationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultiFactorAuthenticationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultiFactorAuthenticationMaxAggregateInputType
  }

  export type GetMultiFactorAuthenticationAggregateType<T extends MultiFactorAuthenticationAggregateArgs> = {
        [P in keyof T & keyof AggregateMultiFactorAuthentication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultiFactorAuthentication[P]>
      : GetScalarType<T[P], AggregateMultiFactorAuthentication[P]>
  }




  export type MultiFactorAuthenticationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultiFactorAuthenticationWhereInput
    orderBy?: MultiFactorAuthenticationOrderByWithAggregationInput | MultiFactorAuthenticationOrderByWithAggregationInput[]
    by: MultiFactorAuthenticationScalarFieldEnum[] | MultiFactorAuthenticationScalarFieldEnum
    having?: MultiFactorAuthenticationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultiFactorAuthenticationCountAggregateInputType | true
    _min?: MultiFactorAuthenticationMinAggregateInputType
    _max?: MultiFactorAuthenticationMaxAggregateInputType
  }

  export type MultiFactorAuthenticationGroupByOutputType = {
    id: string
    totpId: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MultiFactorAuthenticationCountAggregateOutputType | null
    _min: MultiFactorAuthenticationMinAggregateOutputType | null
    _max: MultiFactorAuthenticationMaxAggregateOutputType | null
  }

  type GetMultiFactorAuthenticationGroupByPayload<T extends MultiFactorAuthenticationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultiFactorAuthenticationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultiFactorAuthenticationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultiFactorAuthenticationGroupByOutputType[P]>
            : GetScalarType<T[P], MultiFactorAuthenticationGroupByOutputType[P]>
        }
      >
    >


  export type MultiFactorAuthenticationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totpId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    passkeys?: boolean | MultiFactorAuthentication$passkeysArgs<ExtArgs>
    totp?: boolean | MultiFactorAuthentication$totpArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MultiFactorAuthenticationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multiFactorAuthentication"]>



  export type MultiFactorAuthenticationSelectScalar = {
    id?: boolean
    totpId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MultiFactorAuthenticationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totpId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["multiFactorAuthentication"]>
  export type MultiFactorAuthenticationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passkeys?: boolean | MultiFactorAuthentication$passkeysArgs<ExtArgs>
    totp?: boolean | MultiFactorAuthentication$totpArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | MultiFactorAuthenticationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MultiFactorAuthenticationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultiFactorAuthentication"
    objects: {
      passkeys: Prisma.$PasskeyPayload<ExtArgs>[]
      totp: Prisma.$TotpPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      totpId: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["multiFactorAuthentication"]>
    composites: {}
  }

  type MultiFactorAuthenticationGetPayload<S extends boolean | null | undefined | MultiFactorAuthenticationDefaultArgs> = $Result.GetResult<Prisma.$MultiFactorAuthenticationPayload, S>

  type MultiFactorAuthenticationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultiFactorAuthenticationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultiFactorAuthenticationCountAggregateInputType | true
    }

  export interface MultiFactorAuthenticationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultiFactorAuthentication'], meta: { name: 'MultiFactorAuthentication' } }
    /**
     * Find zero or one MultiFactorAuthentication that matches the filter.
     * @param {MultiFactorAuthenticationFindUniqueArgs} args - Arguments to find a MultiFactorAuthentication
     * @example
     * // Get one MultiFactorAuthentication
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultiFactorAuthenticationFindUniqueArgs>(args: SelectSubset<T, MultiFactorAuthenticationFindUniqueArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultiFactorAuthentication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultiFactorAuthenticationFindUniqueOrThrowArgs} args - Arguments to find a MultiFactorAuthentication
     * @example
     * // Get one MultiFactorAuthentication
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultiFactorAuthenticationFindUniqueOrThrowArgs>(args: SelectSubset<T, MultiFactorAuthenticationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiFactorAuthentication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationFindFirstArgs} args - Arguments to find a MultiFactorAuthentication
     * @example
     * // Get one MultiFactorAuthentication
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultiFactorAuthenticationFindFirstArgs>(args?: SelectSubset<T, MultiFactorAuthenticationFindFirstArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultiFactorAuthentication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationFindFirstOrThrowArgs} args - Arguments to find a MultiFactorAuthentication
     * @example
     * // Get one MultiFactorAuthentication
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultiFactorAuthenticationFindFirstOrThrowArgs>(args?: SelectSubset<T, MultiFactorAuthenticationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultiFactorAuthentications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultiFactorAuthentications
     * const multiFactorAuthentications = await prisma.multiFactorAuthentication.findMany()
     * 
     * // Get first 10 MultiFactorAuthentications
     * const multiFactorAuthentications = await prisma.multiFactorAuthentication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multiFactorAuthenticationWithIdOnly = await prisma.multiFactorAuthentication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultiFactorAuthenticationFindManyArgs>(args?: SelectSubset<T, MultiFactorAuthenticationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultiFactorAuthentication.
     * @param {MultiFactorAuthenticationCreateArgs} args - Arguments to create a MultiFactorAuthentication.
     * @example
     * // Create one MultiFactorAuthentication
     * const MultiFactorAuthentication = await prisma.multiFactorAuthentication.create({
     *   data: {
     *     // ... data to create a MultiFactorAuthentication
     *   }
     * })
     * 
     */
    create<T extends MultiFactorAuthenticationCreateArgs>(args: SelectSubset<T, MultiFactorAuthenticationCreateArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultiFactorAuthentications.
     * @param {MultiFactorAuthenticationCreateManyArgs} args - Arguments to create many MultiFactorAuthentications.
     * @example
     * // Create many MultiFactorAuthentications
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultiFactorAuthenticationCreateManyArgs>(args?: SelectSubset<T, MultiFactorAuthenticationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MultiFactorAuthentication.
     * @param {MultiFactorAuthenticationDeleteArgs} args - Arguments to delete one MultiFactorAuthentication.
     * @example
     * // Delete one MultiFactorAuthentication
     * const MultiFactorAuthentication = await prisma.multiFactorAuthentication.delete({
     *   where: {
     *     // ... filter to delete one MultiFactorAuthentication
     *   }
     * })
     * 
     */
    delete<T extends MultiFactorAuthenticationDeleteArgs>(args: SelectSubset<T, MultiFactorAuthenticationDeleteArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultiFactorAuthentication.
     * @param {MultiFactorAuthenticationUpdateArgs} args - Arguments to update one MultiFactorAuthentication.
     * @example
     * // Update one MultiFactorAuthentication
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultiFactorAuthenticationUpdateArgs>(args: SelectSubset<T, MultiFactorAuthenticationUpdateArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultiFactorAuthentications.
     * @param {MultiFactorAuthenticationDeleteManyArgs} args - Arguments to filter MultiFactorAuthentications to delete.
     * @example
     * // Delete a few MultiFactorAuthentications
     * const { count } = await prisma.multiFactorAuthentication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultiFactorAuthenticationDeleteManyArgs>(args?: SelectSubset<T, MultiFactorAuthenticationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultiFactorAuthentications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultiFactorAuthentications
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultiFactorAuthenticationUpdateManyArgs>(args: SelectSubset<T, MultiFactorAuthenticationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MultiFactorAuthentication.
     * @param {MultiFactorAuthenticationUpsertArgs} args - Arguments to update or create a MultiFactorAuthentication.
     * @example
     * // Update or create a MultiFactorAuthentication
     * const multiFactorAuthentication = await prisma.multiFactorAuthentication.upsert({
     *   create: {
     *     // ... data to create a MultiFactorAuthentication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultiFactorAuthentication we want to update
     *   }
     * })
     */
    upsert<T extends MultiFactorAuthenticationUpsertArgs>(args: SelectSubset<T, MultiFactorAuthenticationUpsertArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultiFactorAuthentications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationCountArgs} args - Arguments to filter MultiFactorAuthentications to count.
     * @example
     * // Count the number of MultiFactorAuthentications
     * const count = await prisma.multiFactorAuthentication.count({
     *   where: {
     *     // ... the filter for the MultiFactorAuthentications we want to count
     *   }
     * })
    **/
    count<T extends MultiFactorAuthenticationCountArgs>(
      args?: Subset<T, MultiFactorAuthenticationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultiFactorAuthenticationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultiFactorAuthentication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultiFactorAuthenticationAggregateArgs>(args: Subset<T, MultiFactorAuthenticationAggregateArgs>): Prisma.PrismaPromise<GetMultiFactorAuthenticationAggregateType<T>>

    /**
     * Group by MultiFactorAuthentication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultiFactorAuthenticationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultiFactorAuthenticationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultiFactorAuthenticationGroupByArgs['orderBy'] }
        : { orderBy?: MultiFactorAuthenticationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultiFactorAuthenticationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultiFactorAuthenticationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultiFactorAuthentication model
   */
  readonly fields: MultiFactorAuthenticationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultiFactorAuthentication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultiFactorAuthenticationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passkeys<T extends MultiFactorAuthentication$passkeysArgs<ExtArgs> = {}>(args?: Subset<T, MultiFactorAuthentication$passkeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    totp<T extends MultiFactorAuthentication$totpArgs<ExtArgs> = {}>(args?: Subset<T, MultiFactorAuthentication$totpArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultiFactorAuthentication model
   */
  interface MultiFactorAuthenticationFieldRefs {
    readonly id: FieldRef<"MultiFactorAuthentication", 'String'>
    readonly totpId: FieldRef<"MultiFactorAuthentication", 'String'>
    readonly userId: FieldRef<"MultiFactorAuthentication", 'String'>
    readonly createdAt: FieldRef<"MultiFactorAuthentication", 'DateTime'>
    readonly updatedAt: FieldRef<"MultiFactorAuthentication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultiFactorAuthentication findUnique
   */
  export type MultiFactorAuthenticationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuthentication to fetch.
     */
    where: MultiFactorAuthenticationWhereUniqueInput
  }

  /**
   * MultiFactorAuthentication findUniqueOrThrow
   */
  export type MultiFactorAuthenticationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuthentication to fetch.
     */
    where: MultiFactorAuthenticationWhereUniqueInput
  }

  /**
   * MultiFactorAuthentication findFirst
   */
  export type MultiFactorAuthenticationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuthentication to fetch.
     */
    where?: MultiFactorAuthenticationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuthentications to fetch.
     */
    orderBy?: MultiFactorAuthenticationOrderByWithRelationInput | MultiFactorAuthenticationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiFactorAuthentications.
     */
    cursor?: MultiFactorAuthenticationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuthentications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuthentications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiFactorAuthentications.
     */
    distinct?: MultiFactorAuthenticationScalarFieldEnum | MultiFactorAuthenticationScalarFieldEnum[]
  }

  /**
   * MultiFactorAuthentication findFirstOrThrow
   */
  export type MultiFactorAuthenticationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuthentication to fetch.
     */
    where?: MultiFactorAuthenticationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuthentications to fetch.
     */
    orderBy?: MultiFactorAuthenticationOrderByWithRelationInput | MultiFactorAuthenticationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultiFactorAuthentications.
     */
    cursor?: MultiFactorAuthenticationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuthentications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuthentications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultiFactorAuthentications.
     */
    distinct?: MultiFactorAuthenticationScalarFieldEnum | MultiFactorAuthenticationScalarFieldEnum[]
  }

  /**
   * MultiFactorAuthentication findMany
   */
  export type MultiFactorAuthenticationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * Filter, which MultiFactorAuthentications to fetch.
     */
    where?: MultiFactorAuthenticationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultiFactorAuthentications to fetch.
     */
    orderBy?: MultiFactorAuthenticationOrderByWithRelationInput | MultiFactorAuthenticationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultiFactorAuthentications.
     */
    cursor?: MultiFactorAuthenticationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultiFactorAuthentications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultiFactorAuthentications.
     */
    skip?: number
    distinct?: MultiFactorAuthenticationScalarFieldEnum | MultiFactorAuthenticationScalarFieldEnum[]
  }

  /**
   * MultiFactorAuthentication create
   */
  export type MultiFactorAuthenticationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * The data needed to create a MultiFactorAuthentication.
     */
    data: XOR<MultiFactorAuthenticationCreateInput, MultiFactorAuthenticationUncheckedCreateInput>
  }

  /**
   * MultiFactorAuthentication createMany
   */
  export type MultiFactorAuthenticationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultiFactorAuthentications.
     */
    data: MultiFactorAuthenticationCreateManyInput | MultiFactorAuthenticationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultiFactorAuthentication update
   */
  export type MultiFactorAuthenticationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * The data needed to update a MultiFactorAuthentication.
     */
    data: XOR<MultiFactorAuthenticationUpdateInput, MultiFactorAuthenticationUncheckedUpdateInput>
    /**
     * Choose, which MultiFactorAuthentication to update.
     */
    where: MultiFactorAuthenticationWhereUniqueInput
  }

  /**
   * MultiFactorAuthentication updateMany
   */
  export type MultiFactorAuthenticationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultiFactorAuthentications.
     */
    data: XOR<MultiFactorAuthenticationUpdateManyMutationInput, MultiFactorAuthenticationUncheckedUpdateManyInput>
    /**
     * Filter which MultiFactorAuthentications to update
     */
    where?: MultiFactorAuthenticationWhereInput
    /**
     * Limit how many MultiFactorAuthentications to update.
     */
    limit?: number
  }

  /**
   * MultiFactorAuthentication upsert
   */
  export type MultiFactorAuthenticationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * The filter to search for the MultiFactorAuthentication to update in case it exists.
     */
    where: MultiFactorAuthenticationWhereUniqueInput
    /**
     * In case the MultiFactorAuthentication found by the `where` argument doesn't exist, create a new MultiFactorAuthentication with this data.
     */
    create: XOR<MultiFactorAuthenticationCreateInput, MultiFactorAuthenticationUncheckedCreateInput>
    /**
     * In case the MultiFactorAuthentication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultiFactorAuthenticationUpdateInput, MultiFactorAuthenticationUncheckedUpdateInput>
  }

  /**
   * MultiFactorAuthentication delete
   */
  export type MultiFactorAuthenticationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    /**
     * Filter which MultiFactorAuthentication to delete.
     */
    where: MultiFactorAuthenticationWhereUniqueInput
  }

  /**
   * MultiFactorAuthentication deleteMany
   */
  export type MultiFactorAuthenticationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultiFactorAuthentications to delete
     */
    where?: MultiFactorAuthenticationWhereInput
    /**
     * Limit how many MultiFactorAuthentications to delete.
     */
    limit?: number
  }

  /**
   * MultiFactorAuthentication.passkeys
   */
  export type MultiFactorAuthentication$passkeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    where?: PasskeyWhereInput
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    cursor?: PasskeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * MultiFactorAuthentication.totp
   */
  export type MultiFactorAuthentication$totpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    where?: TotpWhereInput
  }

  /**
   * MultiFactorAuthentication without action
   */
  export type MultiFactorAuthenticationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
  }


  /**
   * Model Totp
   */

  export type AggregateTotp = {
    _count: TotpCountAggregateOutputType | null
    _min: TotpMinAggregateOutputType | null
    _max: TotpMaxAggregateOutputType | null
  }

  export type TotpMinAggregateOutputType = {
    id: string | null
    status: $Enums.TotpStatus | null
    secret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TotpMaxAggregateOutputType = {
    id: string | null
    status: $Enums.TotpStatus | null
    secret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TotpCountAggregateOutputType = {
    id: number
    status: number
    secret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TotpMinAggregateInputType = {
    id?: true
    status?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TotpMaxAggregateInputType = {
    id?: true
    status?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TotpCountAggregateInputType = {
    id?: true
    status?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TotpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Totp to aggregate.
     */
    where?: TotpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totps to fetch.
     */
    orderBy?: TotpOrderByWithRelationInput | TotpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TotpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Totps
    **/
    _count?: true | TotpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TotpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TotpMaxAggregateInputType
  }

  export type GetTotpAggregateType<T extends TotpAggregateArgs> = {
        [P in keyof T & keyof AggregateTotp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTotp[P]>
      : GetScalarType<T[P], AggregateTotp[P]>
  }




  export type TotpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TotpWhereInput
    orderBy?: TotpOrderByWithAggregationInput | TotpOrderByWithAggregationInput[]
    by: TotpScalarFieldEnum[] | TotpScalarFieldEnum
    having?: TotpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TotpCountAggregateInputType | true
    _min?: TotpMinAggregateInputType
    _max?: TotpMaxAggregateInputType
  }

  export type TotpGroupByOutputType = {
    id: string
    status: $Enums.TotpStatus
    secret: string | null
    createdAt: Date
    updatedAt: Date
    _count: TotpCountAggregateOutputType | null
    _min: TotpMinAggregateOutputType | null
    _max: TotpMaxAggregateOutputType | null
  }

  type GetTotpGroupByPayload<T extends TotpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TotpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TotpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TotpGroupByOutputType[P]>
            : GetScalarType<T[P], TotpGroupByOutputType[P]>
        }
      >
    >


  export type TotpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mfa?: boolean | Totp$mfaArgs<ExtArgs>
  }, ExtArgs["result"]["totp"]>



  export type TotpSelectScalar = {
    id?: boolean
    status?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TotpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "secret" | "createdAt" | "updatedAt", ExtArgs["result"]["totp"]>
  export type TotpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa?: boolean | Totp$mfaArgs<ExtArgs>
  }

  export type $TotpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Totp"
    objects: {
      mfa: Prisma.$MultiFactorAuthenticationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.TotpStatus
      secret: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["totp"]>
    composites: {}
  }

  type TotpGetPayload<S extends boolean | null | undefined | TotpDefaultArgs> = $Result.GetResult<Prisma.$TotpPayload, S>

  type TotpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TotpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TotpCountAggregateInputType | true
    }

  export interface TotpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Totp'], meta: { name: 'Totp' } }
    /**
     * Find zero or one Totp that matches the filter.
     * @param {TotpFindUniqueArgs} args - Arguments to find a Totp
     * @example
     * // Get one Totp
     * const totp = await prisma.totp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TotpFindUniqueArgs>(args: SelectSubset<T, TotpFindUniqueArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Totp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TotpFindUniqueOrThrowArgs} args - Arguments to find a Totp
     * @example
     * // Get one Totp
     * const totp = await prisma.totp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TotpFindUniqueOrThrowArgs>(args: SelectSubset<T, TotpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Totp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpFindFirstArgs} args - Arguments to find a Totp
     * @example
     * // Get one Totp
     * const totp = await prisma.totp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TotpFindFirstArgs>(args?: SelectSubset<T, TotpFindFirstArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Totp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpFindFirstOrThrowArgs} args - Arguments to find a Totp
     * @example
     * // Get one Totp
     * const totp = await prisma.totp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TotpFindFirstOrThrowArgs>(args?: SelectSubset<T, TotpFindFirstOrThrowArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Totps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Totps
     * const totps = await prisma.totp.findMany()
     * 
     * // Get first 10 Totps
     * const totps = await prisma.totp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const totpWithIdOnly = await prisma.totp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TotpFindManyArgs>(args?: SelectSubset<T, TotpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Totp.
     * @param {TotpCreateArgs} args - Arguments to create a Totp.
     * @example
     * // Create one Totp
     * const Totp = await prisma.totp.create({
     *   data: {
     *     // ... data to create a Totp
     *   }
     * })
     * 
     */
    create<T extends TotpCreateArgs>(args: SelectSubset<T, TotpCreateArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Totps.
     * @param {TotpCreateManyArgs} args - Arguments to create many Totps.
     * @example
     * // Create many Totps
     * const totp = await prisma.totp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TotpCreateManyArgs>(args?: SelectSubset<T, TotpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Totp.
     * @param {TotpDeleteArgs} args - Arguments to delete one Totp.
     * @example
     * // Delete one Totp
     * const Totp = await prisma.totp.delete({
     *   where: {
     *     // ... filter to delete one Totp
     *   }
     * })
     * 
     */
    delete<T extends TotpDeleteArgs>(args: SelectSubset<T, TotpDeleteArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Totp.
     * @param {TotpUpdateArgs} args - Arguments to update one Totp.
     * @example
     * // Update one Totp
     * const totp = await prisma.totp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TotpUpdateArgs>(args: SelectSubset<T, TotpUpdateArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Totps.
     * @param {TotpDeleteManyArgs} args - Arguments to filter Totps to delete.
     * @example
     * // Delete a few Totps
     * const { count } = await prisma.totp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TotpDeleteManyArgs>(args?: SelectSubset<T, TotpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Totps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Totps
     * const totp = await prisma.totp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TotpUpdateManyArgs>(args: SelectSubset<T, TotpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Totp.
     * @param {TotpUpsertArgs} args - Arguments to update or create a Totp.
     * @example
     * // Update or create a Totp
     * const totp = await prisma.totp.upsert({
     *   create: {
     *     // ... data to create a Totp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Totp we want to update
     *   }
     * })
     */
    upsert<T extends TotpUpsertArgs>(args: SelectSubset<T, TotpUpsertArgs<ExtArgs>>): Prisma__TotpClient<$Result.GetResult<Prisma.$TotpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Totps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpCountArgs} args - Arguments to filter Totps to count.
     * @example
     * // Count the number of Totps
     * const count = await prisma.totp.count({
     *   where: {
     *     // ... the filter for the Totps we want to count
     *   }
     * })
    **/
    count<T extends TotpCountArgs>(
      args?: Subset<T, TotpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TotpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Totp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TotpAggregateArgs>(args: Subset<T, TotpAggregateArgs>): Prisma.PrismaPromise<GetTotpAggregateType<T>>

    /**
     * Group by Totp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TotpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TotpGroupByArgs['orderBy'] }
        : { orderBy?: TotpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TotpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTotpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Totp model
   */
  readonly fields: TotpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Totp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TotpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mfa<T extends Totp$mfaArgs<ExtArgs> = {}>(args?: Subset<T, Totp$mfaArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Totp model
   */
  interface TotpFieldRefs {
    readonly id: FieldRef<"Totp", 'String'>
    readonly status: FieldRef<"Totp", 'TotpStatus'>
    readonly secret: FieldRef<"Totp", 'String'>
    readonly createdAt: FieldRef<"Totp", 'DateTime'>
    readonly updatedAt: FieldRef<"Totp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Totp findUnique
   */
  export type TotpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * Filter, which Totp to fetch.
     */
    where: TotpWhereUniqueInput
  }

  /**
   * Totp findUniqueOrThrow
   */
  export type TotpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * Filter, which Totp to fetch.
     */
    where: TotpWhereUniqueInput
  }

  /**
   * Totp findFirst
   */
  export type TotpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * Filter, which Totp to fetch.
     */
    where?: TotpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totps to fetch.
     */
    orderBy?: TotpOrderByWithRelationInput | TotpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Totps.
     */
    cursor?: TotpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Totps.
     */
    distinct?: TotpScalarFieldEnum | TotpScalarFieldEnum[]
  }

  /**
   * Totp findFirstOrThrow
   */
  export type TotpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * Filter, which Totp to fetch.
     */
    where?: TotpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totps to fetch.
     */
    orderBy?: TotpOrderByWithRelationInput | TotpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Totps.
     */
    cursor?: TotpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Totps.
     */
    distinct?: TotpScalarFieldEnum | TotpScalarFieldEnum[]
  }

  /**
   * Totp findMany
   */
  export type TotpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * Filter, which Totps to fetch.
     */
    where?: TotpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totps to fetch.
     */
    orderBy?: TotpOrderByWithRelationInput | TotpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Totps.
     */
    cursor?: TotpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totps.
     */
    skip?: number
    distinct?: TotpScalarFieldEnum | TotpScalarFieldEnum[]
  }

  /**
   * Totp create
   */
  export type TotpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * The data needed to create a Totp.
     */
    data: XOR<TotpCreateInput, TotpUncheckedCreateInput>
  }

  /**
   * Totp createMany
   */
  export type TotpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Totps.
     */
    data: TotpCreateManyInput | TotpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Totp update
   */
  export type TotpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * The data needed to update a Totp.
     */
    data: XOR<TotpUpdateInput, TotpUncheckedUpdateInput>
    /**
     * Choose, which Totp to update.
     */
    where: TotpWhereUniqueInput
  }

  /**
   * Totp updateMany
   */
  export type TotpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Totps.
     */
    data: XOR<TotpUpdateManyMutationInput, TotpUncheckedUpdateManyInput>
    /**
     * Filter which Totps to update
     */
    where?: TotpWhereInput
    /**
     * Limit how many Totps to update.
     */
    limit?: number
  }

  /**
   * Totp upsert
   */
  export type TotpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * The filter to search for the Totp to update in case it exists.
     */
    where: TotpWhereUniqueInput
    /**
     * In case the Totp found by the `where` argument doesn't exist, create a new Totp with this data.
     */
    create: XOR<TotpCreateInput, TotpUncheckedCreateInput>
    /**
     * In case the Totp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TotpUpdateInput, TotpUncheckedUpdateInput>
  }

  /**
   * Totp delete
   */
  export type TotpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
    /**
     * Filter which Totp to delete.
     */
    where: TotpWhereUniqueInput
  }

  /**
   * Totp deleteMany
   */
  export type TotpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Totps to delete
     */
    where?: TotpWhereInput
    /**
     * Limit how many Totps to delete.
     */
    limit?: number
  }

  /**
   * Totp.mfa
   */
  export type Totp$mfaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultiFactorAuthentication
     */
    select?: MultiFactorAuthenticationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultiFactorAuthentication
     */
    omit?: MultiFactorAuthenticationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultiFactorAuthenticationInclude<ExtArgs> | null
    where?: MultiFactorAuthenticationWhereInput
  }

  /**
   * Totp without action
   */
  export type TotpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Totp
     */
    select?: TotpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Totp
     */
    omit?: TotpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotpInclude<ExtArgs> | null
  }


  /**
   * Model Passkey
   */

  export type AggregatePasskey = {
    _count: PasskeyCountAggregateOutputType | null
    _avg: PasskeyAvgAggregateOutputType | null
    _sum: PasskeySumAggregateOutputType | null
    _min: PasskeyMinAggregateOutputType | null
    _max: PasskeyMaxAggregateOutputType | null
  }

  export type PasskeyAvgAggregateOutputType = {
    counter: number | null
  }

  export type PasskeySumAggregateOutputType = {
    counter: number | null
  }

  export type PasskeyMinAggregateOutputType = {
    id: string | null
    deviceName: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    lastUsedAt: Date | null
    ip: string | null
    userAgent: string | null
    mfaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasskeyMaxAggregateOutputType = {
    id: string | null
    deviceName: string | null
    credentialId: string | null
    publicKey: string | null
    counter: number | null
    lastUsedAt: Date | null
    ip: string | null
    userAgent: string | null
    mfaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasskeyCountAggregateOutputType = {
    id: number
    deviceName: number
    credentialId: number
    publicKey: number
    counter: number
    lastUsedAt: number
    ip: number
    userAgent: number
    mfaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasskeyAvgAggregateInputType = {
    counter?: true
  }

  export type PasskeySumAggregateInputType = {
    counter?: true
  }

  export type PasskeyMinAggregateInputType = {
    id?: true
    deviceName?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    lastUsedAt?: true
    ip?: true
    userAgent?: true
    mfaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasskeyMaxAggregateInputType = {
    id?: true
    deviceName?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    lastUsedAt?: true
    ip?: true
    userAgent?: true
    mfaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasskeyCountAggregateInputType = {
    id?: true
    deviceName?: true
    credentialId?: true
    publicKey?: true
    counter?: true
    lastUsedAt?: true
    ip?: true
    userAgent?: true
    mfaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasskeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passkey to aggregate.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passkeys
    **/
    _count?: true | PasskeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasskeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasskeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasskeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasskeyMaxAggregateInputType
  }

  export type GetPasskeyAggregateType<T extends PasskeyAggregateArgs> = {
        [P in keyof T & keyof AggregatePasskey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasskey[P]>
      : GetScalarType<T[P], AggregatePasskey[P]>
  }




  export type PasskeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasskeyWhereInput
    orderBy?: PasskeyOrderByWithAggregationInput | PasskeyOrderByWithAggregationInput[]
    by: PasskeyScalarFieldEnum[] | PasskeyScalarFieldEnum
    having?: PasskeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasskeyCountAggregateInputType | true
    _avg?: PasskeyAvgAggregateInputType
    _sum?: PasskeySumAggregateInputType
    _min?: PasskeyMinAggregateInputType
    _max?: PasskeyMaxAggregateInputType
  }

  export type PasskeyGroupByOutputType = {
    id: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter: number
    lastUsedAt: Date | null
    ip: string
    userAgent: string
    mfaId: string
    createdAt: Date
    updatedAt: Date
    _count: PasskeyCountAggregateOutputType | null
    _avg: PasskeyAvgAggregateOutputType | null
    _sum: PasskeySumAggregateOutputType | null
    _min: PasskeyMinAggregateOutputType | null
    _max: PasskeyMaxAggregateOutputType | null
  }

  type GetPasskeyGroupByPayload<T extends PasskeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasskeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasskeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasskeyGroupByOutputType[P]>
            : GetScalarType<T[P], PasskeyGroupByOutputType[P]>
        }
      >
    >


  export type PasskeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceName?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    lastUsedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    mfaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mfa?: boolean | MultiFactorAuthenticationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passkey"]>



  export type PasskeySelectScalar = {
    id?: boolean
    deviceName?: boolean
    credentialId?: boolean
    publicKey?: boolean
    counter?: boolean
    lastUsedAt?: boolean
    ip?: boolean
    userAgent?: boolean
    mfaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasskeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceName" | "credentialId" | "publicKey" | "counter" | "lastUsedAt" | "ip" | "userAgent" | "mfaId" | "createdAt" | "updatedAt", ExtArgs["result"]["passkey"]>
  export type PasskeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mfa?: boolean | MultiFactorAuthenticationDefaultArgs<ExtArgs>
  }

  export type $PasskeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passkey"
    objects: {
      mfa: Prisma.$MultiFactorAuthenticationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceName: string
      credentialId: string
      publicKey: string
      counter: number
      lastUsedAt: Date | null
      ip: string
      userAgent: string
      mfaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passkey"]>
    composites: {}
  }

  type PasskeyGetPayload<S extends boolean | null | undefined | PasskeyDefaultArgs> = $Result.GetResult<Prisma.$PasskeyPayload, S>

  type PasskeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasskeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasskeyCountAggregateInputType | true
    }

  export interface PasskeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passkey'], meta: { name: 'Passkey' } }
    /**
     * Find zero or one Passkey that matches the filter.
     * @param {PasskeyFindUniqueArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasskeyFindUniqueArgs>(args: SelectSubset<T, PasskeyFindUniqueArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passkey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasskeyFindUniqueOrThrowArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasskeyFindUniqueOrThrowArgs>(args: SelectSubset<T, PasskeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passkey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindFirstArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasskeyFindFirstArgs>(args?: SelectSubset<T, PasskeyFindFirstArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passkey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindFirstOrThrowArgs} args - Arguments to find a Passkey
     * @example
     * // Get one Passkey
     * const passkey = await prisma.passkey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasskeyFindFirstOrThrowArgs>(args?: SelectSubset<T, PasskeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passkeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passkeys
     * const passkeys = await prisma.passkey.findMany()
     * 
     * // Get first 10 Passkeys
     * const passkeys = await prisma.passkey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passkeyWithIdOnly = await prisma.passkey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasskeyFindManyArgs>(args?: SelectSubset<T, PasskeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passkey.
     * @param {PasskeyCreateArgs} args - Arguments to create a Passkey.
     * @example
     * // Create one Passkey
     * const Passkey = await prisma.passkey.create({
     *   data: {
     *     // ... data to create a Passkey
     *   }
     * })
     * 
     */
    create<T extends PasskeyCreateArgs>(args: SelectSubset<T, PasskeyCreateArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passkeys.
     * @param {PasskeyCreateManyArgs} args - Arguments to create many Passkeys.
     * @example
     * // Create many Passkeys
     * const passkey = await prisma.passkey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasskeyCreateManyArgs>(args?: SelectSubset<T, PasskeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Passkey.
     * @param {PasskeyDeleteArgs} args - Arguments to delete one Passkey.
     * @example
     * // Delete one Passkey
     * const Passkey = await prisma.passkey.delete({
     *   where: {
     *     // ... filter to delete one Passkey
     *   }
     * })
     * 
     */
    delete<T extends PasskeyDeleteArgs>(args: SelectSubset<T, PasskeyDeleteArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passkey.
     * @param {PasskeyUpdateArgs} args - Arguments to update one Passkey.
     * @example
     * // Update one Passkey
     * const passkey = await prisma.passkey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasskeyUpdateArgs>(args: SelectSubset<T, PasskeyUpdateArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passkeys.
     * @param {PasskeyDeleteManyArgs} args - Arguments to filter Passkeys to delete.
     * @example
     * // Delete a few Passkeys
     * const { count } = await prisma.passkey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasskeyDeleteManyArgs>(args?: SelectSubset<T, PasskeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passkeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passkeys
     * const passkey = await prisma.passkey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasskeyUpdateManyArgs>(args: SelectSubset<T, PasskeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Passkey.
     * @param {PasskeyUpsertArgs} args - Arguments to update or create a Passkey.
     * @example
     * // Update or create a Passkey
     * const passkey = await prisma.passkey.upsert({
     *   create: {
     *     // ... data to create a Passkey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passkey we want to update
     *   }
     * })
     */
    upsert<T extends PasskeyUpsertArgs>(args: SelectSubset<T, PasskeyUpsertArgs<ExtArgs>>): Prisma__PasskeyClient<$Result.GetResult<Prisma.$PasskeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passkeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyCountArgs} args - Arguments to filter Passkeys to count.
     * @example
     * // Count the number of Passkeys
     * const count = await prisma.passkey.count({
     *   where: {
     *     // ... the filter for the Passkeys we want to count
     *   }
     * })
    **/
    count<T extends PasskeyCountArgs>(
      args?: Subset<T, PasskeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasskeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passkey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasskeyAggregateArgs>(args: Subset<T, PasskeyAggregateArgs>): Prisma.PrismaPromise<GetPasskeyAggregateType<T>>

    /**
     * Group by Passkey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasskeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasskeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasskeyGroupByArgs['orderBy'] }
        : { orderBy?: PasskeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasskeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasskeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passkey model
   */
  readonly fields: PasskeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passkey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasskeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mfa<T extends MultiFactorAuthenticationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MultiFactorAuthenticationDefaultArgs<ExtArgs>>): Prisma__MultiFactorAuthenticationClient<$Result.GetResult<Prisma.$MultiFactorAuthenticationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passkey model
   */
  interface PasskeyFieldRefs {
    readonly id: FieldRef<"Passkey", 'String'>
    readonly deviceName: FieldRef<"Passkey", 'String'>
    readonly credentialId: FieldRef<"Passkey", 'String'>
    readonly publicKey: FieldRef<"Passkey", 'String'>
    readonly counter: FieldRef<"Passkey", 'Int'>
    readonly lastUsedAt: FieldRef<"Passkey", 'DateTime'>
    readonly ip: FieldRef<"Passkey", 'String'>
    readonly userAgent: FieldRef<"Passkey", 'String'>
    readonly mfaId: FieldRef<"Passkey", 'String'>
    readonly createdAt: FieldRef<"Passkey", 'DateTime'>
    readonly updatedAt: FieldRef<"Passkey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Passkey findUnique
   */
  export type PasskeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey findUniqueOrThrow
   */
  export type PasskeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey findFirst
   */
  export type PasskeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passkeys.
     */
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey findFirstOrThrow
   */
  export type PasskeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkey to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passkeys.
     */
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey findMany
   */
  export type PasskeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter, which Passkeys to fetch.
     */
    where?: PasskeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passkeys to fetch.
     */
    orderBy?: PasskeyOrderByWithRelationInput | PasskeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passkeys.
     */
    cursor?: PasskeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passkeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passkeys.
     */
    skip?: number
    distinct?: PasskeyScalarFieldEnum | PasskeyScalarFieldEnum[]
  }

  /**
   * Passkey create
   */
  export type PasskeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The data needed to create a Passkey.
     */
    data: XOR<PasskeyCreateInput, PasskeyUncheckedCreateInput>
  }

  /**
   * Passkey createMany
   */
  export type PasskeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passkeys.
     */
    data: PasskeyCreateManyInput | PasskeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passkey update
   */
  export type PasskeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The data needed to update a Passkey.
     */
    data: XOR<PasskeyUpdateInput, PasskeyUncheckedUpdateInput>
    /**
     * Choose, which Passkey to update.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey updateMany
   */
  export type PasskeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passkeys.
     */
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyInput>
    /**
     * Filter which Passkeys to update
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to update.
     */
    limit?: number
  }

  /**
   * Passkey upsert
   */
  export type PasskeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * The filter to search for the Passkey to update in case it exists.
     */
    where: PasskeyWhereUniqueInput
    /**
     * In case the Passkey found by the `where` argument doesn't exist, create a new Passkey with this data.
     */
    create: XOR<PasskeyCreateInput, PasskeyUncheckedCreateInput>
    /**
     * In case the Passkey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasskeyUpdateInput, PasskeyUncheckedUpdateInput>
  }

  /**
   * Passkey delete
   */
  export type PasskeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
    /**
     * Filter which Passkey to delete.
     */
    where: PasskeyWhereUniqueInput
  }

  /**
   * Passkey deleteMany
   */
  export type PasskeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passkeys to delete
     */
    where?: PasskeyWhereInput
    /**
     * Limit how many Passkeys to delete.
     */
    limit?: number
  }

  /**
   * Passkey without action
   */
  export type PasskeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passkey
     */
    select?: PasskeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passkey
     */
    omit?: PasskeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasskeyInclude<ExtArgs> | null
  }


  /**
   * Model Restriction
   */

  export type AggregateRestriction = {
    _count: RestrictionCountAggregateOutputType | null
    _min: RestrictionMinAggregateOutputType | null
    _max: RestrictionMaxAggregateOutputType | null
  }

  export type RestrictionMinAggregateOutputType = {
    id: string | null
    reason: $Enums.RestrictionReason | null
    until: Date | null
    status: $Enums.RestrictionStatus | null
    userId: string | null
    createdAt: Date | null
  }

  export type RestrictionMaxAggregateOutputType = {
    id: string | null
    reason: $Enums.RestrictionReason | null
    until: Date | null
    status: $Enums.RestrictionStatus | null
    userId: string | null
    createdAt: Date | null
  }

  export type RestrictionCountAggregateOutputType = {
    id: number
    reason: number
    until: number
    status: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RestrictionMinAggregateInputType = {
    id?: true
    reason?: true
    until?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type RestrictionMaxAggregateInputType = {
    id?: true
    reason?: true
    until?: true
    status?: true
    userId?: true
    createdAt?: true
  }

  export type RestrictionCountAggregateInputType = {
    id?: true
    reason?: true
    until?: true
    status?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RestrictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restriction to aggregate.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Restrictions
    **/
    _count?: true | RestrictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestrictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestrictionMaxAggregateInputType
  }

  export type GetRestrictionAggregateType<T extends RestrictionAggregateArgs> = {
        [P in keyof T & keyof AggregateRestriction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestriction[P]>
      : GetScalarType<T[P], AggregateRestriction[P]>
  }




  export type RestrictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestrictionWhereInput
    orderBy?: RestrictionOrderByWithAggregationInput | RestrictionOrderByWithAggregationInput[]
    by: RestrictionScalarFieldEnum[] | RestrictionScalarFieldEnum
    having?: RestrictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestrictionCountAggregateInputType | true
    _min?: RestrictionMinAggregateInputType
    _max?: RestrictionMaxAggregateInputType
  }

  export type RestrictionGroupByOutputType = {
    id: string
    reason: $Enums.RestrictionReason
    until: Date | null
    status: $Enums.RestrictionStatus
    userId: string
    createdAt: Date
    _count: RestrictionCountAggregateOutputType | null
    _min: RestrictionMinAggregateOutputType | null
    _max: RestrictionMaxAggregateOutputType | null
  }

  type GetRestrictionGroupByPayload<T extends RestrictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestrictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestrictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestrictionGroupByOutputType[P]>
            : GetScalarType<T[P], RestrictionGroupByOutputType[P]>
        }
      >
    >


  export type RestrictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    until?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restriction"]>



  export type RestrictionSelectScalar = {
    id?: boolean
    reason?: boolean
    until?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type RestrictionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reason" | "until" | "status" | "userId" | "createdAt", ExtArgs["result"]["restriction"]>
  export type RestrictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RestrictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Restriction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reason: $Enums.RestrictionReason
      until: Date | null
      status: $Enums.RestrictionStatus
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["restriction"]>
    composites: {}
  }

  type RestrictionGetPayload<S extends boolean | null | undefined | RestrictionDefaultArgs> = $Result.GetResult<Prisma.$RestrictionPayload, S>

  type RestrictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestrictionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestrictionCountAggregateInputType | true
    }

  export interface RestrictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Restriction'], meta: { name: 'Restriction' } }
    /**
     * Find zero or one Restriction that matches the filter.
     * @param {RestrictionFindUniqueArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestrictionFindUniqueArgs>(args: SelectSubset<T, RestrictionFindUniqueArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Restriction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestrictionFindUniqueOrThrowArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestrictionFindUniqueOrThrowArgs>(args: SelectSubset<T, RestrictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Restriction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionFindFirstArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestrictionFindFirstArgs>(args?: SelectSubset<T, RestrictionFindFirstArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Restriction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionFindFirstOrThrowArgs} args - Arguments to find a Restriction
     * @example
     * // Get one Restriction
     * const restriction = await prisma.restriction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestrictionFindFirstOrThrowArgs>(args?: SelectSubset<T, RestrictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Restrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Restrictions
     * const restrictions = await prisma.restriction.findMany()
     * 
     * // Get first 10 Restrictions
     * const restrictions = await prisma.restriction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restrictionWithIdOnly = await prisma.restriction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestrictionFindManyArgs>(args?: SelectSubset<T, RestrictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Restriction.
     * @param {RestrictionCreateArgs} args - Arguments to create a Restriction.
     * @example
     * // Create one Restriction
     * const Restriction = await prisma.restriction.create({
     *   data: {
     *     // ... data to create a Restriction
     *   }
     * })
     * 
     */
    create<T extends RestrictionCreateArgs>(args: SelectSubset<T, RestrictionCreateArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Restrictions.
     * @param {RestrictionCreateManyArgs} args - Arguments to create many Restrictions.
     * @example
     * // Create many Restrictions
     * const restriction = await prisma.restriction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestrictionCreateManyArgs>(args?: SelectSubset<T, RestrictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Restriction.
     * @param {RestrictionDeleteArgs} args - Arguments to delete one Restriction.
     * @example
     * // Delete one Restriction
     * const Restriction = await prisma.restriction.delete({
     *   where: {
     *     // ... filter to delete one Restriction
     *   }
     * })
     * 
     */
    delete<T extends RestrictionDeleteArgs>(args: SelectSubset<T, RestrictionDeleteArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Restriction.
     * @param {RestrictionUpdateArgs} args - Arguments to update one Restriction.
     * @example
     * // Update one Restriction
     * const restriction = await prisma.restriction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestrictionUpdateArgs>(args: SelectSubset<T, RestrictionUpdateArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Restrictions.
     * @param {RestrictionDeleteManyArgs} args - Arguments to filter Restrictions to delete.
     * @example
     * // Delete a few Restrictions
     * const { count } = await prisma.restriction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestrictionDeleteManyArgs>(args?: SelectSubset<T, RestrictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Restrictions
     * const restriction = await prisma.restriction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestrictionUpdateManyArgs>(args: SelectSubset<T, RestrictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Restriction.
     * @param {RestrictionUpsertArgs} args - Arguments to update or create a Restriction.
     * @example
     * // Update or create a Restriction
     * const restriction = await prisma.restriction.upsert({
     *   create: {
     *     // ... data to create a Restriction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Restriction we want to update
     *   }
     * })
     */
    upsert<T extends RestrictionUpsertArgs>(args: SelectSubset<T, RestrictionUpsertArgs<ExtArgs>>): Prisma__RestrictionClient<$Result.GetResult<Prisma.$RestrictionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionCountArgs} args - Arguments to filter Restrictions to count.
     * @example
     * // Count the number of Restrictions
     * const count = await prisma.restriction.count({
     *   where: {
     *     // ... the filter for the Restrictions we want to count
     *   }
     * })
    **/
    count<T extends RestrictionCountArgs>(
      args?: Subset<T, RestrictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestrictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Restriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestrictionAggregateArgs>(args: Subset<T, RestrictionAggregateArgs>): Prisma.PrismaPromise<GetRestrictionAggregateType<T>>

    /**
     * Group by Restriction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestrictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestrictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestrictionGroupByArgs['orderBy'] }
        : { orderBy?: RestrictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestrictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestrictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Restriction model
   */
  readonly fields: RestrictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Restriction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestrictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Restriction model
   */
  interface RestrictionFieldRefs {
    readonly id: FieldRef<"Restriction", 'String'>
    readonly reason: FieldRef<"Restriction", 'RestrictionReason'>
    readonly until: FieldRef<"Restriction", 'DateTime'>
    readonly status: FieldRef<"Restriction", 'RestrictionStatus'>
    readonly userId: FieldRef<"Restriction", 'String'>
    readonly createdAt: FieldRef<"Restriction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Restriction findUnique
   */
  export type RestrictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction findUniqueOrThrow
   */
  export type RestrictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction findFirst
   */
  export type RestrictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restrictions.
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restrictions.
     */
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Restriction findFirstOrThrow
   */
  export type RestrictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restriction to fetch.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Restrictions.
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Restrictions.
     */
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Restriction findMany
   */
  export type RestrictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter, which Restrictions to fetch.
     */
    where?: RestrictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Restrictions to fetch.
     */
    orderBy?: RestrictionOrderByWithRelationInput | RestrictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Restrictions.
     */
    cursor?: RestrictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Restrictions.
     */
    skip?: number
    distinct?: RestrictionScalarFieldEnum | RestrictionScalarFieldEnum[]
  }

  /**
   * Restriction create
   */
  export type RestrictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * The data needed to create a Restriction.
     */
    data: XOR<RestrictionCreateInput, RestrictionUncheckedCreateInput>
  }

  /**
   * Restriction createMany
   */
  export type RestrictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Restrictions.
     */
    data: RestrictionCreateManyInput | RestrictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Restriction update
   */
  export type RestrictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * The data needed to update a Restriction.
     */
    data: XOR<RestrictionUpdateInput, RestrictionUncheckedUpdateInput>
    /**
     * Choose, which Restriction to update.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction updateMany
   */
  export type RestrictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Restrictions.
     */
    data: XOR<RestrictionUpdateManyMutationInput, RestrictionUncheckedUpdateManyInput>
    /**
     * Filter which Restrictions to update
     */
    where?: RestrictionWhereInput
    /**
     * Limit how many Restrictions to update.
     */
    limit?: number
  }

  /**
   * Restriction upsert
   */
  export type RestrictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * The filter to search for the Restriction to update in case it exists.
     */
    where: RestrictionWhereUniqueInput
    /**
     * In case the Restriction found by the `where` argument doesn't exist, create a new Restriction with this data.
     */
    create: XOR<RestrictionCreateInput, RestrictionUncheckedCreateInput>
    /**
     * In case the Restriction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestrictionUpdateInput, RestrictionUncheckedUpdateInput>
  }

  /**
   * Restriction delete
   */
  export type RestrictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
    /**
     * Filter which Restriction to delete.
     */
    where: RestrictionWhereUniqueInput
  }

  /**
   * Restriction deleteMany
   */
  export type RestrictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Restrictions to delete
     */
    where?: RestrictionWhereInput
    /**
     * Limit how many Restrictions to delete.
     */
    limit?: number
  }

  /**
   * Restriction without action
   */
  export type RestrictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Restriction
     */
    select?: RestrictionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Restriction
     */
    omit?: RestrictionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestrictionInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    thumbnail: string | null
    content: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    thumbnail: string | null
    content: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    thumbnail: number
    content: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    thumbnail?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    thumbnail?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    thumbnail?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    title: string
    slug: string
    thumbnail: string | null
    content: string
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    thumbnail?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>



  export type PostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    thumbnail?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "thumbnail" | "content" | "isPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Post$commentsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      thumbnail: string | null
      content: string
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly slug: FieldRef<"Post", 'String'>
    readonly thumbnail: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly isPublished: FieldRef<"Post", 'Boolean'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    edited: boolean | null
    deleted: boolean | null
    authorId: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    edited: boolean | null
    deleted: boolean | null
    authorId: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    edited: number
    deleted: number
    authorId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    edited?: true
    deleted?: true
    authorId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    edited?: true
    deleted?: true
    authorId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    edited?: true
    deleted?: true
    authorId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    edited: boolean
    deleted: boolean
    authorId: string
    postId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    edited?: boolean
    deleted?: boolean
    authorId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>



  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    edited?: boolean
    deleted?: boolean
    authorId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "edited" | "deleted" | "authorId" | "postId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      edited: boolean
      deleted: boolean
      authorId: string
      postId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly edited: FieldRef<"Comment", 'Boolean'>
    readonly deleted: FieldRef<"Comment", 'Boolean'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Portal
   */

  export type AggregatePortal = {
    _count: PortalCountAggregateOutputType | null
    _min: PortalMinAggregateOutputType | null
    _max: PortalMaxAggregateOutputType | null
  }

  export type PortalMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    customDomain: string | null
    logo: string | null
    primaryColor: string | null
    secondaryColor: string | null
    subscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    trialEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    customDomain: string | null
    logo: string | null
    primaryColor: string | null
    secondaryColor: string | null
    subscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    trialEndsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortalCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    customDomain: number
    logo: number
    primaryColor: number
    secondaryColor: number
    settings: number
    subscriptionId: number
    subscriptionStatus: number
    trialEndsAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortalMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    customDomain?: true
    logo?: true
    primaryColor?: true
    secondaryColor?: true
    subscriptionId?: true
    subscriptionStatus?: true
    trialEndsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortalMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    customDomain?: true
    logo?: true
    primaryColor?: true
    secondaryColor?: true
    subscriptionId?: true
    subscriptionStatus?: true
    trialEndsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortalCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    customDomain?: true
    logo?: true
    primaryColor?: true
    secondaryColor?: true
    settings?: true
    subscriptionId?: true
    subscriptionStatus?: true
    trialEndsAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portal to aggregate.
     */
    where?: PortalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portals to fetch.
     */
    orderBy?: PortalOrderByWithRelationInput | PortalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portals
    **/
    _count?: true | PortalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortalMaxAggregateInputType
  }

  export type GetPortalAggregateType<T extends PortalAggregateArgs> = {
        [P in keyof T & keyof AggregatePortal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortal[P]>
      : GetScalarType<T[P], AggregatePortal[P]>
  }




  export type PortalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortalWhereInput
    orderBy?: PortalOrderByWithAggregationInput | PortalOrderByWithAggregationInput[]
    by: PortalScalarFieldEnum[] | PortalScalarFieldEnum
    having?: PortalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortalCountAggregateInputType | true
    _min?: PortalMinAggregateInputType
    _max?: PortalMaxAggregateInputType
  }

  export type PortalGroupByOutputType = {
    id: string
    name: string
    subdomain: string | null
    customDomain: string | null
    logo: string | null
    primaryColor: string | null
    secondaryColor: string | null
    settings: JsonValue | null
    subscriptionId: string | null
    subscriptionStatus: $Enums.SubscriptionStatus
    trialEndsAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PortalCountAggregateOutputType | null
    _min: PortalMinAggregateOutputType | null
    _max: PortalMaxAggregateOutputType | null
  }

  type GetPortalGroupByPayload<T extends PortalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortalGroupByOutputType[P]>
            : GetScalarType<T[P], PortalGroupByOutputType[P]>
        }
      >
    >


  export type PortalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    customDomain?: boolean
    logo?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    settings?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    trialEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | Portal$userRolesArgs<ExtArgs>
    clients?: boolean | Portal$clientsArgs<ExtArgs>
    leads?: boolean | Portal$leadsArgs<ExtArgs>
    deals?: boolean | Portal$dealsArgs<ExtArgs>
    appointments?: boolean | Portal$appointmentsArgs<ExtArgs>
    products?: boolean | Portal$productsArgs<ExtArgs>
    customFields?: boolean | Portal$customFieldsArgs<ExtArgs>
    auditLogs?: boolean | Portal$auditLogsArgs<ExtArgs>
    seoKeywords?: boolean | Portal$seoKeywordsArgs<ExtArgs>
    seoArticles?: boolean | Portal$seoArticlesArgs<ExtArgs>
    serpPositions?: boolean | Portal$serpPositionsArgs<ExtArgs>
    integrations?: boolean | Portal$integrationsArgs<ExtArgs>
    _count?: boolean | PortalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portal"]>



  export type PortalSelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    customDomain?: boolean
    logo?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    settings?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    trialEndsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "customDomain" | "logo" | "primaryColor" | "secondaryColor" | "settings" | "subscriptionId" | "subscriptionStatus" | "trialEndsAt" | "createdAt" | "updatedAt", ExtArgs["result"]["portal"]>
  export type PortalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Portal$userRolesArgs<ExtArgs>
    clients?: boolean | Portal$clientsArgs<ExtArgs>
    leads?: boolean | Portal$leadsArgs<ExtArgs>
    deals?: boolean | Portal$dealsArgs<ExtArgs>
    appointments?: boolean | Portal$appointmentsArgs<ExtArgs>
    products?: boolean | Portal$productsArgs<ExtArgs>
    customFields?: boolean | Portal$customFieldsArgs<ExtArgs>
    auditLogs?: boolean | Portal$auditLogsArgs<ExtArgs>
    seoKeywords?: boolean | Portal$seoKeywordsArgs<ExtArgs>
    seoArticles?: boolean | Portal$seoArticlesArgs<ExtArgs>
    serpPositions?: boolean | Portal$serpPositionsArgs<ExtArgs>
    integrations?: boolean | Portal$integrationsArgs<ExtArgs>
    _count?: boolean | PortalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PortalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portal"
    objects: {
      userRoles: Prisma.$UserPortalRolePayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      customFields: Prisma.$CustomFieldPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      seoKeywords: Prisma.$SeoKeywordPayload<ExtArgs>[]
      seoArticles: Prisma.$SeoArticlePayload<ExtArgs>[]
      serpPositions: Prisma.$SerpPositionPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string | null
      customDomain: string | null
      logo: string | null
      primaryColor: string | null
      secondaryColor: string | null
      settings: Prisma.JsonValue | null
      subscriptionId: string | null
      subscriptionStatus: $Enums.SubscriptionStatus
      trialEndsAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portal"]>
    composites: {}
  }

  type PortalGetPayload<S extends boolean | null | undefined | PortalDefaultArgs> = $Result.GetResult<Prisma.$PortalPayload, S>

  type PortalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortalCountAggregateInputType | true
    }

  export interface PortalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portal'], meta: { name: 'Portal' } }
    /**
     * Find zero or one Portal that matches the filter.
     * @param {PortalFindUniqueArgs} args - Arguments to find a Portal
     * @example
     * // Get one Portal
     * const portal = await prisma.portal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortalFindUniqueArgs>(args: SelectSubset<T, PortalFindUniqueArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Portal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortalFindUniqueOrThrowArgs} args - Arguments to find a Portal
     * @example
     * // Get one Portal
     * const portal = await prisma.portal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortalFindUniqueOrThrowArgs>(args: SelectSubset<T, PortalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalFindFirstArgs} args - Arguments to find a Portal
     * @example
     * // Get one Portal
     * const portal = await prisma.portal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortalFindFirstArgs>(args?: SelectSubset<T, PortalFindFirstArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalFindFirstOrThrowArgs} args - Arguments to find a Portal
     * @example
     * // Get one Portal
     * const portal = await prisma.portal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortalFindFirstOrThrowArgs>(args?: SelectSubset<T, PortalFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Portals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portals
     * const portals = await prisma.portal.findMany()
     * 
     * // Get first 10 Portals
     * const portals = await prisma.portal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portalWithIdOnly = await prisma.portal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortalFindManyArgs>(args?: SelectSubset<T, PortalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Portal.
     * @param {PortalCreateArgs} args - Arguments to create a Portal.
     * @example
     * // Create one Portal
     * const Portal = await prisma.portal.create({
     *   data: {
     *     // ... data to create a Portal
     *   }
     * })
     * 
     */
    create<T extends PortalCreateArgs>(args: SelectSubset<T, PortalCreateArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Portals.
     * @param {PortalCreateManyArgs} args - Arguments to create many Portals.
     * @example
     * // Create many Portals
     * const portal = await prisma.portal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortalCreateManyArgs>(args?: SelectSubset<T, PortalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Portal.
     * @param {PortalDeleteArgs} args - Arguments to delete one Portal.
     * @example
     * // Delete one Portal
     * const Portal = await prisma.portal.delete({
     *   where: {
     *     // ... filter to delete one Portal
     *   }
     * })
     * 
     */
    delete<T extends PortalDeleteArgs>(args: SelectSubset<T, PortalDeleteArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Portal.
     * @param {PortalUpdateArgs} args - Arguments to update one Portal.
     * @example
     * // Update one Portal
     * const portal = await prisma.portal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortalUpdateArgs>(args: SelectSubset<T, PortalUpdateArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Portals.
     * @param {PortalDeleteManyArgs} args - Arguments to filter Portals to delete.
     * @example
     * // Delete a few Portals
     * const { count } = await prisma.portal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortalDeleteManyArgs>(args?: SelectSubset<T, PortalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portals
     * const portal = await prisma.portal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortalUpdateManyArgs>(args: SelectSubset<T, PortalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Portal.
     * @param {PortalUpsertArgs} args - Arguments to update or create a Portal.
     * @example
     * // Update or create a Portal
     * const portal = await prisma.portal.upsert({
     *   create: {
     *     // ... data to create a Portal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portal we want to update
     *   }
     * })
     */
    upsert<T extends PortalUpsertArgs>(args: SelectSubset<T, PortalUpsertArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Portals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCountArgs} args - Arguments to filter Portals to count.
     * @example
     * // Count the number of Portals
     * const count = await prisma.portal.count({
     *   where: {
     *     // ... the filter for the Portals we want to count
     *   }
     * })
    **/
    count<T extends PortalCountArgs>(
      args?: Subset<T, PortalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortalAggregateArgs>(args: Subset<T, PortalAggregateArgs>): Prisma.PrismaPromise<GetPortalAggregateType<T>>

    /**
     * Group by Portal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortalGroupByArgs['orderBy'] }
        : { orderBy?: PortalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portal model
   */
  readonly fields: PortalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Portal$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Portal$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends Portal$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Portal$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deals<T extends Portal$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Portal$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Portal$productsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customFields<T extends Portal$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Portal$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seoKeywords<T extends Portal$seoKeywordsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$seoKeywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    seoArticles<T extends Portal$seoArticlesArgs<ExtArgs> = {}>(args?: Subset<T, Portal$seoArticlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serpPositions<T extends Portal$serpPositionsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$serpPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends Portal$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Portal$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portal model
   */
  interface PortalFieldRefs {
    readonly id: FieldRef<"Portal", 'String'>
    readonly name: FieldRef<"Portal", 'String'>
    readonly subdomain: FieldRef<"Portal", 'String'>
    readonly customDomain: FieldRef<"Portal", 'String'>
    readonly logo: FieldRef<"Portal", 'String'>
    readonly primaryColor: FieldRef<"Portal", 'String'>
    readonly secondaryColor: FieldRef<"Portal", 'String'>
    readonly settings: FieldRef<"Portal", 'Json'>
    readonly subscriptionId: FieldRef<"Portal", 'String'>
    readonly subscriptionStatus: FieldRef<"Portal", 'SubscriptionStatus'>
    readonly trialEndsAt: FieldRef<"Portal", 'DateTime'>
    readonly createdAt: FieldRef<"Portal", 'DateTime'>
    readonly updatedAt: FieldRef<"Portal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Portal findUnique
   */
  export type PortalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * Filter, which Portal to fetch.
     */
    where: PortalWhereUniqueInput
  }

  /**
   * Portal findUniqueOrThrow
   */
  export type PortalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * Filter, which Portal to fetch.
     */
    where: PortalWhereUniqueInput
  }

  /**
   * Portal findFirst
   */
  export type PortalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * Filter, which Portal to fetch.
     */
    where?: PortalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portals to fetch.
     */
    orderBy?: PortalOrderByWithRelationInput | PortalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portals.
     */
    cursor?: PortalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portals.
     */
    distinct?: PortalScalarFieldEnum | PortalScalarFieldEnum[]
  }

  /**
   * Portal findFirstOrThrow
   */
  export type PortalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * Filter, which Portal to fetch.
     */
    where?: PortalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portals to fetch.
     */
    orderBy?: PortalOrderByWithRelationInput | PortalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portals.
     */
    cursor?: PortalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portals.
     */
    distinct?: PortalScalarFieldEnum | PortalScalarFieldEnum[]
  }

  /**
   * Portal findMany
   */
  export type PortalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * Filter, which Portals to fetch.
     */
    where?: PortalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portals to fetch.
     */
    orderBy?: PortalOrderByWithRelationInput | PortalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portals.
     */
    cursor?: PortalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portals.
     */
    skip?: number
    distinct?: PortalScalarFieldEnum | PortalScalarFieldEnum[]
  }

  /**
   * Portal create
   */
  export type PortalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * The data needed to create a Portal.
     */
    data: XOR<PortalCreateInput, PortalUncheckedCreateInput>
  }

  /**
   * Portal createMany
   */
  export type PortalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portals.
     */
    data: PortalCreateManyInput | PortalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portal update
   */
  export type PortalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * The data needed to update a Portal.
     */
    data: XOR<PortalUpdateInput, PortalUncheckedUpdateInput>
    /**
     * Choose, which Portal to update.
     */
    where: PortalWhereUniqueInput
  }

  /**
   * Portal updateMany
   */
  export type PortalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portals.
     */
    data: XOR<PortalUpdateManyMutationInput, PortalUncheckedUpdateManyInput>
    /**
     * Filter which Portals to update
     */
    where?: PortalWhereInput
    /**
     * Limit how many Portals to update.
     */
    limit?: number
  }

  /**
   * Portal upsert
   */
  export type PortalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * The filter to search for the Portal to update in case it exists.
     */
    where: PortalWhereUniqueInput
    /**
     * In case the Portal found by the `where` argument doesn't exist, create a new Portal with this data.
     */
    create: XOR<PortalCreateInput, PortalUncheckedCreateInput>
    /**
     * In case the Portal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortalUpdateInput, PortalUncheckedUpdateInput>
  }

  /**
   * Portal delete
   */
  export type PortalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    /**
     * Filter which Portal to delete.
     */
    where: PortalWhereUniqueInput
  }

  /**
   * Portal deleteMany
   */
  export type PortalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portals to delete
     */
    where?: PortalWhereInput
    /**
     * Limit how many Portals to delete.
     */
    limit?: number
  }

  /**
   * Portal.userRoles
   */
  export type Portal$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    where?: UserPortalRoleWhereInput
    orderBy?: UserPortalRoleOrderByWithRelationInput | UserPortalRoleOrderByWithRelationInput[]
    cursor?: UserPortalRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPortalRoleScalarFieldEnum | UserPortalRoleScalarFieldEnum[]
  }

  /**
   * Portal.clients
   */
  export type Portal$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Portal.leads
   */
  export type Portal$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Portal.deals
   */
  export type Portal$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Portal.appointments
   */
  export type Portal$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Portal.products
   */
  export type Portal$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Portal.customFields
   */
  export type Portal$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    cursor?: CustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * Portal.auditLogs
   */
  export type Portal$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Portal.seoKeywords
   */
  export type Portal$seoKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    where?: SeoKeywordWhereInput
    orderBy?: SeoKeywordOrderByWithRelationInput | SeoKeywordOrderByWithRelationInput[]
    cursor?: SeoKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeoKeywordScalarFieldEnum | SeoKeywordScalarFieldEnum[]
  }

  /**
   * Portal.seoArticles
   */
  export type Portal$seoArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    where?: SeoArticleWhereInput
    orderBy?: SeoArticleOrderByWithRelationInput | SeoArticleOrderByWithRelationInput[]
    cursor?: SeoArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeoArticleScalarFieldEnum | SeoArticleScalarFieldEnum[]
  }

  /**
   * Portal.serpPositions
   */
  export type Portal$serpPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    where?: SerpPositionWhereInput
    orderBy?: SerpPositionOrderByWithRelationInput | SerpPositionOrderByWithRelationInput[]
    cursor?: SerpPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SerpPositionScalarFieldEnum | SerpPositionScalarFieldEnum[]
  }

  /**
   * Portal.integrations
   */
  export type Portal$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Portal without action
   */
  export type PortalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
  }


  /**
   * Model UserPortalRole
   */

  export type AggregateUserPortalRole = {
    _count: UserPortalRoleCountAggregateOutputType | null
    _min: UserPortalRoleMinAggregateOutputType | null
    _max: UserPortalRoleMaxAggregateOutputType | null
  }

  export type UserPortalRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    portalId: string | null
    role: $Enums.PortalRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPortalRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    portalId: string | null
    role: $Enums.PortalRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPortalRoleCountAggregateOutputType = {
    id: number
    userId: number
    portalId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPortalRoleMinAggregateInputType = {
    id?: true
    userId?: true
    portalId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPortalRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    portalId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPortalRoleCountAggregateInputType = {
    id?: true
    userId?: true
    portalId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPortalRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPortalRole to aggregate.
     */
    where?: UserPortalRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPortalRoles to fetch.
     */
    orderBy?: UserPortalRoleOrderByWithRelationInput | UserPortalRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPortalRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPortalRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPortalRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPortalRoles
    **/
    _count?: true | UserPortalRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPortalRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPortalRoleMaxAggregateInputType
  }

  export type GetUserPortalRoleAggregateType<T extends UserPortalRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPortalRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPortalRole[P]>
      : GetScalarType<T[P], AggregateUserPortalRole[P]>
  }




  export type UserPortalRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPortalRoleWhereInput
    orderBy?: UserPortalRoleOrderByWithAggregationInput | UserPortalRoleOrderByWithAggregationInput[]
    by: UserPortalRoleScalarFieldEnum[] | UserPortalRoleScalarFieldEnum
    having?: UserPortalRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPortalRoleCountAggregateInputType | true
    _min?: UserPortalRoleMinAggregateInputType
    _max?: UserPortalRoleMaxAggregateInputType
  }

  export type UserPortalRoleGroupByOutputType = {
    id: string
    userId: string
    portalId: string
    role: $Enums.PortalRole
    createdAt: Date
    updatedAt: Date
    _count: UserPortalRoleCountAggregateOutputType | null
    _min: UserPortalRoleMinAggregateOutputType | null
    _max: UserPortalRoleMaxAggregateOutputType | null
  }

  type GetUserPortalRoleGroupByPayload<T extends UserPortalRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPortalRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPortalRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPortalRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserPortalRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserPortalRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    portalId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    portal?: boolean | PortalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPortalRole"]>



  export type UserPortalRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    portalId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPortalRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "portalId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["userPortalRole"]>
  export type UserPortalRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    portal?: boolean | PortalDefaultArgs<ExtArgs>
  }

  export type $UserPortalRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPortalRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      portal: Prisma.$PortalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      portalId: string
      role: $Enums.PortalRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPortalRole"]>
    composites: {}
  }

  type UserPortalRoleGetPayload<S extends boolean | null | undefined | UserPortalRoleDefaultArgs> = $Result.GetResult<Prisma.$UserPortalRolePayload, S>

  type UserPortalRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPortalRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPortalRoleCountAggregateInputType | true
    }

  export interface UserPortalRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPortalRole'], meta: { name: 'UserPortalRole' } }
    /**
     * Find zero or one UserPortalRole that matches the filter.
     * @param {UserPortalRoleFindUniqueArgs} args - Arguments to find a UserPortalRole
     * @example
     * // Get one UserPortalRole
     * const userPortalRole = await prisma.userPortalRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPortalRoleFindUniqueArgs>(args: SelectSubset<T, UserPortalRoleFindUniqueArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPortalRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPortalRoleFindUniqueOrThrowArgs} args - Arguments to find a UserPortalRole
     * @example
     * // Get one UserPortalRole
     * const userPortalRole = await prisma.userPortalRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPortalRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPortalRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPortalRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleFindFirstArgs} args - Arguments to find a UserPortalRole
     * @example
     * // Get one UserPortalRole
     * const userPortalRole = await prisma.userPortalRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPortalRoleFindFirstArgs>(args?: SelectSubset<T, UserPortalRoleFindFirstArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPortalRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleFindFirstOrThrowArgs} args - Arguments to find a UserPortalRole
     * @example
     * // Get one UserPortalRole
     * const userPortalRole = await prisma.userPortalRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPortalRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPortalRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPortalRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPortalRoles
     * const userPortalRoles = await prisma.userPortalRole.findMany()
     * 
     * // Get first 10 UserPortalRoles
     * const userPortalRoles = await prisma.userPortalRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPortalRoleWithIdOnly = await prisma.userPortalRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPortalRoleFindManyArgs>(args?: SelectSubset<T, UserPortalRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPortalRole.
     * @param {UserPortalRoleCreateArgs} args - Arguments to create a UserPortalRole.
     * @example
     * // Create one UserPortalRole
     * const UserPortalRole = await prisma.userPortalRole.create({
     *   data: {
     *     // ... data to create a UserPortalRole
     *   }
     * })
     * 
     */
    create<T extends UserPortalRoleCreateArgs>(args: SelectSubset<T, UserPortalRoleCreateArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPortalRoles.
     * @param {UserPortalRoleCreateManyArgs} args - Arguments to create many UserPortalRoles.
     * @example
     * // Create many UserPortalRoles
     * const userPortalRole = await prisma.userPortalRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPortalRoleCreateManyArgs>(args?: SelectSubset<T, UserPortalRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPortalRole.
     * @param {UserPortalRoleDeleteArgs} args - Arguments to delete one UserPortalRole.
     * @example
     * // Delete one UserPortalRole
     * const UserPortalRole = await prisma.userPortalRole.delete({
     *   where: {
     *     // ... filter to delete one UserPortalRole
     *   }
     * })
     * 
     */
    delete<T extends UserPortalRoleDeleteArgs>(args: SelectSubset<T, UserPortalRoleDeleteArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPortalRole.
     * @param {UserPortalRoleUpdateArgs} args - Arguments to update one UserPortalRole.
     * @example
     * // Update one UserPortalRole
     * const userPortalRole = await prisma.userPortalRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPortalRoleUpdateArgs>(args: SelectSubset<T, UserPortalRoleUpdateArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPortalRoles.
     * @param {UserPortalRoleDeleteManyArgs} args - Arguments to filter UserPortalRoles to delete.
     * @example
     * // Delete a few UserPortalRoles
     * const { count } = await prisma.userPortalRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPortalRoleDeleteManyArgs>(args?: SelectSubset<T, UserPortalRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPortalRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPortalRoles
     * const userPortalRole = await prisma.userPortalRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPortalRoleUpdateManyArgs>(args: SelectSubset<T, UserPortalRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPortalRole.
     * @param {UserPortalRoleUpsertArgs} args - Arguments to update or create a UserPortalRole.
     * @example
     * // Update or create a UserPortalRole
     * const userPortalRole = await prisma.userPortalRole.upsert({
     *   create: {
     *     // ... data to create a UserPortalRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPortalRole we want to update
     *   }
     * })
     */
    upsert<T extends UserPortalRoleUpsertArgs>(args: SelectSubset<T, UserPortalRoleUpsertArgs<ExtArgs>>): Prisma__UserPortalRoleClient<$Result.GetResult<Prisma.$UserPortalRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPortalRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleCountArgs} args - Arguments to filter UserPortalRoles to count.
     * @example
     * // Count the number of UserPortalRoles
     * const count = await prisma.userPortalRole.count({
     *   where: {
     *     // ... the filter for the UserPortalRoles we want to count
     *   }
     * })
    **/
    count<T extends UserPortalRoleCountArgs>(
      args?: Subset<T, UserPortalRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPortalRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPortalRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPortalRoleAggregateArgs>(args: Subset<T, UserPortalRoleAggregateArgs>): Prisma.PrismaPromise<GetUserPortalRoleAggregateType<T>>

    /**
     * Group by UserPortalRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPortalRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPortalRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPortalRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserPortalRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPortalRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPortalRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPortalRole model
   */
  readonly fields: UserPortalRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPortalRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPortalRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPortalRole model
   */
  interface UserPortalRoleFieldRefs {
    readonly id: FieldRef<"UserPortalRole", 'String'>
    readonly userId: FieldRef<"UserPortalRole", 'String'>
    readonly portalId: FieldRef<"UserPortalRole", 'String'>
    readonly role: FieldRef<"UserPortalRole", 'PortalRole'>
    readonly createdAt: FieldRef<"UserPortalRole", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPortalRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPortalRole findUnique
   */
  export type UserPortalRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserPortalRole to fetch.
     */
    where: UserPortalRoleWhereUniqueInput
  }

  /**
   * UserPortalRole findUniqueOrThrow
   */
  export type UserPortalRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserPortalRole to fetch.
     */
    where: UserPortalRoleWhereUniqueInput
  }

  /**
   * UserPortalRole findFirst
   */
  export type UserPortalRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserPortalRole to fetch.
     */
    where?: UserPortalRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPortalRoles to fetch.
     */
    orderBy?: UserPortalRoleOrderByWithRelationInput | UserPortalRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPortalRoles.
     */
    cursor?: UserPortalRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPortalRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPortalRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPortalRoles.
     */
    distinct?: UserPortalRoleScalarFieldEnum | UserPortalRoleScalarFieldEnum[]
  }

  /**
   * UserPortalRole findFirstOrThrow
   */
  export type UserPortalRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserPortalRole to fetch.
     */
    where?: UserPortalRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPortalRoles to fetch.
     */
    orderBy?: UserPortalRoleOrderByWithRelationInput | UserPortalRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPortalRoles.
     */
    cursor?: UserPortalRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPortalRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPortalRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPortalRoles.
     */
    distinct?: UserPortalRoleScalarFieldEnum | UserPortalRoleScalarFieldEnum[]
  }

  /**
   * UserPortalRole findMany
   */
  export type UserPortalRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserPortalRoles to fetch.
     */
    where?: UserPortalRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPortalRoles to fetch.
     */
    orderBy?: UserPortalRoleOrderByWithRelationInput | UserPortalRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPortalRoles.
     */
    cursor?: UserPortalRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPortalRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPortalRoles.
     */
    skip?: number
    distinct?: UserPortalRoleScalarFieldEnum | UserPortalRoleScalarFieldEnum[]
  }

  /**
   * UserPortalRole create
   */
  export type UserPortalRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPortalRole.
     */
    data: XOR<UserPortalRoleCreateInput, UserPortalRoleUncheckedCreateInput>
  }

  /**
   * UserPortalRole createMany
   */
  export type UserPortalRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPortalRoles.
     */
    data: UserPortalRoleCreateManyInput | UserPortalRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPortalRole update
   */
  export type UserPortalRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPortalRole.
     */
    data: XOR<UserPortalRoleUpdateInput, UserPortalRoleUncheckedUpdateInput>
    /**
     * Choose, which UserPortalRole to update.
     */
    where: UserPortalRoleWhereUniqueInput
  }

  /**
   * UserPortalRole updateMany
   */
  export type UserPortalRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPortalRoles.
     */
    data: XOR<UserPortalRoleUpdateManyMutationInput, UserPortalRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserPortalRoles to update
     */
    where?: UserPortalRoleWhereInput
    /**
     * Limit how many UserPortalRoles to update.
     */
    limit?: number
  }

  /**
   * UserPortalRole upsert
   */
  export type UserPortalRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPortalRole to update in case it exists.
     */
    where: UserPortalRoleWhereUniqueInput
    /**
     * In case the UserPortalRole found by the `where` argument doesn't exist, create a new UserPortalRole with this data.
     */
    create: XOR<UserPortalRoleCreateInput, UserPortalRoleUncheckedCreateInput>
    /**
     * In case the UserPortalRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPortalRoleUpdateInput, UserPortalRoleUncheckedUpdateInput>
  }

  /**
   * UserPortalRole delete
   */
  export type UserPortalRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
    /**
     * Filter which UserPortalRole to delete.
     */
    where: UserPortalRoleWhereUniqueInput
  }

  /**
   * UserPortalRole deleteMany
   */
  export type UserPortalRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPortalRoles to delete
     */
    where?: UserPortalRoleWhereInput
    /**
     * Limit how many UserPortalRoles to delete.
     */
    limit?: number
  }

  /**
   * UserPortalRole without action
   */
  export type UserPortalRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPortalRole
     */
    select?: UserPortalRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPortalRole
     */
    omit?: UserPortalRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPortalRoleInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    portalId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    avatar: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    portalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    avatar?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    portalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    avatar?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    portalId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    avatar?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    portalId: string
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    createdBy?: boolean | Client$createdByArgs<ExtArgs>
    deals?: boolean | Client$dealsArgs<ExtArgs>
    appointments?: boolean | Client$appointmentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>



  export type ClientSelectScalar = {
    id?: boolean
    portalId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "firstName" | "lastName" | "email" | "phone" | "avatar" | "notes" | "metadata" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    createdBy?: boolean | Client$createdByArgs<ExtArgs>
    deals?: boolean | Client$dealsArgs<ExtArgs>
    appointments?: boolean | Client$appointmentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      deals: Prisma.$DealPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      firstName: string | null
      lastName: string | null
      email: string | null
      phone: string | null
      avatar: string | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Client$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Client$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deals<T extends Client$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Client$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Client$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly portalId: FieldRef<"Client", 'String'>
    readonly firstName: FieldRef<"Client", 'String'>
    readonly lastName: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly avatar: FieldRef<"Client", 'String'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly metadata: FieldRef<"Client", 'Json'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
    readonly createdById: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.createdBy
   */
  export type Client$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Client.deals
   */
  export type Client$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Client.appointments
   */
  export type Client$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    source: $Enums.LeadSource | null
    status: $Enums.LeadStatus | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    createdById: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    source: $Enums.LeadSource | null
    status: $Enums.LeadStatus | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedToId: string | null
    createdById: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    portalId: number
    source: number
    status: number
    firstName: number
    lastName: number
    email: number
    phone: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    assignedToId: number
    createdById: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    portalId?: true
    source?: true
    status?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    portalId?: true
    source?: true
    status?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    portalId?: true
    source?: true
    status?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    assignedToId?: true
    createdById?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    portalId: string
    source: $Enums.LeadSource
    status: $Enums.LeadStatus
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    assignedToId: string | null
    createdById: string | null
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    source?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    assignedTo?: boolean | Lead$assignedToArgs<ExtArgs>
    createdBy?: boolean | Lead$createdByArgs<ExtArgs>
    deals?: boolean | Lead$dealsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>



  export type LeadSelectScalar = {
    id?: boolean
    portalId?: boolean
    source?: boolean
    status?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedToId?: boolean
    createdById?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "source" | "status" | "firstName" | "lastName" | "email" | "phone" | "notes" | "metadata" | "createdAt" | "updatedAt" | "assignedToId" | "createdById", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    assignedTo?: boolean | Lead$assignedToArgs<ExtArgs>
    createdBy?: boolean | Lead$createdByArgs<ExtArgs>
    deals?: boolean | Lead$dealsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      deals: Prisma.$DealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      source: $Enums.LeadSource
      status: $Enums.LeadStatus
      firstName: string | null
      lastName: string | null
      email: string | null
      phone: string | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      assignedToId: string | null
      createdById: string | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Lead$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Lead$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Lead$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Lead$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deals<T extends Lead$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly portalId: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'LeadSource'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly firstName: FieldRef<"Lead", 'String'>
    readonly lastName: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly metadata: FieldRef<"Lead", 'Json'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly assignedToId: FieldRef<"Lead", 'String'>
    readonly createdById: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.assignedTo
   */
  export type Lead$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Lead.createdBy
   */
  export type Lead$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Lead.deals
   */
  export type Lead$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    value: Decimal | null
    probability: number | null
  }

  export type DealSumAggregateOutputType = {
    value: Decimal | null
    probability: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    title: string | null
    stage: string | null
    value: Decimal | null
    currency: string | null
    probability: number | null
    expectedCloseDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    leadId: string | null
    assignedToId: string | null
    createdById: string | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    title: string | null
    stage: string | null
    value: Decimal | null
    currency: string | null
    probability: number | null
    expectedCloseDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    leadId: string | null
    assignedToId: string | null
    createdById: string | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    portalId: number
    title: number
    stage: number
    value: number
    currency: number
    probability: number
    expectedCloseDate: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    clientId: number
    leadId: number
    assignedToId: number
    createdById: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealSumAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    stage?: true
    value?: true
    currency?: true
    probability?: true
    expectedCloseDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    leadId?: true
    assignedToId?: true
    createdById?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    stage?: true
    value?: true
    currency?: true
    probability?: true
    expectedCloseDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    leadId?: true
    assignedToId?: true
    createdById?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    stage?: true
    value?: true
    currency?: true
    probability?: true
    expectedCloseDate?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    leadId?: true
    assignedToId?: true
    createdById?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    portalId: string
    title: string
    stage: string
    value: Decimal | null
    currency: string
    probability: number | null
    expectedCloseDate: Date | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    clientId: string | null
    leadId: string | null
    assignedToId: string | null
    createdById: string | null
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    title?: boolean
    stage?: boolean
    value?: boolean
    currency?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    leadId?: boolean
    assignedToId?: boolean
    createdById?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    client?: boolean | Deal$clientArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    assignedTo?: boolean | Deal$assignedToArgs<ExtArgs>
    createdBy?: boolean | Deal$createdByArgs<ExtArgs>
    appointments?: boolean | Deal$appointmentsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>



  export type DealSelectScalar = {
    id?: boolean
    portalId?: boolean
    title?: boolean
    stage?: boolean
    value?: boolean
    currency?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    leadId?: boolean
    assignedToId?: boolean
    createdById?: boolean
  }

  export type DealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "title" | "stage" | "value" | "currency" | "probability" | "expectedCloseDate" | "notes" | "metadata" | "createdAt" | "updatedAt" | "clientId" | "leadId" | "assignedToId" | "createdById", ExtArgs["result"]["deal"]>
  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    client?: boolean | Deal$clientArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    assignedTo?: boolean | Deal$assignedToArgs<ExtArgs>
    createdBy?: boolean | Deal$createdByArgs<ExtArgs>
    appointments?: boolean | Deal$appointmentsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
      lead: Prisma.$LeadPayload<ExtArgs> | null
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      title: string
      stage: string
      value: Prisma.Decimal | null
      currency: string
      probability: number | null
      expectedCloseDate: Date | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      clientId: string | null
      leadId: string | null
      assignedToId: string | null
      createdById: string | null
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends Deal$clientArgs<ExtArgs> = {}>(args?: Subset<T, Deal$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lead<T extends Deal$leadArgs<ExtArgs> = {}>(args?: Subset<T, Deal$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Deal$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Deal$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Deal$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Deal$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Deal$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly portalId: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly stage: FieldRef<"Deal", 'String'>
    readonly value: FieldRef<"Deal", 'Decimal'>
    readonly currency: FieldRef<"Deal", 'String'>
    readonly probability: FieldRef<"Deal", 'Int'>
    readonly expectedCloseDate: FieldRef<"Deal", 'DateTime'>
    readonly notes: FieldRef<"Deal", 'String'>
    readonly metadata: FieldRef<"Deal", 'Json'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
    readonly clientId: FieldRef<"Deal", 'String'>
    readonly leadId: FieldRef<"Deal", 'String'>
    readonly assignedToId: FieldRef<"Deal", 'String'>
    readonly createdById: FieldRef<"Deal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to delete.
     */
    limit?: number
  }

  /**
   * Deal.client
   */
  export type Deal$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Deal.lead
   */
  export type Deal$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Deal.assignedTo
   */
  export type Deal$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Deal.createdBy
   */
  export type Deal$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Deal.appointments
   */
  export type Deal$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AppointmentStatus | null
    location: string | null
    googleCalendarEventId: string | null
    reminderSent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    dealId: string | null
    productId: string | null
    assignedToId: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AppointmentStatus | null
    location: string | null
    googleCalendarEventId: string | null
    reminderSent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    dealId: string | null
    productId: string | null
    assignedToId: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    portalId: number
    title: number
    description: number
    startTime: number
    endTime: number
    status: number
    location: number
    googleCalendarEventId: number
    reminderSent: number
    metadata: number
    createdAt: number
    updatedAt: number
    clientId: number
    dealId: number
    productId: number
    assignedToId: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    status?: true
    location?: true
    googleCalendarEventId?: true
    reminderSent?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    dealId?: true
    productId?: true
    assignedToId?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    status?: true
    location?: true
    googleCalendarEventId?: true
    reminderSent?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    dealId?: true
    productId?: true
    assignedToId?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    status?: true
    location?: true
    googleCalendarEventId?: true
    reminderSent?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    dealId?: true
    productId?: true
    assignedToId?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    portalId: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    status: $Enums.AppointmentStatus
    location: string | null
    googleCalendarEventId: string | null
    reminderSent: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    clientId: string | null
    dealId: string | null
    productId: string | null
    assignedToId: string | null
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    location?: boolean
    googleCalendarEventId?: boolean
    reminderSent?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    dealId?: boolean
    productId?: boolean
    assignedToId?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    client?: boolean | Appointment$clientArgs<ExtArgs>
    deal?: boolean | Appointment$dealArgs<ExtArgs>
    product?: boolean | Appointment$productArgs<ExtArgs>
    assignedTo?: boolean | Appointment$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>



  export type AppointmentSelectScalar = {
    id?: boolean
    portalId?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    location?: boolean
    googleCalendarEventId?: boolean
    reminderSent?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    dealId?: boolean
    productId?: boolean
    assignedToId?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "title" | "description" | "startTime" | "endTime" | "status" | "location" | "googleCalendarEventId" | "reminderSent" | "metadata" | "createdAt" | "updatedAt" | "clientId" | "dealId" | "productId" | "assignedToId", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    client?: boolean | Appointment$clientArgs<ExtArgs>
    deal?: boolean | Appointment$dealArgs<ExtArgs>
    product?: boolean | Appointment$productArgs<ExtArgs>
    assignedTo?: boolean | Appointment$assignedToArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      status: $Enums.AppointmentStatus
      location: string | null
      googleCalendarEventId: string | null
      reminderSent: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      clientId: string | null
      dealId: string | null
      productId: string | null
      assignedToId: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends Appointment$clientArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deal<T extends Appointment$dealArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Appointment$productArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends Appointment$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly portalId: FieldRef<"Appointment", 'String'>
    readonly title: FieldRef<"Appointment", 'String'>
    readonly description: FieldRef<"Appointment", 'String'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly googleCalendarEventId: FieldRef<"Appointment", 'String'>
    readonly reminderSent: FieldRef<"Appointment", 'Boolean'>
    readonly metadata: FieldRef<"Appointment", 'Json'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
    readonly clientId: FieldRef<"Appointment", 'String'>
    readonly dealId: FieldRef<"Appointment", 'String'>
    readonly productId: FieldRef<"Appointment", 'String'>
    readonly assignedToId: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.client
   */
  export type Appointment$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Appointment.deal
   */
  export type Appointment$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Appointment.product
   */
  export type Appointment$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Appointment.assignedTo
   */
  export type Appointment$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    duration: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    duration: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    name: string | null
    description: string | null
    category: string | null
    price: Decimal | null
    currency: string | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    name: string | null
    description: string | null
    category: string | null
    price: Decimal | null
    currency: string | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    portalId: number
    name: number
    description: number
    category: number
    price: number
    currency: number
    duration: number
    portfolio: number
    isActive: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    portalId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    currency?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    portalId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    currency?: true
    duration?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    portalId?: true
    name?: true
    description?: true
    category?: true
    price?: true
    currency?: true
    duration?: true
    portfolio?: true
    isActive?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    portalId: string
    name: string
    description: string | null
    category: string | null
    price: Decimal
    currency: string
    duration: number | null
    portfolio: JsonValue | null
    isActive: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    portfolio?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    appointments?: boolean | Product$appointmentsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    portalId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    currency?: boolean
    duration?: boolean
    portfolio?: boolean
    isActive?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "name" | "description" | "category" | "price" | "currency" | "duration" | "portfolio" | "isActive" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    appointments?: boolean | Product$appointmentsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      name: string
      description: string | null
      category: string | null
      price: Prisma.Decimal
      currency: string
      duration: number | null
      portfolio: Prisma.JsonValue | null
      isActive: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Product$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Product$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly portalId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly duration: FieldRef<"Product", 'Int'>
    readonly portfolio: FieldRef<"Product", 'Json'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly metadata: FieldRef<"Product", 'Json'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.appointments
   */
  export type Product$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model CustomField
   */

  export type AggregateCustomField = {
    _count: CustomFieldCountAggregateOutputType | null
    _avg: CustomFieldAvgAggregateOutputType | null
    _sum: CustomFieldSumAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  export type CustomFieldAvgAggregateOutputType = {
    order: number | null
  }

  export type CustomFieldSumAggregateOutputType = {
    order: number | null
  }

  export type CustomFieldMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    entityType: $Enums.EntityType | null
    name: string | null
    fieldType: $Enums.FieldType | null
    isRequired: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomFieldMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    entityType: $Enums.EntityType | null
    name: string | null
    fieldType: $Enums.FieldType | null
    isRequired: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomFieldCountAggregateOutputType = {
    id: number
    portalId: number
    entityType: number
    name: number
    fieldType: number
    config: number
    isRequired: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomFieldAvgAggregateInputType = {
    order?: true
  }

  export type CustomFieldSumAggregateInputType = {
    order?: true
  }

  export type CustomFieldMinAggregateInputType = {
    id?: true
    portalId?: true
    entityType?: true
    name?: true
    fieldType?: true
    isRequired?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomFieldMaxAggregateInputType = {
    id?: true
    portalId?: true
    entityType?: true
    name?: true
    fieldType?: true
    isRequired?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomFieldCountAggregateInputType = {
    id?: true
    portalId?: true
    entityType?: true
    name?: true
    fieldType?: true
    config?: true
    isRequired?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomField to aggregate.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFields
    **/
    _count?: true | CustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldMaxAggregateInputType
  }

  export type GetCustomFieldAggregateType<T extends CustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomField[P]>
      : GetScalarType<T[P], AggregateCustomField[P]>
  }




  export type CustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithAggregationInput | CustomFieldOrderByWithAggregationInput[]
    by: CustomFieldScalarFieldEnum[] | CustomFieldScalarFieldEnum
    having?: CustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldCountAggregateInputType | true
    _avg?: CustomFieldAvgAggregateInputType
    _sum?: CustomFieldSumAggregateInputType
    _min?: CustomFieldMinAggregateInputType
    _max?: CustomFieldMaxAggregateInputType
  }

  export type CustomFieldGroupByOutputType = {
    id: string
    portalId: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config: JsonValue | null
    isRequired: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: CustomFieldCountAggregateOutputType | null
    _avg: CustomFieldAvgAggregateOutputType | null
    _sum: CustomFieldSumAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  type GetCustomFieldGroupByPayload<T extends CustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    entityType?: boolean
    name?: boolean
    fieldType?: boolean
    config?: boolean
    isRequired?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    values?: boolean | CustomField$valuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>



  export type CustomFieldSelectScalar = {
    id?: boolean
    portalId?: boolean
    entityType?: boolean
    name?: boolean
    fieldType?: boolean
    config?: boolean
    isRequired?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "entityType" | "name" | "fieldType" | "config" | "isRequired" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["customField"]>
  export type CustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    values?: boolean | CustomField$valuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomField"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      values: Prisma.$CustomFieldValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      entityType: $Enums.EntityType
      name: string
      fieldType: $Enums.FieldType
      config: Prisma.JsonValue | null
      isRequired: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customField"]>
    composites: {}
  }

  type CustomFieldGetPayload<S extends boolean | null | undefined | CustomFieldDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldPayload, S>

  type CustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomFieldCountAggregateInputType | true
    }

  export interface CustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomField'], meta: { name: 'CustomField' } }
    /**
     * Find zero or one CustomField that matches the filter.
     * @param {CustomFieldFindUniqueArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFieldFindUniqueArgs>(args: SelectSubset<T, CustomFieldFindUniqueArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomFieldFindUniqueOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFieldFindFirstArgs>(args?: SelectSubset<T, CustomFieldFindFirstArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFields
     * const customFields = await prisma.customField.findMany()
     * 
     * // Get first 10 CustomFields
     * const customFields = await prisma.customField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldWithIdOnly = await prisma.customField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFieldFindManyArgs>(args?: SelectSubset<T, CustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomField.
     * @param {CustomFieldCreateArgs} args - Arguments to create a CustomField.
     * @example
     * // Create one CustomField
     * const CustomField = await prisma.customField.create({
     *   data: {
     *     // ... data to create a CustomField
     *   }
     * })
     * 
     */
    create<T extends CustomFieldCreateArgs>(args: SelectSubset<T, CustomFieldCreateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomFields.
     * @param {CustomFieldCreateManyArgs} args - Arguments to create many CustomFields.
     * @example
     * // Create many CustomFields
     * const customField = await prisma.customField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFieldCreateManyArgs>(args?: SelectSubset<T, CustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomField.
     * @param {CustomFieldDeleteArgs} args - Arguments to delete one CustomField.
     * @example
     * // Delete one CustomField
     * const CustomField = await prisma.customField.delete({
     *   where: {
     *     // ... filter to delete one CustomField
     *   }
     * })
     * 
     */
    delete<T extends CustomFieldDeleteArgs>(args: SelectSubset<T, CustomFieldDeleteArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomField.
     * @param {CustomFieldUpdateArgs} args - Arguments to update one CustomField.
     * @example
     * // Update one CustomField
     * const customField = await prisma.customField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFieldUpdateArgs>(args: SelectSubset<T, CustomFieldUpdateArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomFields.
     * @param {CustomFieldDeleteManyArgs} args - Arguments to filter CustomFields to delete.
     * @example
     * // Delete a few CustomFields
     * const { count } = await prisma.customField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFieldDeleteManyArgs>(args?: SelectSubset<T, CustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFieldUpdateManyArgs>(args: SelectSubset<T, CustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomField.
     * @param {CustomFieldUpsertArgs} args - Arguments to update or create a CustomField.
     * @example
     * // Update or create a CustomField
     * const customField = await prisma.customField.upsert({
     *   create: {
     *     // ... data to create a CustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomField we want to update
     *   }
     * })
     */
    upsert<T extends CustomFieldUpsertArgs>(args: SelectSubset<T, CustomFieldUpsertArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldCountArgs} args - Arguments to filter CustomFields to count.
     * @example
     * // Count the number of CustomFields
     * const count = await prisma.customField.count({
     *   where: {
     *     // ... the filter for the CustomFields we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldCountArgs>(
      args?: Subset<T, CustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldAggregateArgs>(args: Subset<T, CustomFieldAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldAggregateType<T>>

    /**
     * Group by CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomField model
   */
  readonly fields: CustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends CustomField$valuesArgs<ExtArgs> = {}>(args?: Subset<T, CustomField$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomField model
   */
  interface CustomFieldFieldRefs {
    readonly id: FieldRef<"CustomField", 'String'>
    readonly portalId: FieldRef<"CustomField", 'String'>
    readonly entityType: FieldRef<"CustomField", 'EntityType'>
    readonly name: FieldRef<"CustomField", 'String'>
    readonly fieldType: FieldRef<"CustomField", 'FieldType'>
    readonly config: FieldRef<"CustomField", 'Json'>
    readonly isRequired: FieldRef<"CustomField", 'Boolean'>
    readonly order: FieldRef<"CustomField", 'Int'>
    readonly createdAt: FieldRef<"CustomField", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomField findUnique
   */
  export type CustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findUniqueOrThrow
   */
  export type CustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField findFirst
   */
  export type CustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findFirstOrThrow
   */
  export type CustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField findMany
   */
  export type CustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomFields to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }

  /**
   * CustomField create
   */
  export type CustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomField.
     */
    data: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
  }

  /**
   * CustomField createMany
   */
  export type CustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomField update
   */
  export type CustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomField.
     */
    data: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
    /**
     * Choose, which CustomField to update.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField updateMany
   */
  export type CustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to update.
     */
    limit?: number
  }

  /**
   * CustomField upsert
   */
  export type CustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomField to update in case it exists.
     */
    where: CustomFieldWhereUniqueInput
    /**
     * In case the CustomField found by the `where` argument doesn't exist, create a new CustomField with this data.
     */
    create: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
    /**
     * In case the CustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
  }

  /**
   * CustomField delete
   */
  export type CustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter which CustomField to delete.
     */
    where: CustomFieldWhereUniqueInput
  }

  /**
   * CustomField deleteMany
   */
  export type CustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFields to delete
     */
    where?: CustomFieldWhereInput
    /**
     * Limit how many CustomFields to delete.
     */
    limit?: number
  }

  /**
   * CustomField.values
   */
  export type CustomField$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    cursor?: CustomFieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomField without action
   */
  export type CustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomField
     */
    omit?: CustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model CustomFieldValue
   */

  export type AggregateCustomFieldValue = {
    _count: CustomFieldValueCountAggregateOutputType | null
    _min: CustomFieldValueMinAggregateOutputType | null
    _max: CustomFieldValueMaxAggregateOutputType | null
  }

  export type CustomFieldValueMinAggregateOutputType = {
    id: string | null
    fieldId: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomFieldValueMaxAggregateOutputType = {
    id: string | null
    fieldId: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomFieldValueCountAggregateOutputType = {
    id: number
    fieldId: number
    entityType: number
    entityId: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomFieldValueMinAggregateInputType = {
    id?: true
    fieldId?: true
    entityType?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomFieldValueMaxAggregateInputType = {
    id?: true
    fieldId?: true
    entityType?: true
    entityId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomFieldValueCountAggregateInputType = {
    id?: true
    fieldId?: true
    entityType?: true
    entityId?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomFieldValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFieldValue to aggregate.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFieldValues
    **/
    _count?: true | CustomFieldValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldValueMaxAggregateInputType
  }

  export type GetCustomFieldValueAggregateType<T extends CustomFieldValueAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomFieldValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomFieldValue[P]>
      : GetScalarType<T[P], AggregateCustomFieldValue[P]>
  }




  export type CustomFieldValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithAggregationInput | CustomFieldValueOrderByWithAggregationInput[]
    by: CustomFieldValueScalarFieldEnum[] | CustomFieldValueScalarFieldEnum
    having?: CustomFieldValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldValueCountAggregateInputType | true
    _min?: CustomFieldValueMinAggregateInputType
    _max?: CustomFieldValueMaxAggregateInputType
  }

  export type CustomFieldValueGroupByOutputType = {
    id: string
    fieldId: string
    entityType: $Enums.EntityType
    entityId: string
    value: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CustomFieldValueCountAggregateOutputType | null
    _min: CustomFieldValueMinAggregateOutputType | null
    _max: CustomFieldValueMaxAggregateOutputType | null
  }

  type GetCustomFieldValueGroupByPayload<T extends CustomFieldValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldValueGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldValueGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    entityType?: boolean
    entityId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customFieldValue"]>



  export type CustomFieldValueSelectScalar = {
    id?: boolean
    fieldId?: boolean
    entityType?: boolean
    entityId?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomFieldValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldId" | "entityType" | "entityId" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["customFieldValue"]>
  export type CustomFieldValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    field?: boolean | CustomFieldDefaultArgs<ExtArgs>
  }

  export type $CustomFieldValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomFieldValue"
    objects: {
      field: Prisma.$CustomFieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldId: string
      entityType: $Enums.EntityType
      entityId: string
      value: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customFieldValue"]>
    composites: {}
  }

  type CustomFieldValueGetPayload<S extends boolean | null | undefined | CustomFieldValueDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldValuePayload, S>

  type CustomFieldValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomFieldValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomFieldValueCountAggregateInputType | true
    }

  export interface CustomFieldValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomFieldValue'], meta: { name: 'CustomFieldValue' } }
    /**
     * Find zero or one CustomFieldValue that matches the filter.
     * @param {CustomFieldValueFindUniqueArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomFieldValueFindUniqueArgs>(args: SelectSubset<T, CustomFieldValueFindUniqueArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomFieldValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomFieldValueFindUniqueOrThrowArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomFieldValueFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomFieldValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindFirstArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomFieldValueFindFirstArgs>(args?: SelectSubset<T, CustomFieldValueFindFirstArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomFieldValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindFirstOrThrowArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomFieldValueFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomFieldValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomFieldValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFieldValues
     * const customFieldValues = await prisma.customFieldValue.findMany()
     * 
     * // Get first 10 CustomFieldValues
     * const customFieldValues = await prisma.customFieldValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldValueWithIdOnly = await prisma.customFieldValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomFieldValueFindManyArgs>(args?: SelectSubset<T, CustomFieldValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomFieldValue.
     * @param {CustomFieldValueCreateArgs} args - Arguments to create a CustomFieldValue.
     * @example
     * // Create one CustomFieldValue
     * const CustomFieldValue = await prisma.customFieldValue.create({
     *   data: {
     *     // ... data to create a CustomFieldValue
     *   }
     * })
     * 
     */
    create<T extends CustomFieldValueCreateArgs>(args: SelectSubset<T, CustomFieldValueCreateArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomFieldValues.
     * @param {CustomFieldValueCreateManyArgs} args - Arguments to create many CustomFieldValues.
     * @example
     * // Create many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomFieldValueCreateManyArgs>(args?: SelectSubset<T, CustomFieldValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomFieldValue.
     * @param {CustomFieldValueDeleteArgs} args - Arguments to delete one CustomFieldValue.
     * @example
     * // Delete one CustomFieldValue
     * const CustomFieldValue = await prisma.customFieldValue.delete({
     *   where: {
     *     // ... filter to delete one CustomFieldValue
     *   }
     * })
     * 
     */
    delete<T extends CustomFieldValueDeleteArgs>(args: SelectSubset<T, CustomFieldValueDeleteArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomFieldValue.
     * @param {CustomFieldValueUpdateArgs} args - Arguments to update one CustomFieldValue.
     * @example
     * // Update one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomFieldValueUpdateArgs>(args: SelectSubset<T, CustomFieldValueUpdateArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomFieldValues.
     * @param {CustomFieldValueDeleteManyArgs} args - Arguments to filter CustomFieldValues to delete.
     * @example
     * // Delete a few CustomFieldValues
     * const { count } = await prisma.customFieldValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomFieldValueDeleteManyArgs>(args?: SelectSubset<T, CustomFieldValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomFieldValueUpdateManyArgs>(args: SelectSubset<T, CustomFieldValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomFieldValue.
     * @param {CustomFieldValueUpsertArgs} args - Arguments to update or create a CustomFieldValue.
     * @example
     * // Update or create a CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.upsert({
     *   create: {
     *     // ... data to create a CustomFieldValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomFieldValue we want to update
     *   }
     * })
     */
    upsert<T extends CustomFieldValueUpsertArgs>(args: SelectSubset<T, CustomFieldValueUpsertArgs<ExtArgs>>): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomFieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueCountArgs} args - Arguments to filter CustomFieldValues to count.
     * @example
     * // Count the number of CustomFieldValues
     * const count = await prisma.customFieldValue.count({
     *   where: {
     *     // ... the filter for the CustomFieldValues we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldValueCountArgs>(
      args?: Subset<T, CustomFieldValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomFieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldValueAggregateArgs>(args: Subset<T, CustomFieldValueAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldValueAggregateType<T>>

    /**
     * Group by CustomFieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldValueGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomFieldValue model
   */
  readonly fields: CustomFieldValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomFieldValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    field<T extends CustomFieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomFieldDefaultArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomFieldValue model
   */
  interface CustomFieldValueFieldRefs {
    readonly id: FieldRef<"CustomFieldValue", 'String'>
    readonly fieldId: FieldRef<"CustomFieldValue", 'String'>
    readonly entityType: FieldRef<"CustomFieldValue", 'EntityType'>
    readonly entityId: FieldRef<"CustomFieldValue", 'String'>
    readonly value: FieldRef<"CustomFieldValue", 'Json'>
    readonly createdAt: FieldRef<"CustomFieldValue", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomFieldValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomFieldValue findUnique
   */
  export type CustomFieldValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue findUniqueOrThrow
   */
  export type CustomFieldValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue findFirst
   */
  export type CustomFieldValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFieldValues.
     */
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomFieldValue findFirstOrThrow
   */
  export type CustomFieldValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFieldValues.
     */
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomFieldValue findMany
   */
  export type CustomFieldValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValues to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }

  /**
   * CustomFieldValue create
   */
  export type CustomFieldValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomFieldValue.
     */
    data: XOR<CustomFieldValueCreateInput, CustomFieldValueUncheckedCreateInput>
  }

  /**
   * CustomFieldValue createMany
   */
  export type CustomFieldValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFieldValues.
     */
    data: CustomFieldValueCreateManyInput | CustomFieldValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomFieldValue update
   */
  export type CustomFieldValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomFieldValue.
     */
    data: XOR<CustomFieldValueUpdateInput, CustomFieldValueUncheckedUpdateInput>
    /**
     * Choose, which CustomFieldValue to update.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue updateMany
   */
  export type CustomFieldValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFieldValues.
     */
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyInput>
    /**
     * Filter which CustomFieldValues to update
     */
    where?: CustomFieldValueWhereInput
    /**
     * Limit how many CustomFieldValues to update.
     */
    limit?: number
  }

  /**
   * CustomFieldValue upsert
   */
  export type CustomFieldValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomFieldValue to update in case it exists.
     */
    where: CustomFieldValueWhereUniqueInput
    /**
     * In case the CustomFieldValue found by the `where` argument doesn't exist, create a new CustomFieldValue with this data.
     */
    create: XOR<CustomFieldValueCreateInput, CustomFieldValueUncheckedCreateInput>
    /**
     * In case the CustomFieldValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldValueUpdateInput, CustomFieldValueUncheckedUpdateInput>
  }

  /**
   * CustomFieldValue delete
   */
  export type CustomFieldValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter which CustomFieldValue to delete.
     */
    where: CustomFieldValueWhereUniqueInput
  }

  /**
   * CustomFieldValue deleteMany
   */
  export type CustomFieldValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFieldValues to delete
     */
    where?: CustomFieldValueWhereInput
    /**
     * Limit how many CustomFieldValues to delete.
     */
    limit?: number
  }

  /**
   * CustomFieldValue without action
   */
  export type CustomFieldValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomFieldValue
     */
    omit?: CustomFieldValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    portalId: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    portalId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    portalId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    portalId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    portalId: string | null
    userId: string | null
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    portal?: boolean | AuditLog$portalArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>



  export type AuditLogSelectScalar = {
    id?: boolean
    portalId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "userId" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | AuditLog$portalArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string | null
      userId: string | null
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends AuditLog$portalArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$portalArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly portalId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.portal
   */
  export type AuditLog$portalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portal
     */
    select?: PortalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portal
     */
    omit?: PortalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalInclude<ExtArgs> | null
    where?: PortalWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SeoKeyword
   */

  export type AggregateSeoKeyword = {
    _count: SeoKeywordCountAggregateOutputType | null
    _avg: SeoKeywordAvgAggregateOutputType | null
    _sum: SeoKeywordSumAggregateOutputType | null
    _min: SeoKeywordMinAggregateOutputType | null
    _max: SeoKeywordMaxAggregateOutputType | null
  }

  export type SeoKeywordAvgAggregateOutputType = {
    volume: number | null
    difficulty: number | null
  }

  export type SeoKeywordSumAggregateOutputType = {
    volume: number | null
    difficulty: number | null
  }

  export type SeoKeywordMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    keyword: string | null
    language: string | null
    volume: number | null
    difficulty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeoKeywordMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    keyword: string | null
    language: string | null
    volume: number | null
    difficulty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeoKeywordCountAggregateOutputType = {
    id: number
    portalId: number
    keyword: number
    language: number
    volume: number
    difficulty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeoKeywordAvgAggregateInputType = {
    volume?: true
    difficulty?: true
  }

  export type SeoKeywordSumAggregateInputType = {
    volume?: true
    difficulty?: true
  }

  export type SeoKeywordMinAggregateInputType = {
    id?: true
    portalId?: true
    keyword?: true
    language?: true
    volume?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeoKeywordMaxAggregateInputType = {
    id?: true
    portalId?: true
    keyword?: true
    language?: true
    volume?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeoKeywordCountAggregateInputType = {
    id?: true
    portalId?: true
    keyword?: true
    language?: true
    volume?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeoKeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoKeyword to aggregate.
     */
    where?: SeoKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoKeywords to fetch.
     */
    orderBy?: SeoKeywordOrderByWithRelationInput | SeoKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeoKeywords
    **/
    _count?: true | SeoKeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeoKeywordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeoKeywordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoKeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoKeywordMaxAggregateInputType
  }

  export type GetSeoKeywordAggregateType<T extends SeoKeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateSeoKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeoKeyword[P]>
      : GetScalarType<T[P], AggregateSeoKeyword[P]>
  }




  export type SeoKeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoKeywordWhereInput
    orderBy?: SeoKeywordOrderByWithAggregationInput | SeoKeywordOrderByWithAggregationInput[]
    by: SeoKeywordScalarFieldEnum[] | SeoKeywordScalarFieldEnum
    having?: SeoKeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoKeywordCountAggregateInputType | true
    _avg?: SeoKeywordAvgAggregateInputType
    _sum?: SeoKeywordSumAggregateInputType
    _min?: SeoKeywordMinAggregateInputType
    _max?: SeoKeywordMaxAggregateInputType
  }

  export type SeoKeywordGroupByOutputType = {
    id: string
    portalId: string
    keyword: string
    language: string
    volume: number | null
    difficulty: number | null
    createdAt: Date
    updatedAt: Date
    _count: SeoKeywordCountAggregateOutputType | null
    _avg: SeoKeywordAvgAggregateOutputType | null
    _sum: SeoKeywordSumAggregateOutputType | null
    _min: SeoKeywordMinAggregateOutputType | null
    _max: SeoKeywordMaxAggregateOutputType | null
  }

  type GetSeoKeywordGroupByPayload<T extends SeoKeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoKeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoKeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoKeywordGroupByOutputType[P]>
            : GetScalarType<T[P], SeoKeywordGroupByOutputType[P]>
        }
      >
    >


  export type SeoKeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    keyword?: boolean
    language?: boolean
    volume?: boolean
    difficulty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    serpPositions?: boolean | SeoKeyword$serpPositionsArgs<ExtArgs>
    _count?: boolean | SeoKeywordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seoKeyword"]>



  export type SeoKeywordSelectScalar = {
    id?: boolean
    portalId?: boolean
    keyword?: boolean
    language?: boolean
    volume?: boolean
    difficulty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeoKeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "keyword" | "language" | "volume" | "difficulty" | "createdAt" | "updatedAt", ExtArgs["result"]["seoKeyword"]>
  export type SeoKeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    serpPositions?: boolean | SeoKeyword$serpPositionsArgs<ExtArgs>
    _count?: boolean | SeoKeywordCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SeoKeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeoKeyword"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      serpPositions: Prisma.$SerpPositionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      keyword: string
      language: string
      volume: number | null
      difficulty: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seoKeyword"]>
    composites: {}
  }

  type SeoKeywordGetPayload<S extends boolean | null | undefined | SeoKeywordDefaultArgs> = $Result.GetResult<Prisma.$SeoKeywordPayload, S>

  type SeoKeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoKeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoKeywordCountAggregateInputType | true
    }

  export interface SeoKeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeoKeyword'], meta: { name: 'SeoKeyword' } }
    /**
     * Find zero or one SeoKeyword that matches the filter.
     * @param {SeoKeywordFindUniqueArgs} args - Arguments to find a SeoKeyword
     * @example
     * // Get one SeoKeyword
     * const seoKeyword = await prisma.seoKeyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoKeywordFindUniqueArgs>(args: SelectSubset<T, SeoKeywordFindUniqueArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeoKeyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoKeywordFindUniqueOrThrowArgs} args - Arguments to find a SeoKeyword
     * @example
     * // Get one SeoKeyword
     * const seoKeyword = await prisma.seoKeyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoKeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoKeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoKeyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordFindFirstArgs} args - Arguments to find a SeoKeyword
     * @example
     * // Get one SeoKeyword
     * const seoKeyword = await prisma.seoKeyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoKeywordFindFirstArgs>(args?: SelectSubset<T, SeoKeywordFindFirstArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoKeyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordFindFirstOrThrowArgs} args - Arguments to find a SeoKeyword
     * @example
     * // Get one SeoKeyword
     * const seoKeyword = await prisma.seoKeyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoKeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoKeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeoKeywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeoKeywords
     * const seoKeywords = await prisma.seoKeyword.findMany()
     * 
     * // Get first 10 SeoKeywords
     * const seoKeywords = await prisma.seoKeyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoKeywordWithIdOnly = await prisma.seoKeyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoKeywordFindManyArgs>(args?: SelectSubset<T, SeoKeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeoKeyword.
     * @param {SeoKeywordCreateArgs} args - Arguments to create a SeoKeyword.
     * @example
     * // Create one SeoKeyword
     * const SeoKeyword = await prisma.seoKeyword.create({
     *   data: {
     *     // ... data to create a SeoKeyword
     *   }
     * })
     * 
     */
    create<T extends SeoKeywordCreateArgs>(args: SelectSubset<T, SeoKeywordCreateArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeoKeywords.
     * @param {SeoKeywordCreateManyArgs} args - Arguments to create many SeoKeywords.
     * @example
     * // Create many SeoKeywords
     * const seoKeyword = await prisma.seoKeyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoKeywordCreateManyArgs>(args?: SelectSubset<T, SeoKeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeoKeyword.
     * @param {SeoKeywordDeleteArgs} args - Arguments to delete one SeoKeyword.
     * @example
     * // Delete one SeoKeyword
     * const SeoKeyword = await prisma.seoKeyword.delete({
     *   where: {
     *     // ... filter to delete one SeoKeyword
     *   }
     * })
     * 
     */
    delete<T extends SeoKeywordDeleteArgs>(args: SelectSubset<T, SeoKeywordDeleteArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeoKeyword.
     * @param {SeoKeywordUpdateArgs} args - Arguments to update one SeoKeyword.
     * @example
     * // Update one SeoKeyword
     * const seoKeyword = await prisma.seoKeyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoKeywordUpdateArgs>(args: SelectSubset<T, SeoKeywordUpdateArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeoKeywords.
     * @param {SeoKeywordDeleteManyArgs} args - Arguments to filter SeoKeywords to delete.
     * @example
     * // Delete a few SeoKeywords
     * const { count } = await prisma.seoKeyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoKeywordDeleteManyArgs>(args?: SelectSubset<T, SeoKeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeoKeywords
     * const seoKeyword = await prisma.seoKeyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoKeywordUpdateManyArgs>(args: SelectSubset<T, SeoKeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeoKeyword.
     * @param {SeoKeywordUpsertArgs} args - Arguments to update or create a SeoKeyword.
     * @example
     * // Update or create a SeoKeyword
     * const seoKeyword = await prisma.seoKeyword.upsert({
     *   create: {
     *     // ... data to create a SeoKeyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeoKeyword we want to update
     *   }
     * })
     */
    upsert<T extends SeoKeywordUpsertArgs>(args: SelectSubset<T, SeoKeywordUpsertArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeoKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordCountArgs} args - Arguments to filter SeoKeywords to count.
     * @example
     * // Count the number of SeoKeywords
     * const count = await prisma.seoKeyword.count({
     *   where: {
     *     // ... the filter for the SeoKeywords we want to count
     *   }
     * })
    **/
    count<T extends SeoKeywordCountArgs>(
      args?: Subset<T, SeoKeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoKeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeoKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoKeywordAggregateArgs>(args: Subset<T, SeoKeywordAggregateArgs>): Prisma.PrismaPromise<GetSeoKeywordAggregateType<T>>

    /**
     * Group by SeoKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoKeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoKeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoKeywordGroupByArgs['orderBy'] }
        : { orderBy?: SeoKeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoKeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeoKeyword model
   */
  readonly fields: SeoKeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeoKeyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoKeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serpPositions<T extends SeoKeyword$serpPositionsArgs<ExtArgs> = {}>(args?: Subset<T, SeoKeyword$serpPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeoKeyword model
   */
  interface SeoKeywordFieldRefs {
    readonly id: FieldRef<"SeoKeyword", 'String'>
    readonly portalId: FieldRef<"SeoKeyword", 'String'>
    readonly keyword: FieldRef<"SeoKeyword", 'String'>
    readonly language: FieldRef<"SeoKeyword", 'String'>
    readonly volume: FieldRef<"SeoKeyword", 'Int'>
    readonly difficulty: FieldRef<"SeoKeyword", 'Int'>
    readonly createdAt: FieldRef<"SeoKeyword", 'DateTime'>
    readonly updatedAt: FieldRef<"SeoKeyword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeoKeyword findUnique
   */
  export type SeoKeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SeoKeyword to fetch.
     */
    where: SeoKeywordWhereUniqueInput
  }

  /**
   * SeoKeyword findUniqueOrThrow
   */
  export type SeoKeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SeoKeyword to fetch.
     */
    where: SeoKeywordWhereUniqueInput
  }

  /**
   * SeoKeyword findFirst
   */
  export type SeoKeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SeoKeyword to fetch.
     */
    where?: SeoKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoKeywords to fetch.
     */
    orderBy?: SeoKeywordOrderByWithRelationInput | SeoKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoKeywords.
     */
    cursor?: SeoKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoKeywords.
     */
    distinct?: SeoKeywordScalarFieldEnum | SeoKeywordScalarFieldEnum[]
  }

  /**
   * SeoKeyword findFirstOrThrow
   */
  export type SeoKeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SeoKeyword to fetch.
     */
    where?: SeoKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoKeywords to fetch.
     */
    orderBy?: SeoKeywordOrderByWithRelationInput | SeoKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoKeywords.
     */
    cursor?: SeoKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoKeywords.
     */
    distinct?: SeoKeywordScalarFieldEnum | SeoKeywordScalarFieldEnum[]
  }

  /**
   * SeoKeyword findMany
   */
  export type SeoKeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * Filter, which SeoKeywords to fetch.
     */
    where?: SeoKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoKeywords to fetch.
     */
    orderBy?: SeoKeywordOrderByWithRelationInput | SeoKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeoKeywords.
     */
    cursor?: SeoKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoKeywords.
     */
    skip?: number
    distinct?: SeoKeywordScalarFieldEnum | SeoKeywordScalarFieldEnum[]
  }

  /**
   * SeoKeyword create
   */
  export type SeoKeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a SeoKeyword.
     */
    data: XOR<SeoKeywordCreateInput, SeoKeywordUncheckedCreateInput>
  }

  /**
   * SeoKeyword createMany
   */
  export type SeoKeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeoKeywords.
     */
    data: SeoKeywordCreateManyInput | SeoKeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeoKeyword update
   */
  export type SeoKeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a SeoKeyword.
     */
    data: XOR<SeoKeywordUpdateInput, SeoKeywordUncheckedUpdateInput>
    /**
     * Choose, which SeoKeyword to update.
     */
    where: SeoKeywordWhereUniqueInput
  }

  /**
   * SeoKeyword updateMany
   */
  export type SeoKeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeoKeywords.
     */
    data: XOR<SeoKeywordUpdateManyMutationInput, SeoKeywordUncheckedUpdateManyInput>
    /**
     * Filter which SeoKeywords to update
     */
    where?: SeoKeywordWhereInput
    /**
     * Limit how many SeoKeywords to update.
     */
    limit?: number
  }

  /**
   * SeoKeyword upsert
   */
  export type SeoKeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the SeoKeyword to update in case it exists.
     */
    where: SeoKeywordWhereUniqueInput
    /**
     * In case the SeoKeyword found by the `where` argument doesn't exist, create a new SeoKeyword with this data.
     */
    create: XOR<SeoKeywordCreateInput, SeoKeywordUncheckedCreateInput>
    /**
     * In case the SeoKeyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoKeywordUpdateInput, SeoKeywordUncheckedUpdateInput>
  }

  /**
   * SeoKeyword delete
   */
  export type SeoKeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
    /**
     * Filter which SeoKeyword to delete.
     */
    where: SeoKeywordWhereUniqueInput
  }

  /**
   * SeoKeyword deleteMany
   */
  export type SeoKeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoKeywords to delete
     */
    where?: SeoKeywordWhereInput
    /**
     * Limit how many SeoKeywords to delete.
     */
    limit?: number
  }

  /**
   * SeoKeyword.serpPositions
   */
  export type SeoKeyword$serpPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    where?: SerpPositionWhereInput
    orderBy?: SerpPositionOrderByWithRelationInput | SerpPositionOrderByWithRelationInput[]
    cursor?: SerpPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SerpPositionScalarFieldEnum | SerpPositionScalarFieldEnum[]
  }

  /**
   * SeoKeyword without action
   */
  export type SeoKeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoKeyword
     */
    select?: SeoKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoKeyword
     */
    omit?: SeoKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoKeywordInclude<ExtArgs> | null
  }


  /**
   * Model SeoArticle
   */

  export type AggregateSeoArticle = {
    _count: SeoArticleCountAggregateOutputType | null
    _min: SeoArticleMinAggregateOutputType | null
    _max: SeoArticleMaxAggregateOutputType | null
  }

  export type SeoArticleMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    language: string | null
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    isPublished: boolean | null
    aiGenerated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeoArticleMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    language: string | null
    metaTitle: string | null
    metaDescription: string | null
    ogImage: string | null
    isPublished: boolean | null
    aiGenerated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeoArticleCountAggregateOutputType = {
    id: number
    portalId: number
    title: number
    slug: number
    content: number
    excerpt: number
    language: number
    metaTitle: number
    metaDescription: number
    keywords: number
    faqSchema: number
    ogImage: number
    isPublished: number
    aiGenerated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeoArticleMinAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    language?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    isPublished?: true
    aiGenerated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeoArticleMaxAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    language?: true
    metaTitle?: true
    metaDescription?: true
    ogImage?: true
    isPublished?: true
    aiGenerated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeoArticleCountAggregateInputType = {
    id?: true
    portalId?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    language?: true
    metaTitle?: true
    metaDescription?: true
    keywords?: true
    faqSchema?: true
    ogImage?: true
    isPublished?: true
    aiGenerated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeoArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoArticle to aggregate.
     */
    where?: SeoArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoArticles to fetch.
     */
    orderBy?: SeoArticleOrderByWithRelationInput | SeoArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeoArticles
    **/
    _count?: true | SeoArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoArticleMaxAggregateInputType
  }

  export type GetSeoArticleAggregateType<T extends SeoArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateSeoArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeoArticle[P]>
      : GetScalarType<T[P], AggregateSeoArticle[P]>
  }




  export type SeoArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoArticleWhereInput
    orderBy?: SeoArticleOrderByWithAggregationInput | SeoArticleOrderByWithAggregationInput[]
    by: SeoArticleScalarFieldEnum[] | SeoArticleScalarFieldEnum
    having?: SeoArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoArticleCountAggregateInputType | true
    _min?: SeoArticleMinAggregateInputType
    _max?: SeoArticleMaxAggregateInputType
  }

  export type SeoArticleGroupByOutputType = {
    id: string
    portalId: string
    title: string
    slug: string
    content: string
    excerpt: string | null
    language: string
    metaTitle: string | null
    metaDescription: string | null
    keywords: JsonValue | null
    faqSchema: JsonValue | null
    ogImage: string | null
    isPublished: boolean
    aiGenerated: boolean
    createdAt: Date
    updatedAt: Date
    _count: SeoArticleCountAggregateOutputType | null
    _min: SeoArticleMinAggregateOutputType | null
    _max: SeoArticleMaxAggregateOutputType | null
  }

  type GetSeoArticleGroupByPayload<T extends SeoArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoArticleGroupByOutputType[P]>
            : GetScalarType<T[P], SeoArticleGroupByOutputType[P]>
        }
      >
    >


  export type SeoArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    language?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    faqSchema?: boolean
    ogImage?: boolean
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seoArticle"]>



  export type SeoArticleSelectScalar = {
    id?: boolean
    portalId?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    language?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    keywords?: boolean
    faqSchema?: boolean
    ogImage?: boolean
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeoArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "title" | "slug" | "content" | "excerpt" | "language" | "metaTitle" | "metaDescription" | "keywords" | "faqSchema" | "ogImage" | "isPublished" | "aiGenerated" | "createdAt" | "updatedAt", ExtArgs["result"]["seoArticle"]>
  export type SeoArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
  }

  export type $SeoArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeoArticle"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      title: string
      slug: string
      content: string
      excerpt: string | null
      language: string
      metaTitle: string | null
      metaDescription: string | null
      keywords: Prisma.JsonValue | null
      faqSchema: Prisma.JsonValue | null
      ogImage: string | null
      isPublished: boolean
      aiGenerated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["seoArticle"]>
    composites: {}
  }

  type SeoArticleGetPayload<S extends boolean | null | undefined | SeoArticleDefaultArgs> = $Result.GetResult<Prisma.$SeoArticlePayload, S>

  type SeoArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoArticleCountAggregateInputType | true
    }

  export interface SeoArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeoArticle'], meta: { name: 'SeoArticle' } }
    /**
     * Find zero or one SeoArticle that matches the filter.
     * @param {SeoArticleFindUniqueArgs} args - Arguments to find a SeoArticle
     * @example
     * // Get one SeoArticle
     * const seoArticle = await prisma.seoArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoArticleFindUniqueArgs>(args: SelectSubset<T, SeoArticleFindUniqueArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeoArticle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoArticleFindUniqueOrThrowArgs} args - Arguments to find a SeoArticle
     * @example
     * // Get one SeoArticle
     * const seoArticle = await prisma.seoArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleFindFirstArgs} args - Arguments to find a SeoArticle
     * @example
     * // Get one SeoArticle
     * const seoArticle = await prisma.seoArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoArticleFindFirstArgs>(args?: SelectSubset<T, SeoArticleFindFirstArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleFindFirstOrThrowArgs} args - Arguments to find a SeoArticle
     * @example
     * // Get one SeoArticle
     * const seoArticle = await prisma.seoArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeoArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeoArticles
     * const seoArticles = await prisma.seoArticle.findMany()
     * 
     * // Get first 10 SeoArticles
     * const seoArticles = await prisma.seoArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoArticleWithIdOnly = await prisma.seoArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoArticleFindManyArgs>(args?: SelectSubset<T, SeoArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeoArticle.
     * @param {SeoArticleCreateArgs} args - Arguments to create a SeoArticle.
     * @example
     * // Create one SeoArticle
     * const SeoArticle = await prisma.seoArticle.create({
     *   data: {
     *     // ... data to create a SeoArticle
     *   }
     * })
     * 
     */
    create<T extends SeoArticleCreateArgs>(args: SelectSubset<T, SeoArticleCreateArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeoArticles.
     * @param {SeoArticleCreateManyArgs} args - Arguments to create many SeoArticles.
     * @example
     * // Create many SeoArticles
     * const seoArticle = await prisma.seoArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoArticleCreateManyArgs>(args?: SelectSubset<T, SeoArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeoArticle.
     * @param {SeoArticleDeleteArgs} args - Arguments to delete one SeoArticle.
     * @example
     * // Delete one SeoArticle
     * const SeoArticle = await prisma.seoArticle.delete({
     *   where: {
     *     // ... filter to delete one SeoArticle
     *   }
     * })
     * 
     */
    delete<T extends SeoArticleDeleteArgs>(args: SelectSubset<T, SeoArticleDeleteArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeoArticle.
     * @param {SeoArticleUpdateArgs} args - Arguments to update one SeoArticle.
     * @example
     * // Update one SeoArticle
     * const seoArticle = await prisma.seoArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoArticleUpdateArgs>(args: SelectSubset<T, SeoArticleUpdateArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeoArticles.
     * @param {SeoArticleDeleteManyArgs} args - Arguments to filter SeoArticles to delete.
     * @example
     * // Delete a few SeoArticles
     * const { count } = await prisma.seoArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoArticleDeleteManyArgs>(args?: SelectSubset<T, SeoArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeoArticles
     * const seoArticle = await prisma.seoArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoArticleUpdateManyArgs>(args: SelectSubset<T, SeoArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeoArticle.
     * @param {SeoArticleUpsertArgs} args - Arguments to update or create a SeoArticle.
     * @example
     * // Update or create a SeoArticle
     * const seoArticle = await prisma.seoArticle.upsert({
     *   create: {
     *     // ... data to create a SeoArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeoArticle we want to update
     *   }
     * })
     */
    upsert<T extends SeoArticleUpsertArgs>(args: SelectSubset<T, SeoArticleUpsertArgs<ExtArgs>>): Prisma__SeoArticleClient<$Result.GetResult<Prisma.$SeoArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeoArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleCountArgs} args - Arguments to filter SeoArticles to count.
     * @example
     * // Count the number of SeoArticles
     * const count = await prisma.seoArticle.count({
     *   where: {
     *     // ... the filter for the SeoArticles we want to count
     *   }
     * })
    **/
    count<T extends SeoArticleCountArgs>(
      args?: Subset<T, SeoArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeoArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoArticleAggregateArgs>(args: Subset<T, SeoArticleAggregateArgs>): Prisma.PrismaPromise<GetSeoArticleAggregateType<T>>

    /**
     * Group by SeoArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoArticleGroupByArgs['orderBy'] }
        : { orderBy?: SeoArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeoArticle model
   */
  readonly fields: SeoArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeoArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeoArticle model
   */
  interface SeoArticleFieldRefs {
    readonly id: FieldRef<"SeoArticle", 'String'>
    readonly portalId: FieldRef<"SeoArticle", 'String'>
    readonly title: FieldRef<"SeoArticle", 'String'>
    readonly slug: FieldRef<"SeoArticle", 'String'>
    readonly content: FieldRef<"SeoArticle", 'String'>
    readonly excerpt: FieldRef<"SeoArticle", 'String'>
    readonly language: FieldRef<"SeoArticle", 'String'>
    readonly metaTitle: FieldRef<"SeoArticle", 'String'>
    readonly metaDescription: FieldRef<"SeoArticle", 'String'>
    readonly keywords: FieldRef<"SeoArticle", 'Json'>
    readonly faqSchema: FieldRef<"SeoArticle", 'Json'>
    readonly ogImage: FieldRef<"SeoArticle", 'String'>
    readonly isPublished: FieldRef<"SeoArticle", 'Boolean'>
    readonly aiGenerated: FieldRef<"SeoArticle", 'Boolean'>
    readonly createdAt: FieldRef<"SeoArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"SeoArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeoArticle findUnique
   */
  export type SeoArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * Filter, which SeoArticle to fetch.
     */
    where: SeoArticleWhereUniqueInput
  }

  /**
   * SeoArticle findUniqueOrThrow
   */
  export type SeoArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * Filter, which SeoArticle to fetch.
     */
    where: SeoArticleWhereUniqueInput
  }

  /**
   * SeoArticle findFirst
   */
  export type SeoArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * Filter, which SeoArticle to fetch.
     */
    where?: SeoArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoArticles to fetch.
     */
    orderBy?: SeoArticleOrderByWithRelationInput | SeoArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoArticles.
     */
    cursor?: SeoArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoArticles.
     */
    distinct?: SeoArticleScalarFieldEnum | SeoArticleScalarFieldEnum[]
  }

  /**
   * SeoArticle findFirstOrThrow
   */
  export type SeoArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * Filter, which SeoArticle to fetch.
     */
    where?: SeoArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoArticles to fetch.
     */
    orderBy?: SeoArticleOrderByWithRelationInput | SeoArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoArticles.
     */
    cursor?: SeoArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoArticles.
     */
    distinct?: SeoArticleScalarFieldEnum | SeoArticleScalarFieldEnum[]
  }

  /**
   * SeoArticle findMany
   */
  export type SeoArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * Filter, which SeoArticles to fetch.
     */
    where?: SeoArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoArticles to fetch.
     */
    orderBy?: SeoArticleOrderByWithRelationInput | SeoArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeoArticles.
     */
    cursor?: SeoArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoArticles.
     */
    skip?: number
    distinct?: SeoArticleScalarFieldEnum | SeoArticleScalarFieldEnum[]
  }

  /**
   * SeoArticle create
   */
  export type SeoArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a SeoArticle.
     */
    data: XOR<SeoArticleCreateInput, SeoArticleUncheckedCreateInput>
  }

  /**
   * SeoArticle createMany
   */
  export type SeoArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeoArticles.
     */
    data: SeoArticleCreateManyInput | SeoArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeoArticle update
   */
  export type SeoArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a SeoArticle.
     */
    data: XOR<SeoArticleUpdateInput, SeoArticleUncheckedUpdateInput>
    /**
     * Choose, which SeoArticle to update.
     */
    where: SeoArticleWhereUniqueInput
  }

  /**
   * SeoArticle updateMany
   */
  export type SeoArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeoArticles.
     */
    data: XOR<SeoArticleUpdateManyMutationInput, SeoArticleUncheckedUpdateManyInput>
    /**
     * Filter which SeoArticles to update
     */
    where?: SeoArticleWhereInput
    /**
     * Limit how many SeoArticles to update.
     */
    limit?: number
  }

  /**
   * SeoArticle upsert
   */
  export type SeoArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the SeoArticle to update in case it exists.
     */
    where: SeoArticleWhereUniqueInput
    /**
     * In case the SeoArticle found by the `where` argument doesn't exist, create a new SeoArticle with this data.
     */
    create: XOR<SeoArticleCreateInput, SeoArticleUncheckedCreateInput>
    /**
     * In case the SeoArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoArticleUpdateInput, SeoArticleUncheckedUpdateInput>
  }

  /**
   * SeoArticle delete
   */
  export type SeoArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
    /**
     * Filter which SeoArticle to delete.
     */
    where: SeoArticleWhereUniqueInput
  }

  /**
   * SeoArticle deleteMany
   */
  export type SeoArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoArticles to delete
     */
    where?: SeoArticleWhereInput
    /**
     * Limit how many SeoArticles to delete.
     */
    limit?: number
  }

  /**
   * SeoArticle without action
   */
  export type SeoArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoArticle
     */
    select?: SeoArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoArticle
     */
    omit?: SeoArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoArticleInclude<ExtArgs> | null
  }


  /**
   * Model SerpPosition
   */

  export type AggregateSerpPosition = {
    _count: SerpPositionCountAggregateOutputType | null
    _avg: SerpPositionAvgAggregateOutputType | null
    _sum: SerpPositionSumAggregateOutputType | null
    _min: SerpPositionMinAggregateOutputType | null
    _max: SerpPositionMaxAggregateOutputType | null
  }

  export type SerpPositionAvgAggregateOutputType = {
    position: number | null
  }

  export type SerpPositionSumAggregateOutputType = {
    position: number | null
  }

  export type SerpPositionMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    keywordId: string | null
    position: number | null
    url: string | null
    searchEngine: string | null
    country: string | null
    createdAt: Date | null
  }

  export type SerpPositionMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    keywordId: string | null
    position: number | null
    url: string | null
    searchEngine: string | null
    country: string | null
    createdAt: Date | null
  }

  export type SerpPositionCountAggregateOutputType = {
    id: number
    portalId: number
    keywordId: number
    position: number
    url: number
    searchEngine: number
    country: number
    createdAt: number
    _all: number
  }


  export type SerpPositionAvgAggregateInputType = {
    position?: true
  }

  export type SerpPositionSumAggregateInputType = {
    position?: true
  }

  export type SerpPositionMinAggregateInputType = {
    id?: true
    portalId?: true
    keywordId?: true
    position?: true
    url?: true
    searchEngine?: true
    country?: true
    createdAt?: true
  }

  export type SerpPositionMaxAggregateInputType = {
    id?: true
    portalId?: true
    keywordId?: true
    position?: true
    url?: true
    searchEngine?: true
    country?: true
    createdAt?: true
  }

  export type SerpPositionCountAggregateInputType = {
    id?: true
    portalId?: true
    keywordId?: true
    position?: true
    url?: true
    searchEngine?: true
    country?: true
    createdAt?: true
    _all?: true
  }

  export type SerpPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SerpPosition to aggregate.
     */
    where?: SerpPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SerpPositions to fetch.
     */
    orderBy?: SerpPositionOrderByWithRelationInput | SerpPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SerpPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SerpPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SerpPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SerpPositions
    **/
    _count?: true | SerpPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SerpPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SerpPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SerpPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SerpPositionMaxAggregateInputType
  }

  export type GetSerpPositionAggregateType<T extends SerpPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateSerpPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSerpPosition[P]>
      : GetScalarType<T[P], AggregateSerpPosition[P]>
  }




  export type SerpPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SerpPositionWhereInput
    orderBy?: SerpPositionOrderByWithAggregationInput | SerpPositionOrderByWithAggregationInput[]
    by: SerpPositionScalarFieldEnum[] | SerpPositionScalarFieldEnum
    having?: SerpPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SerpPositionCountAggregateInputType | true
    _avg?: SerpPositionAvgAggregateInputType
    _sum?: SerpPositionSumAggregateInputType
    _min?: SerpPositionMinAggregateInputType
    _max?: SerpPositionMaxAggregateInputType
  }

  export type SerpPositionGroupByOutputType = {
    id: string
    portalId: string
    keywordId: string
    position: number | null
    url: string | null
    searchEngine: string
    country: string | null
    createdAt: Date
    _count: SerpPositionCountAggregateOutputType | null
    _avg: SerpPositionAvgAggregateOutputType | null
    _sum: SerpPositionSumAggregateOutputType | null
    _min: SerpPositionMinAggregateOutputType | null
    _max: SerpPositionMaxAggregateOutputType | null
  }

  type GetSerpPositionGroupByPayload<T extends SerpPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SerpPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SerpPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SerpPositionGroupByOutputType[P]>
            : GetScalarType<T[P], SerpPositionGroupByOutputType[P]>
        }
      >
    >


  export type SerpPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    keywordId?: boolean
    position?: boolean
    url?: boolean
    searchEngine?: boolean
    country?: boolean
    createdAt?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    keyword?: boolean | SeoKeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serpPosition"]>



  export type SerpPositionSelectScalar = {
    id?: boolean
    portalId?: boolean
    keywordId?: boolean
    position?: boolean
    url?: boolean
    searchEngine?: boolean
    country?: boolean
    createdAt?: boolean
  }

  export type SerpPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "keywordId" | "position" | "url" | "searchEngine" | "country" | "createdAt", ExtArgs["result"]["serpPosition"]>
  export type SerpPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
    keyword?: boolean | SeoKeywordDefaultArgs<ExtArgs>
  }

  export type $SerpPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SerpPosition"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
      keyword: Prisma.$SeoKeywordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      keywordId: string
      position: number | null
      url: string | null
      searchEngine: string
      country: string | null
      createdAt: Date
    }, ExtArgs["result"]["serpPosition"]>
    composites: {}
  }

  type SerpPositionGetPayload<S extends boolean | null | undefined | SerpPositionDefaultArgs> = $Result.GetResult<Prisma.$SerpPositionPayload, S>

  type SerpPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SerpPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SerpPositionCountAggregateInputType | true
    }

  export interface SerpPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SerpPosition'], meta: { name: 'SerpPosition' } }
    /**
     * Find zero or one SerpPosition that matches the filter.
     * @param {SerpPositionFindUniqueArgs} args - Arguments to find a SerpPosition
     * @example
     * // Get one SerpPosition
     * const serpPosition = await prisma.serpPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SerpPositionFindUniqueArgs>(args: SelectSubset<T, SerpPositionFindUniqueArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SerpPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SerpPositionFindUniqueOrThrowArgs} args - Arguments to find a SerpPosition
     * @example
     * // Get one SerpPosition
     * const serpPosition = await prisma.serpPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SerpPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, SerpPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SerpPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionFindFirstArgs} args - Arguments to find a SerpPosition
     * @example
     * // Get one SerpPosition
     * const serpPosition = await prisma.serpPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SerpPositionFindFirstArgs>(args?: SelectSubset<T, SerpPositionFindFirstArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SerpPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionFindFirstOrThrowArgs} args - Arguments to find a SerpPosition
     * @example
     * // Get one SerpPosition
     * const serpPosition = await prisma.serpPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SerpPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, SerpPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SerpPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SerpPositions
     * const serpPositions = await prisma.serpPosition.findMany()
     * 
     * // Get first 10 SerpPositions
     * const serpPositions = await prisma.serpPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serpPositionWithIdOnly = await prisma.serpPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SerpPositionFindManyArgs>(args?: SelectSubset<T, SerpPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SerpPosition.
     * @param {SerpPositionCreateArgs} args - Arguments to create a SerpPosition.
     * @example
     * // Create one SerpPosition
     * const SerpPosition = await prisma.serpPosition.create({
     *   data: {
     *     // ... data to create a SerpPosition
     *   }
     * })
     * 
     */
    create<T extends SerpPositionCreateArgs>(args: SelectSubset<T, SerpPositionCreateArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SerpPositions.
     * @param {SerpPositionCreateManyArgs} args - Arguments to create many SerpPositions.
     * @example
     * // Create many SerpPositions
     * const serpPosition = await prisma.serpPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SerpPositionCreateManyArgs>(args?: SelectSubset<T, SerpPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SerpPosition.
     * @param {SerpPositionDeleteArgs} args - Arguments to delete one SerpPosition.
     * @example
     * // Delete one SerpPosition
     * const SerpPosition = await prisma.serpPosition.delete({
     *   where: {
     *     // ... filter to delete one SerpPosition
     *   }
     * })
     * 
     */
    delete<T extends SerpPositionDeleteArgs>(args: SelectSubset<T, SerpPositionDeleteArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SerpPosition.
     * @param {SerpPositionUpdateArgs} args - Arguments to update one SerpPosition.
     * @example
     * // Update one SerpPosition
     * const serpPosition = await prisma.serpPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SerpPositionUpdateArgs>(args: SelectSubset<T, SerpPositionUpdateArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SerpPositions.
     * @param {SerpPositionDeleteManyArgs} args - Arguments to filter SerpPositions to delete.
     * @example
     * // Delete a few SerpPositions
     * const { count } = await prisma.serpPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SerpPositionDeleteManyArgs>(args?: SelectSubset<T, SerpPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SerpPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SerpPositions
     * const serpPosition = await prisma.serpPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SerpPositionUpdateManyArgs>(args: SelectSubset<T, SerpPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SerpPosition.
     * @param {SerpPositionUpsertArgs} args - Arguments to update or create a SerpPosition.
     * @example
     * // Update or create a SerpPosition
     * const serpPosition = await prisma.serpPosition.upsert({
     *   create: {
     *     // ... data to create a SerpPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SerpPosition we want to update
     *   }
     * })
     */
    upsert<T extends SerpPositionUpsertArgs>(args: SelectSubset<T, SerpPositionUpsertArgs<ExtArgs>>): Prisma__SerpPositionClient<$Result.GetResult<Prisma.$SerpPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SerpPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionCountArgs} args - Arguments to filter SerpPositions to count.
     * @example
     * // Count the number of SerpPositions
     * const count = await prisma.serpPosition.count({
     *   where: {
     *     // ... the filter for the SerpPositions we want to count
     *   }
     * })
    **/
    count<T extends SerpPositionCountArgs>(
      args?: Subset<T, SerpPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SerpPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SerpPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SerpPositionAggregateArgs>(args: Subset<T, SerpPositionAggregateArgs>): Prisma.PrismaPromise<GetSerpPositionAggregateType<T>>

    /**
     * Group by SerpPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerpPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SerpPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SerpPositionGroupByArgs['orderBy'] }
        : { orderBy?: SerpPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SerpPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSerpPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SerpPosition model
   */
  readonly fields: SerpPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SerpPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SerpPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    keyword<T extends SeoKeywordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeoKeywordDefaultArgs<ExtArgs>>): Prisma__SeoKeywordClient<$Result.GetResult<Prisma.$SeoKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SerpPosition model
   */
  interface SerpPositionFieldRefs {
    readonly id: FieldRef<"SerpPosition", 'String'>
    readonly portalId: FieldRef<"SerpPosition", 'String'>
    readonly keywordId: FieldRef<"SerpPosition", 'String'>
    readonly position: FieldRef<"SerpPosition", 'Int'>
    readonly url: FieldRef<"SerpPosition", 'String'>
    readonly searchEngine: FieldRef<"SerpPosition", 'String'>
    readonly country: FieldRef<"SerpPosition", 'String'>
    readonly createdAt: FieldRef<"SerpPosition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SerpPosition findUnique
   */
  export type SerpPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * Filter, which SerpPosition to fetch.
     */
    where: SerpPositionWhereUniqueInput
  }

  /**
   * SerpPosition findUniqueOrThrow
   */
  export type SerpPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * Filter, which SerpPosition to fetch.
     */
    where: SerpPositionWhereUniqueInput
  }

  /**
   * SerpPosition findFirst
   */
  export type SerpPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * Filter, which SerpPosition to fetch.
     */
    where?: SerpPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SerpPositions to fetch.
     */
    orderBy?: SerpPositionOrderByWithRelationInput | SerpPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SerpPositions.
     */
    cursor?: SerpPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SerpPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SerpPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SerpPositions.
     */
    distinct?: SerpPositionScalarFieldEnum | SerpPositionScalarFieldEnum[]
  }

  /**
   * SerpPosition findFirstOrThrow
   */
  export type SerpPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * Filter, which SerpPosition to fetch.
     */
    where?: SerpPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SerpPositions to fetch.
     */
    orderBy?: SerpPositionOrderByWithRelationInput | SerpPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SerpPositions.
     */
    cursor?: SerpPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SerpPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SerpPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SerpPositions.
     */
    distinct?: SerpPositionScalarFieldEnum | SerpPositionScalarFieldEnum[]
  }

  /**
   * SerpPosition findMany
   */
  export type SerpPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * Filter, which SerpPositions to fetch.
     */
    where?: SerpPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SerpPositions to fetch.
     */
    orderBy?: SerpPositionOrderByWithRelationInput | SerpPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SerpPositions.
     */
    cursor?: SerpPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SerpPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SerpPositions.
     */
    skip?: number
    distinct?: SerpPositionScalarFieldEnum | SerpPositionScalarFieldEnum[]
  }

  /**
   * SerpPosition create
   */
  export type SerpPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a SerpPosition.
     */
    data: XOR<SerpPositionCreateInput, SerpPositionUncheckedCreateInput>
  }

  /**
   * SerpPosition createMany
   */
  export type SerpPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SerpPositions.
     */
    data: SerpPositionCreateManyInput | SerpPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SerpPosition update
   */
  export type SerpPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a SerpPosition.
     */
    data: XOR<SerpPositionUpdateInput, SerpPositionUncheckedUpdateInput>
    /**
     * Choose, which SerpPosition to update.
     */
    where: SerpPositionWhereUniqueInput
  }

  /**
   * SerpPosition updateMany
   */
  export type SerpPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SerpPositions.
     */
    data: XOR<SerpPositionUpdateManyMutationInput, SerpPositionUncheckedUpdateManyInput>
    /**
     * Filter which SerpPositions to update
     */
    where?: SerpPositionWhereInput
    /**
     * Limit how many SerpPositions to update.
     */
    limit?: number
  }

  /**
   * SerpPosition upsert
   */
  export type SerpPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the SerpPosition to update in case it exists.
     */
    where: SerpPositionWhereUniqueInput
    /**
     * In case the SerpPosition found by the `where` argument doesn't exist, create a new SerpPosition with this data.
     */
    create: XOR<SerpPositionCreateInput, SerpPositionUncheckedCreateInput>
    /**
     * In case the SerpPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SerpPositionUpdateInput, SerpPositionUncheckedUpdateInput>
  }

  /**
   * SerpPosition delete
   */
  export type SerpPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
    /**
     * Filter which SerpPosition to delete.
     */
    where: SerpPositionWhereUniqueInput
  }

  /**
   * SerpPosition deleteMany
   */
  export type SerpPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SerpPositions to delete
     */
    where?: SerpPositionWhereInput
    /**
     * Limit how many SerpPositions to delete.
     */
    limit?: number
  }

  /**
   * SerpPosition without action
   */
  export type SerpPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerpPosition
     */
    select?: SerpPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SerpPosition
     */
    omit?: SerpPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SerpPositionInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    portalId: string | null
    type: $Enums.IntegrationType | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    portalId: string | null
    type: $Enums.IntegrationType | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    portalId: number
    type: number
    config: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    portalId?: true
    type?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    portalId?: true
    type?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    portalId?: true
    type?: true
    config?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    portalId: string
    type: $Enums.IntegrationType
    config: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    portalId?: boolean
    type?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portal?: boolean | PortalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>



  export type IntegrationSelectScalar = {
    id?: boolean
    portalId?: boolean
    type?: boolean
    config?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "portalId" | "type" | "config" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portal?: boolean | PortalDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      portal: Prisma.$PortalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      portalId: string
      type: $Enums.IntegrationType
      config: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portal<T extends PortalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PortalDefaultArgs<ExtArgs>>): Prisma__PortalClient<$Result.GetResult<Prisma.$PortalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly portalId: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'IntegrationType'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    surname: 'surname',
    password: 'password',
    displayName: 'displayName',
    avatar: 'avatar',
    points: 'points',
    role: 'role',
    method: 'method',
    emailVerified: 'emailVerified',
    isEmailVerified: 'isEmailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ExternalAccountScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    expiry: 'expiry',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalAccountScalarFieldEnum = (typeof ExternalAccountScalarFieldEnum)[keyof typeof ExternalAccountScalarFieldEnum]


  export const EmailVerificationScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiry: 'expiry',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailVerificationScalarFieldEnum = (typeof EmailVerificationScalarFieldEnum)[keyof typeof EmailVerificationScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiry: 'expiry',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const MultiFactorAuthenticationScalarFieldEnum: {
    id: 'id',
    totpId: 'totpId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MultiFactorAuthenticationScalarFieldEnum = (typeof MultiFactorAuthenticationScalarFieldEnum)[keyof typeof MultiFactorAuthenticationScalarFieldEnum]


  export const TotpScalarFieldEnum: {
    id: 'id',
    status: 'status',
    secret: 'secret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TotpScalarFieldEnum = (typeof TotpScalarFieldEnum)[keyof typeof TotpScalarFieldEnum]


  export const PasskeyScalarFieldEnum: {
    id: 'id',
    deviceName: 'deviceName',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    counter: 'counter',
    lastUsedAt: 'lastUsedAt',
    ip: 'ip',
    userAgent: 'userAgent',
    mfaId: 'mfaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasskeyScalarFieldEnum = (typeof PasskeyScalarFieldEnum)[keyof typeof PasskeyScalarFieldEnum]


  export const RestrictionScalarFieldEnum: {
    id: 'id',
    reason: 'reason',
    until: 'until',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RestrictionScalarFieldEnum = (typeof RestrictionScalarFieldEnum)[keyof typeof RestrictionScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    thumbnail: 'thumbnail',
    content: 'content',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    edited: 'edited',
    deleted: 'deleted',
    authorId: 'authorId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PortalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    customDomain: 'customDomain',
    logo: 'logo',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    settings: 'settings',
    subscriptionId: 'subscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    trialEndsAt: 'trialEndsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortalScalarFieldEnum = (typeof PortalScalarFieldEnum)[keyof typeof PortalScalarFieldEnum]


  export const UserPortalRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    portalId: 'portalId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPortalRoleScalarFieldEnum = (typeof UserPortalRoleScalarFieldEnum)[keyof typeof UserPortalRoleScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    avatar: 'avatar',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    source: 'source',
    status: 'status',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedToId: 'assignedToId',
    createdById: 'createdById'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    title: 'title',
    stage: 'stage',
    value: 'value',
    currency: 'currency',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    leadId: 'leadId',
    assignedToId: 'assignedToId',
    createdById: 'createdById'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    location: 'location',
    googleCalendarEventId: 'googleCalendarEventId',
    reminderSent: 'reminderSent',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    dealId: 'dealId',
    productId: 'productId',
    assignedToId: 'assignedToId'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    name: 'name',
    description: 'description',
    category: 'category',
    price: 'price',
    currency: 'currency',
    duration: 'duration',
    portfolio: 'portfolio',
    isActive: 'isActive',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CustomFieldScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    entityType: 'entityType',
    name: 'name',
    fieldType: 'fieldType',
    config: 'config',
    isRequired: 'isRequired',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomFieldScalarFieldEnum = (typeof CustomFieldScalarFieldEnum)[keyof typeof CustomFieldScalarFieldEnum]


  export const CustomFieldValueScalarFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    entityType: 'entityType',
    entityId: 'entityId',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomFieldValueScalarFieldEnum = (typeof CustomFieldValueScalarFieldEnum)[keyof typeof CustomFieldValueScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SeoKeywordScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    keyword: 'keyword',
    language: 'language',
    volume: 'volume',
    difficulty: 'difficulty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeoKeywordScalarFieldEnum = (typeof SeoKeywordScalarFieldEnum)[keyof typeof SeoKeywordScalarFieldEnum]


  export const SeoArticleScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    language: 'language',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    keywords: 'keywords',
    faqSchema: 'faqSchema',
    ogImage: 'ogImage',
    isPublished: 'isPublished',
    aiGenerated: 'aiGenerated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeoArticleScalarFieldEnum = (typeof SeoArticleScalarFieldEnum)[keyof typeof SeoArticleScalarFieldEnum]


  export const SerpPositionScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    keywordId: 'keywordId',
    position: 'position',
    url: 'url',
    searchEngine: 'searchEngine',
    country: 'country',
    createdAt: 'createdAt'
  };

  export type SerpPositionScalarFieldEnum = (typeof SerpPositionScalarFieldEnum)[keyof typeof SerpPositionScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    type: 'type',
    config: 'config',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    surname: 'surname',
    password: 'password',
    displayName: 'displayName',
    avatar: 'avatar'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const ExternalAccountOrderByRelevanceFieldEnum: {
    id: 'id',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    userId: 'userId'
  };

  export type ExternalAccountOrderByRelevanceFieldEnum = (typeof ExternalAccountOrderByRelevanceFieldEnum)[keyof typeof ExternalAccountOrderByRelevanceFieldEnum]


  export const EmailVerificationOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId'
  };

  export type EmailVerificationOrderByRelevanceFieldEnum = (typeof EmailVerificationOrderByRelevanceFieldEnum)[keyof typeof EmailVerificationOrderByRelevanceFieldEnum]


  export const PasswordResetOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId'
  };

  export type PasswordResetOrderByRelevanceFieldEnum = (typeof PasswordResetOrderByRelevanceFieldEnum)[keyof typeof PasswordResetOrderByRelevanceFieldEnum]


  export const MultiFactorAuthenticationOrderByRelevanceFieldEnum: {
    id: 'id',
    totpId: 'totpId',
    userId: 'userId'
  };

  export type MultiFactorAuthenticationOrderByRelevanceFieldEnum = (typeof MultiFactorAuthenticationOrderByRelevanceFieldEnum)[keyof typeof MultiFactorAuthenticationOrderByRelevanceFieldEnum]


  export const TotpOrderByRelevanceFieldEnum: {
    id: 'id',
    secret: 'secret'
  };

  export type TotpOrderByRelevanceFieldEnum = (typeof TotpOrderByRelevanceFieldEnum)[keyof typeof TotpOrderByRelevanceFieldEnum]


  export const PasskeyOrderByRelevanceFieldEnum: {
    id: 'id',
    deviceName: 'deviceName',
    credentialId: 'credentialId',
    publicKey: 'publicKey',
    ip: 'ip',
    userAgent: 'userAgent',
    mfaId: 'mfaId'
  };

  export type PasskeyOrderByRelevanceFieldEnum = (typeof PasskeyOrderByRelevanceFieldEnum)[keyof typeof PasskeyOrderByRelevanceFieldEnum]


  export const RestrictionOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type RestrictionOrderByRelevanceFieldEnum = (typeof RestrictionOrderByRelevanceFieldEnum)[keyof typeof RestrictionOrderByRelevanceFieldEnum]


  export const PostOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    thumbnail: 'thumbnail',
    content: 'content'
  };

  export type PostOrderByRelevanceFieldEnum = (typeof PostOrderByRelevanceFieldEnum)[keyof typeof PostOrderByRelevanceFieldEnum]


  export const CommentOrderByRelevanceFieldEnum: {
    id: 'id',
    content: 'content',
    authorId: 'authorId',
    postId: 'postId'
  };

  export type CommentOrderByRelevanceFieldEnum = (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const PortalOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    customDomain: 'customDomain',
    logo: 'logo',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    subscriptionId: 'subscriptionId'
  };

  export type PortalOrderByRelevanceFieldEnum = (typeof PortalOrderByRelevanceFieldEnum)[keyof typeof PortalOrderByRelevanceFieldEnum]


  export const UserPortalRoleOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    portalId: 'portalId'
  };

  export type UserPortalRoleOrderByRelevanceFieldEnum = (typeof UserPortalRoleOrderByRelevanceFieldEnum)[keyof typeof UserPortalRoleOrderByRelevanceFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    avatar: 'avatar',
    notes: 'notes',
    createdById: 'createdById'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const LeadOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    notes: 'notes',
    assignedToId: 'assignedToId',
    createdById: 'createdById'
  };

  export type LeadOrderByRelevanceFieldEnum = (typeof LeadOrderByRelevanceFieldEnum)[keyof typeof LeadOrderByRelevanceFieldEnum]


  export const DealOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    title: 'title',
    stage: 'stage',
    currency: 'currency',
    notes: 'notes',
    clientId: 'clientId',
    leadId: 'leadId',
    assignedToId: 'assignedToId',
    createdById: 'createdById'
  };

  export type DealOrderByRelevanceFieldEnum = (typeof DealOrderByRelevanceFieldEnum)[keyof typeof DealOrderByRelevanceFieldEnum]


  export const AppointmentOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    title: 'title',
    description: 'description',
    location: 'location',
    googleCalendarEventId: 'googleCalendarEventId',
    clientId: 'clientId',
    dealId: 'dealId',
    productId: 'productId',
    assignedToId: 'assignedToId'
  };

  export type AppointmentOrderByRelevanceFieldEnum = (typeof AppointmentOrderByRelevanceFieldEnum)[keyof typeof AppointmentOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    name: 'name',
    description: 'description',
    category: 'category',
    currency: 'currency'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const CustomFieldOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    name: 'name'
  };

  export type CustomFieldOrderByRelevanceFieldEnum = (typeof CustomFieldOrderByRelevanceFieldEnum)[keyof typeof CustomFieldOrderByRelevanceFieldEnum]


  export const CustomFieldValueOrderByRelevanceFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    entityId: 'entityId'
  };

  export type CustomFieldValueOrderByRelevanceFieldEnum = (typeof CustomFieldValueOrderByRelevanceFieldEnum)[keyof typeof CustomFieldValueOrderByRelevanceFieldEnum]


  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  export const SeoKeywordOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    keyword: 'keyword',
    language: 'language'
  };

  export type SeoKeywordOrderByRelevanceFieldEnum = (typeof SeoKeywordOrderByRelevanceFieldEnum)[keyof typeof SeoKeywordOrderByRelevanceFieldEnum]


  export const SeoArticleOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    language: 'language',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    ogImage: 'ogImage'
  };

  export type SeoArticleOrderByRelevanceFieldEnum = (typeof SeoArticleOrderByRelevanceFieldEnum)[keyof typeof SeoArticleOrderByRelevanceFieldEnum]


  export const SerpPositionOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId',
    keywordId: 'keywordId',
    url: 'url',
    searchEngine: 'searchEngine',
    country: 'country'
  };

  export type SerpPositionOrderByRelevanceFieldEnum = (typeof SerpPositionOrderByRelevanceFieldEnum)[keyof typeof SerpPositionOrderByRelevanceFieldEnum]


  export const IntegrationOrderByRelevanceFieldEnum: {
    id: 'id',
    portalId: 'portalId'
  };

  export type IntegrationOrderByRelevanceFieldEnum = (typeof IntegrationOrderByRelevanceFieldEnum)[keyof typeof IntegrationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'AuthMethod'
   */
  export type EnumAuthMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthMethod'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccountProvider'
   */
  export type EnumAccountProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountProvider'>
    


  /**
   * Reference to a field of type 'EmailVerificationStatus'
   */
  export type EnumEmailVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailVerificationStatus'>
    


  /**
   * Reference to a field of type 'TotpStatus'
   */
  export type EnumTotpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TotpStatus'>
    


  /**
   * Reference to a field of type 'RestrictionReason'
   */
  export type EnumRestrictionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RestrictionReason'>
    


  /**
   * Reference to a field of type 'RestrictionStatus'
   */
  export type EnumRestrictionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RestrictionStatus'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'PortalRole'
   */
  export type EnumPortalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PortalRole'>
    


  /**
   * Reference to a field of type 'LeadSource'
   */
  export type EnumLeadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadSource'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'FieldType'
   */
  export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


  /**
   * Reference to a field of type 'IntegrationType'
   */
  export type EnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    surname?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    displayName?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    method?: EnumAuthMethodFilter<"User"> | $Enums.AuthMethod
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    passwordReset?: XOR<PasswordResetNullableScalarRelationFilter, PasswordResetWhereInput> | null
    externalAccounts?: ExternalAccountListRelationFilter
    comments?: CommentListRelationFilter
    mfa?: XOR<MultiFactorAuthenticationNullableScalarRelationFilter, MultiFactorAuthenticationWhereInput> | null
    restrictions?: RestrictionListRelationFilter
    emailVerification?: XOR<EmailVerificationNullableScalarRelationFilter, EmailVerificationWhereInput> | null
    portalRoles?: UserPortalRoleListRelationFilter
    createdClients?: ClientListRelationFilter
    assignedLeads?: LeadListRelationFilter
    createdLeads?: LeadListRelationFilter
    assignedDeals?: DealListRelationFilter
    createdDeals?: DealListRelationFilter
    appointments?: AppointmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    displayName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    points?: SortOrder
    role?: SortOrder
    method?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passwordReset?: PasswordResetOrderByWithRelationInput
    externalAccounts?: ExternalAccountOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    mfa?: MultiFactorAuthenticationOrderByWithRelationInput
    restrictions?: RestrictionOrderByRelationAggregateInput
    emailVerification?: EmailVerificationOrderByWithRelationInput
    portalRoles?: UserPortalRoleOrderByRelationAggregateInput
    createdClients?: ClientOrderByRelationAggregateInput
    assignedLeads?: LeadOrderByRelationAggregateInput
    createdLeads?: LeadOrderByRelationAggregateInput
    assignedDeals?: DealOrderByRelationAggregateInput
    createdDeals?: DealOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    surname?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    displayName?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    points?: IntFilter<"User"> | number
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    method?: EnumAuthMethodFilter<"User"> | $Enums.AuthMethod
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    passwordReset?: XOR<PasswordResetNullableScalarRelationFilter, PasswordResetWhereInput> | null
    externalAccounts?: ExternalAccountListRelationFilter
    comments?: CommentListRelationFilter
    mfa?: XOR<MultiFactorAuthenticationNullableScalarRelationFilter, MultiFactorAuthenticationWhereInput> | null
    restrictions?: RestrictionListRelationFilter
    emailVerification?: XOR<EmailVerificationNullableScalarRelationFilter, EmailVerificationWhereInput> | null
    portalRoles?: UserPortalRoleListRelationFilter
    createdClients?: ClientListRelationFilter
    assignedLeads?: LeadListRelationFilter
    createdLeads?: LeadListRelationFilter
    assignedDeals?: DealListRelationFilter
    createdDeals?: DealListRelationFilter
    appointments?: AppointmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    displayName?: SortOrder
    avatar?: SortOrderInput | SortOrder
    points?: SortOrder
    role?: SortOrder
    method?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    surname?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    points?: IntWithAggregatesFilter<"User"> | number
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    method?: EnumAuthMethodWithAggregatesFilter<"User"> | $Enums.AuthMethod
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ExternalAccountWhereInput = {
    AND?: ExternalAccountWhereInput | ExternalAccountWhereInput[]
    OR?: ExternalAccountWhereInput[]
    NOT?: ExternalAccountWhereInput | ExternalAccountWhereInput[]
    id?: StringFilter<"ExternalAccount"> | string
    provider?: EnumAccountProviderFilter<"ExternalAccount"> | $Enums.AccountProvider
    providerAccountId?: StringFilter<"ExternalAccount"> | string
    refreshToken?: StringNullableFilter<"ExternalAccount"> | string | null
    accessToken?: StringNullableFilter<"ExternalAccount"> | string | null
    expiry?: IntNullableFilter<"ExternalAccount"> | number | null
    userId?: StringFilter<"ExternalAccount"> | string
    createdAt?: DateTimeFilter<"ExternalAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExternalAccountOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ExternalAccountOrderByRelevanceInput
  }

  export type ExternalAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerAccountId?: string
    userId_provider?: ExternalAccountUserIdProviderCompoundUniqueInput
    AND?: ExternalAccountWhereInput | ExternalAccountWhereInput[]
    OR?: ExternalAccountWhereInput[]
    NOT?: ExternalAccountWhereInput | ExternalAccountWhereInput[]
    provider?: EnumAccountProviderFilter<"ExternalAccount"> | $Enums.AccountProvider
    refreshToken?: StringNullableFilter<"ExternalAccount"> | string | null
    accessToken?: StringNullableFilter<"ExternalAccount"> | string | null
    expiry?: IntNullableFilter<"ExternalAccount"> | number | null
    userId?: StringFilter<"ExternalAccount"> | string
    createdAt?: DateTimeFilter<"ExternalAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerAccountId" | "userId_provider">

  export type ExternalAccountOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalAccountCountOrderByAggregateInput
    _avg?: ExternalAccountAvgOrderByAggregateInput
    _max?: ExternalAccountMaxOrderByAggregateInput
    _min?: ExternalAccountMinOrderByAggregateInput
    _sum?: ExternalAccountSumOrderByAggregateInput
  }

  export type ExternalAccountScalarWhereWithAggregatesInput = {
    AND?: ExternalAccountScalarWhereWithAggregatesInput | ExternalAccountScalarWhereWithAggregatesInput[]
    OR?: ExternalAccountScalarWhereWithAggregatesInput[]
    NOT?: ExternalAccountScalarWhereWithAggregatesInput | ExternalAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalAccount"> | string
    provider?: EnumAccountProviderWithAggregatesFilter<"ExternalAccount"> | $Enums.AccountProvider
    providerAccountId?: StringWithAggregatesFilter<"ExternalAccount"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"ExternalAccount"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"ExternalAccount"> | string | null
    expiry?: IntNullableWithAggregatesFilter<"ExternalAccount"> | number | null
    userId?: StringWithAggregatesFilter<"ExternalAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExternalAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalAccount"> | Date | string
  }

  export type EmailVerificationWhereInput = {
    AND?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    OR?: EmailVerificationWhereInput[]
    NOT?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    id?: StringFilter<"EmailVerification"> | string
    token?: StringFilter<"EmailVerification"> | string
    expiry?: DateTimeNullableFilter<"EmailVerification"> | Date | string | null
    status?: EnumEmailVerificationStatusFilter<"EmailVerification"> | $Enums.EmailVerificationStatus
    userId?: StringFilter<"EmailVerification"> | string
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailVerificationOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: EmailVerificationOrderByRelevanceInput
  }

  export type EmailVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    userId?: string
    AND?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    OR?: EmailVerificationWhereInput[]
    NOT?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    expiry?: DateTimeNullableFilter<"EmailVerification"> | Date | string | null
    status?: EnumEmailVerificationStatusFilter<"EmailVerification"> | $Enums.EmailVerificationStatus
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "userId">

  export type EmailVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailVerificationCountOrderByAggregateInput
    _max?: EmailVerificationMaxOrderByAggregateInput
    _min?: EmailVerificationMinOrderByAggregateInput
  }

  export type EmailVerificationScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationScalarWhereWithAggregatesInput | EmailVerificationScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationScalarWhereWithAggregatesInput | EmailVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailVerification"> | string
    token?: StringWithAggregatesFilter<"EmailVerification"> | string
    expiry?: DateTimeNullableWithAggregatesFilter<"EmailVerification"> | Date | string | null
    status?: EnumEmailVerificationStatusWithAggregatesFilter<"EmailVerification"> | $Enums.EmailVerificationStatus
    userId?: StringWithAggregatesFilter<"EmailVerification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailVerification"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    token?: StringFilter<"PasswordReset"> | string
    expiry?: DateTimeFilter<"PasswordReset"> | Date | string
    userId?: StringFilter<"PasswordReset"> | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: PasswordResetOrderByRelevanceInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    userId?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    expiry?: DateTimeFilter<"PasswordReset"> | Date | string
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "userId">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordReset"> | string
    token?: StringWithAggregatesFilter<"PasswordReset"> | string
    expiry?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    userId?: StringWithAggregatesFilter<"PasswordReset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type MultiFactorAuthenticationWhereInput = {
    AND?: MultiFactorAuthenticationWhereInput | MultiFactorAuthenticationWhereInput[]
    OR?: MultiFactorAuthenticationWhereInput[]
    NOT?: MultiFactorAuthenticationWhereInput | MultiFactorAuthenticationWhereInput[]
    id?: StringFilter<"MultiFactorAuthentication"> | string
    totpId?: StringNullableFilter<"MultiFactorAuthentication"> | string | null
    userId?: StringFilter<"MultiFactorAuthentication"> | string
    createdAt?: DateTimeFilter<"MultiFactorAuthentication"> | Date | string
    updatedAt?: DateTimeFilter<"MultiFactorAuthentication"> | Date | string
    passkeys?: PasskeyListRelationFilter
    totp?: XOR<TotpNullableScalarRelationFilter, TotpWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MultiFactorAuthenticationOrderByWithRelationInput = {
    id?: SortOrder
    totpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    passkeys?: PasskeyOrderByRelationAggregateInput
    totp?: TotpOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: MultiFactorAuthenticationOrderByRelevanceInput
  }

  export type MultiFactorAuthenticationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    totpId?: string
    userId?: string
    AND?: MultiFactorAuthenticationWhereInput | MultiFactorAuthenticationWhereInput[]
    OR?: MultiFactorAuthenticationWhereInput[]
    NOT?: MultiFactorAuthenticationWhereInput | MultiFactorAuthenticationWhereInput[]
    createdAt?: DateTimeFilter<"MultiFactorAuthentication"> | Date | string
    updatedAt?: DateTimeFilter<"MultiFactorAuthentication"> | Date | string
    passkeys?: PasskeyListRelationFilter
    totp?: XOR<TotpNullableScalarRelationFilter, TotpWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "totpId" | "userId">

  export type MultiFactorAuthenticationOrderByWithAggregationInput = {
    id?: SortOrder
    totpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MultiFactorAuthenticationCountOrderByAggregateInput
    _max?: MultiFactorAuthenticationMaxOrderByAggregateInput
    _min?: MultiFactorAuthenticationMinOrderByAggregateInput
  }

  export type MultiFactorAuthenticationScalarWhereWithAggregatesInput = {
    AND?: MultiFactorAuthenticationScalarWhereWithAggregatesInput | MultiFactorAuthenticationScalarWhereWithAggregatesInput[]
    OR?: MultiFactorAuthenticationScalarWhereWithAggregatesInput[]
    NOT?: MultiFactorAuthenticationScalarWhereWithAggregatesInput | MultiFactorAuthenticationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultiFactorAuthentication"> | string
    totpId?: StringNullableWithAggregatesFilter<"MultiFactorAuthentication"> | string | null
    userId?: StringWithAggregatesFilter<"MultiFactorAuthentication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MultiFactorAuthentication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MultiFactorAuthentication"> | Date | string
  }

  export type TotpWhereInput = {
    AND?: TotpWhereInput | TotpWhereInput[]
    OR?: TotpWhereInput[]
    NOT?: TotpWhereInput | TotpWhereInput[]
    id?: StringFilter<"Totp"> | string
    status?: EnumTotpStatusFilter<"Totp"> | $Enums.TotpStatus
    secret?: StringNullableFilter<"Totp"> | string | null
    createdAt?: DateTimeFilter<"Totp"> | Date | string
    updatedAt?: DateTimeFilter<"Totp"> | Date | string
    mfa?: XOR<MultiFactorAuthenticationNullableScalarRelationFilter, MultiFactorAuthenticationWhereInput> | null
  }

  export type TotpOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    secret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mfa?: MultiFactorAuthenticationOrderByWithRelationInput
    _relevance?: TotpOrderByRelevanceInput
  }

  export type TotpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TotpWhereInput | TotpWhereInput[]
    OR?: TotpWhereInput[]
    NOT?: TotpWhereInput | TotpWhereInput[]
    status?: EnumTotpStatusFilter<"Totp"> | $Enums.TotpStatus
    secret?: StringNullableFilter<"Totp"> | string | null
    createdAt?: DateTimeFilter<"Totp"> | Date | string
    updatedAt?: DateTimeFilter<"Totp"> | Date | string
    mfa?: XOR<MultiFactorAuthenticationNullableScalarRelationFilter, MultiFactorAuthenticationWhereInput> | null
  }, "id">

  export type TotpOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    secret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TotpCountOrderByAggregateInput
    _max?: TotpMaxOrderByAggregateInput
    _min?: TotpMinOrderByAggregateInput
  }

  export type TotpScalarWhereWithAggregatesInput = {
    AND?: TotpScalarWhereWithAggregatesInput | TotpScalarWhereWithAggregatesInput[]
    OR?: TotpScalarWhereWithAggregatesInput[]
    NOT?: TotpScalarWhereWithAggregatesInput | TotpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Totp"> | string
    status?: EnumTotpStatusWithAggregatesFilter<"Totp"> | $Enums.TotpStatus
    secret?: StringNullableWithAggregatesFilter<"Totp"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Totp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Totp"> | Date | string
  }

  export type PasskeyWhereInput = {
    AND?: PasskeyWhereInput | PasskeyWhereInput[]
    OR?: PasskeyWhereInput[]
    NOT?: PasskeyWhereInput | PasskeyWhereInput[]
    id?: StringFilter<"Passkey"> | string
    deviceName?: StringFilter<"Passkey"> | string
    credentialId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    lastUsedAt?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    ip?: StringFilter<"Passkey"> | string
    userAgent?: StringFilter<"Passkey"> | string
    mfaId?: StringFilter<"Passkey"> | string
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    updatedAt?: DateTimeFilter<"Passkey"> | Date | string
    mfa?: XOR<MultiFactorAuthenticationScalarRelationFilter, MultiFactorAuthenticationWhereInput>
  }

  export type PasskeyOrderByWithRelationInput = {
    id?: SortOrder
    deviceName?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    mfaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mfa?: MultiFactorAuthenticationOrderByWithRelationInput
    _relevance?: PasskeyOrderByRelevanceInput
  }

  export type PasskeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    credentialId?: string
    AND?: PasskeyWhereInput | PasskeyWhereInput[]
    OR?: PasskeyWhereInput[]
    NOT?: PasskeyWhereInput | PasskeyWhereInput[]
    deviceName?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    lastUsedAt?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    ip?: StringFilter<"Passkey"> | string
    userAgent?: StringFilter<"Passkey"> | string
    mfaId?: StringFilter<"Passkey"> | string
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    updatedAt?: DateTimeFilter<"Passkey"> | Date | string
    mfa?: XOR<MultiFactorAuthenticationScalarRelationFilter, MultiFactorAuthenticationWhereInput>
  }, "id" | "credentialId">

  export type PasskeyOrderByWithAggregationInput = {
    id?: SortOrder
    deviceName?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    mfaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasskeyCountOrderByAggregateInput
    _avg?: PasskeyAvgOrderByAggregateInput
    _max?: PasskeyMaxOrderByAggregateInput
    _min?: PasskeyMinOrderByAggregateInput
    _sum?: PasskeySumOrderByAggregateInput
  }

  export type PasskeyScalarWhereWithAggregatesInput = {
    AND?: PasskeyScalarWhereWithAggregatesInput | PasskeyScalarWhereWithAggregatesInput[]
    OR?: PasskeyScalarWhereWithAggregatesInput[]
    NOT?: PasskeyScalarWhereWithAggregatesInput | PasskeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Passkey"> | string
    deviceName?: StringWithAggregatesFilter<"Passkey"> | string
    credentialId?: StringWithAggregatesFilter<"Passkey"> | string
    publicKey?: StringWithAggregatesFilter<"Passkey"> | string
    counter?: IntWithAggregatesFilter<"Passkey"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"Passkey"> | Date | string | null
    ip?: StringWithAggregatesFilter<"Passkey"> | string
    userAgent?: StringWithAggregatesFilter<"Passkey"> | string
    mfaId?: StringWithAggregatesFilter<"Passkey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Passkey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Passkey"> | Date | string
  }

  export type RestrictionWhereInput = {
    AND?: RestrictionWhereInput | RestrictionWhereInput[]
    OR?: RestrictionWhereInput[]
    NOT?: RestrictionWhereInput | RestrictionWhereInput[]
    id?: StringFilter<"Restriction"> | string
    reason?: EnumRestrictionReasonFilter<"Restriction"> | $Enums.RestrictionReason
    until?: DateTimeNullableFilter<"Restriction"> | Date | string | null
    status?: EnumRestrictionStatusFilter<"Restriction"> | $Enums.RestrictionStatus
    userId?: StringFilter<"Restriction"> | string
    createdAt?: DateTimeFilter<"Restriction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RestrictionOrderByWithRelationInput = {
    id?: SortOrder
    reason?: SortOrder
    until?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: RestrictionOrderByRelevanceInput
  }

  export type RestrictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RestrictionWhereInput | RestrictionWhereInput[]
    OR?: RestrictionWhereInput[]
    NOT?: RestrictionWhereInput | RestrictionWhereInput[]
    reason?: EnumRestrictionReasonFilter<"Restriction"> | $Enums.RestrictionReason
    until?: DateTimeNullableFilter<"Restriction"> | Date | string | null
    status?: EnumRestrictionStatusFilter<"Restriction"> | $Enums.RestrictionStatus
    userId?: StringFilter<"Restriction"> | string
    createdAt?: DateTimeFilter<"Restriction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RestrictionOrderByWithAggregationInput = {
    id?: SortOrder
    reason?: SortOrder
    until?: SortOrderInput | SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RestrictionCountOrderByAggregateInput
    _max?: RestrictionMaxOrderByAggregateInput
    _min?: RestrictionMinOrderByAggregateInput
  }

  export type RestrictionScalarWhereWithAggregatesInput = {
    AND?: RestrictionScalarWhereWithAggregatesInput | RestrictionScalarWhereWithAggregatesInput[]
    OR?: RestrictionScalarWhereWithAggregatesInput[]
    NOT?: RestrictionScalarWhereWithAggregatesInput | RestrictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Restriction"> | string
    reason?: EnumRestrictionReasonWithAggregatesFilter<"Restriction"> | $Enums.RestrictionReason
    until?: DateTimeNullableWithAggregatesFilter<"Restriction"> | Date | string | null
    status?: EnumRestrictionStatusWithAggregatesFilter<"Restriction"> | $Enums.RestrictionStatus
    userId?: StringWithAggregatesFilter<"Restriction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Restriction"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    thumbnail?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    isPublished?: BoolFilter<"Post"> | boolean
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    comments?: CommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    _relevance?: PostOrderByRelevanceInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    title?: StringFilter<"Post"> | string
    thumbnail?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    isPublished?: BoolFilter<"Post"> | boolean
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    comments?: CommentListRelationFilter
  }, "id" | "slug">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    slug?: StringWithAggregatesFilter<"Post"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: StringWithAggregatesFilter<"Post"> | string
    isPublished?: BoolWithAggregatesFilter<"Post"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    edited?: BoolFilter<"Comment"> | boolean
    deleted?: BoolFilter<"Comment"> | boolean
    authorId?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    _relevance?: CommentOrderByRelevanceInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    edited?: BoolFilter<"Comment"> | boolean
    deleted?: BoolFilter<"Comment"> | boolean
    authorId?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    edited?: BoolWithAggregatesFilter<"Comment"> | boolean
    deleted?: BoolWithAggregatesFilter<"Comment"> | boolean
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type PortalWhereInput = {
    AND?: PortalWhereInput | PortalWhereInput[]
    OR?: PortalWhereInput[]
    NOT?: PortalWhereInput | PortalWhereInput[]
    id?: StringFilter<"Portal"> | string
    name?: StringFilter<"Portal"> | string
    subdomain?: StringNullableFilter<"Portal"> | string | null
    customDomain?: StringNullableFilter<"Portal"> | string | null
    logo?: StringNullableFilter<"Portal"> | string | null
    primaryColor?: StringNullableFilter<"Portal"> | string | null
    secondaryColor?: StringNullableFilter<"Portal"> | string | null
    settings?: JsonNullableFilter<"Portal">
    subscriptionId?: StringNullableFilter<"Portal"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusFilter<"Portal"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableFilter<"Portal"> | Date | string | null
    createdAt?: DateTimeFilter<"Portal"> | Date | string
    updatedAt?: DateTimeFilter<"Portal"> | Date | string
    userRoles?: UserPortalRoleListRelationFilter
    clients?: ClientListRelationFilter
    leads?: LeadListRelationFilter
    deals?: DealListRelationFilter
    appointments?: AppointmentListRelationFilter
    products?: ProductListRelationFilter
    customFields?: CustomFieldListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    seoKeywords?: SeoKeywordListRelationFilter
    seoArticles?: SeoArticleListRelationFilter
    serpPositions?: SerpPositionListRelationFilter
    integrations?: IntegrationListRelationFilter
  }

  export type PortalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserPortalRoleOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    customFields?: CustomFieldOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    seoKeywords?: SeoKeywordOrderByRelationAggregateInput
    seoArticles?: SeoArticleOrderByRelationAggregateInput
    serpPositions?: SerpPositionOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    _relevance?: PortalOrderByRelevanceInput
  }

  export type PortalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    customDomain?: string
    subscriptionId?: string
    AND?: PortalWhereInput | PortalWhereInput[]
    OR?: PortalWhereInput[]
    NOT?: PortalWhereInput | PortalWhereInput[]
    name?: StringFilter<"Portal"> | string
    logo?: StringNullableFilter<"Portal"> | string | null
    primaryColor?: StringNullableFilter<"Portal"> | string | null
    secondaryColor?: StringNullableFilter<"Portal"> | string | null
    settings?: JsonNullableFilter<"Portal">
    subscriptionStatus?: EnumSubscriptionStatusFilter<"Portal"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableFilter<"Portal"> | Date | string | null
    createdAt?: DateTimeFilter<"Portal"> | Date | string
    updatedAt?: DateTimeFilter<"Portal"> | Date | string
    userRoles?: UserPortalRoleListRelationFilter
    clients?: ClientListRelationFilter
    leads?: LeadListRelationFilter
    deals?: DealListRelationFilter
    appointments?: AppointmentListRelationFilter
    products?: ProductListRelationFilter
    customFields?: CustomFieldListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    seoKeywords?: SeoKeywordListRelationFilter
    seoArticles?: SeoArticleListRelationFilter
    serpPositions?: SerpPositionListRelationFilter
    integrations?: IntegrationListRelationFilter
  }, "id" | "subdomain" | "customDomain" | "subscriptionId">

  export type PortalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrderInput | SortOrder
    customDomain?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortalCountOrderByAggregateInput
    _max?: PortalMaxOrderByAggregateInput
    _min?: PortalMinOrderByAggregateInput
  }

  export type PortalScalarWhereWithAggregatesInput = {
    AND?: PortalScalarWhereWithAggregatesInput | PortalScalarWhereWithAggregatesInput[]
    OR?: PortalScalarWhereWithAggregatesInput[]
    NOT?: PortalScalarWhereWithAggregatesInput | PortalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Portal"> | string
    name?: StringWithAggregatesFilter<"Portal"> | string
    subdomain?: StringNullableWithAggregatesFilter<"Portal"> | string | null
    customDomain?: StringNullableWithAggregatesFilter<"Portal"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Portal"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"Portal"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"Portal"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"Portal">
    subscriptionId?: StringNullableWithAggregatesFilter<"Portal"> | string | null
    subscriptionStatus?: EnumSubscriptionStatusWithAggregatesFilter<"Portal"> | $Enums.SubscriptionStatus
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"Portal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Portal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Portal"> | Date | string
  }

  export type UserPortalRoleWhereInput = {
    AND?: UserPortalRoleWhereInput | UserPortalRoleWhereInput[]
    OR?: UserPortalRoleWhereInput[]
    NOT?: UserPortalRoleWhereInput | UserPortalRoleWhereInput[]
    id?: StringFilter<"UserPortalRole"> | string
    userId?: StringFilter<"UserPortalRole"> | string
    portalId?: StringFilter<"UserPortalRole"> | string
    role?: EnumPortalRoleFilter<"UserPortalRole"> | $Enums.PortalRole
    createdAt?: DateTimeFilter<"UserPortalRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserPortalRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
  }

  export type UserPortalRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    portalId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    portal?: PortalOrderByWithRelationInput
    _relevance?: UserPortalRoleOrderByRelevanceInput
  }

  export type UserPortalRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_portalId?: UserPortalRoleUserIdPortalIdCompoundUniqueInput
    AND?: UserPortalRoleWhereInput | UserPortalRoleWhereInput[]
    OR?: UserPortalRoleWhereInput[]
    NOT?: UserPortalRoleWhereInput | UserPortalRoleWhereInput[]
    userId?: StringFilter<"UserPortalRole"> | string
    portalId?: StringFilter<"UserPortalRole"> | string
    role?: EnumPortalRoleFilter<"UserPortalRole"> | $Enums.PortalRole
    createdAt?: DateTimeFilter<"UserPortalRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserPortalRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
  }, "id" | "userId_portalId">

  export type UserPortalRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    portalId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPortalRoleCountOrderByAggregateInput
    _max?: UserPortalRoleMaxOrderByAggregateInput
    _min?: UserPortalRoleMinOrderByAggregateInput
  }

  export type UserPortalRoleScalarWhereWithAggregatesInput = {
    AND?: UserPortalRoleScalarWhereWithAggregatesInput | UserPortalRoleScalarWhereWithAggregatesInput[]
    OR?: UserPortalRoleScalarWhereWithAggregatesInput[]
    NOT?: UserPortalRoleScalarWhereWithAggregatesInput | UserPortalRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPortalRole"> | string
    userId?: StringWithAggregatesFilter<"UserPortalRole"> | string
    portalId?: StringWithAggregatesFilter<"UserPortalRole"> | string
    role?: EnumPortalRoleWithAggregatesFilter<"UserPortalRole"> | $Enums.PortalRole
    createdAt?: DateTimeWithAggregatesFilter<"UserPortalRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPortalRole"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    portalId?: StringFilter<"Client"> | string
    firstName?: StringNullableFilter<"Client"> | string | null
    lastName?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    avatar?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    metadata?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    createdById?: StringNullableFilter<"Client"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deals?: DealListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    portal?: PortalOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    deals?: DealOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    portalId?: StringFilter<"Client"> | string
    firstName?: StringNullableFilter<"Client"> | string | null
    lastName?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    avatar?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    metadata?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    createdById?: StringNullableFilter<"Client"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deals?: DealListRelationFilter
    appointments?: AppointmentListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    portalId?: StringWithAggregatesFilter<"Client"> | string
    firstName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Client"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Client">
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Client"> | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    portalId?: StringFilter<"Lead"> | string
    source?: EnumLeadSourceFilter<"Lead"> | $Enums.LeadSource
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    firstName?: StringNullableFilter<"Lead"> | string | null
    lastName?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    metadata?: JsonNullableFilter<"Lead">
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    assignedToId?: StringNullableFilter<"Lead"> | string | null
    createdById?: StringNullableFilter<"Lead"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deals?: DealListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    portal?: PortalOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    deals?: DealOrderByRelationAggregateInput
    _relevance?: LeadOrderByRelevanceInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    portalId?: StringFilter<"Lead"> | string
    source?: EnumLeadSourceFilter<"Lead"> | $Enums.LeadSource
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    firstName?: StringNullableFilter<"Lead"> | string | null
    lastName?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    metadata?: JsonNullableFilter<"Lead">
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    assignedToId?: StringNullableFilter<"Lead"> | string | null
    createdById?: StringNullableFilter<"Lead"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deals?: DealListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    portalId?: StringWithAggregatesFilter<"Lead"> | string
    source?: EnumLeadSourceWithAggregatesFilter<"Lead"> | $Enums.LeadSource
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    firstName?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Lead">
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    assignedToId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Lead"> | string | null
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    portalId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    stage?: StringFilter<"Deal"> | string
    value?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Deal"> | string
    probability?: IntNullableFilter<"Deal"> | number | null
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    notes?: StringNullableFilter<"Deal"> | string | null
    metadata?: JsonNullableFilter<"Deal">
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    clientId?: StringNullableFilter<"Deal"> | string | null
    leadId?: StringNullableFilter<"Deal"> | string | null
    assignedToId?: StringNullableFilter<"Deal"> | string | null
    createdById?: StringNullableFilter<"Deal"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    appointments?: AppointmentListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    stage?: SortOrder
    value?: SortOrderInput | SortOrder
    currency?: SortOrder
    probability?: SortOrderInput | SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    portal?: PortalOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    _relevance?: DealOrderByRelevanceInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    portalId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    stage?: StringFilter<"Deal"> | string
    value?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Deal"> | string
    probability?: IntNullableFilter<"Deal"> | number | null
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    notes?: StringNullableFilter<"Deal"> | string | null
    metadata?: JsonNullableFilter<"Deal">
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    clientId?: StringNullableFilter<"Deal"> | string | null
    leadId?: StringNullableFilter<"Deal"> | string | null
    assignedToId?: StringNullableFilter<"Deal"> | string | null
    createdById?: StringNullableFilter<"Deal"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    appointments?: AppointmentListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    stage?: SortOrder
    value?: SortOrderInput | SortOrder
    currency?: SortOrder
    probability?: SortOrderInput | SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    portalId?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    stage?: StringWithAggregatesFilter<"Deal"> | string
    value?: DecimalNullableWithAggregatesFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Deal"> | string
    probability?: IntNullableWithAggregatesFilter<"Deal"> | number | null
    expectedCloseDate?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Deal">
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    clientId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    assignedToId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    createdById?: StringNullableWithAggregatesFilter<"Deal"> | string | null
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    portalId?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableFilter<"Appointment"> | string | null
    googleCalendarEventId?: StringNullableFilter<"Appointment"> | string | null
    reminderSent?: BoolFilter<"Appointment"> | boolean
    metadata?: JsonNullableFilter<"Appointment">
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    clientId?: StringNullableFilter<"Appointment"> | string | null
    dealId?: StringNullableFilter<"Appointment"> | string | null
    productId?: StringNullableFilter<"Appointment"> | string | null
    assignedToId?: StringNullableFilter<"Appointment"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    googleCalendarEventId?: SortOrderInput | SortOrder
    reminderSent?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    portal?: PortalOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    _relevance?: AppointmentOrderByRelevanceInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    portalId?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableFilter<"Appointment"> | string | null
    googleCalendarEventId?: StringNullableFilter<"Appointment"> | string | null
    reminderSent?: BoolFilter<"Appointment"> | boolean
    metadata?: JsonNullableFilter<"Appointment">
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    clientId?: StringNullableFilter<"Appointment"> | string | null
    dealId?: StringNullableFilter<"Appointment"> | string | null
    productId?: StringNullableFilter<"Appointment"> | string | null
    assignedToId?: StringNullableFilter<"Appointment"> | string | null
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    googleCalendarEventId?: SortOrderInput | SortOrder
    reminderSent?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    portalId?: StringWithAggregatesFilter<"Appointment"> | string
    title?: StringWithAggregatesFilter<"Appointment"> | string
    description?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    googleCalendarEventId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    reminderSent?: BoolWithAggregatesFilter<"Appointment"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Appointment">
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    clientId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    productId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    assignedToId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    portalId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Product"> | string
    duration?: IntNullableFilter<"Product"> | number | null
    portfolio?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    metadata?: JsonNullableFilter<"Product">
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    appointments?: AppointmentListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    portalId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Product"> | string
    duration?: IntNullableFilter<"Product"> | number | null
    portfolio?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    metadata?: JsonNullableFilter<"Product">
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    appointments?: AppointmentListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    isActive?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    portalId?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Product"> | string
    duration?: IntNullableWithAggregatesFilter<"Product"> | number | null
    portfolio?: JsonNullableWithAggregatesFilter<"Product">
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Product">
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type CustomFieldWhereInput = {
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    id?: StringFilter<"CustomField"> | string
    portalId?: StringFilter<"CustomField"> | string
    entityType?: EnumEntityTypeFilter<"CustomField"> | $Enums.EntityType
    name?: StringFilter<"CustomField"> | string
    fieldType?: EnumFieldTypeFilter<"CustomField"> | $Enums.FieldType
    config?: JsonNullableFilter<"CustomField">
    isRequired?: BoolFilter<"CustomField"> | boolean
    order?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomField"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    values?: CustomFieldValueListRelationFilter
  }

  export type CustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    entityType?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    config?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    values?: CustomFieldValueOrderByRelationAggregateInput
    _relevance?: CustomFieldOrderByRelevanceInput
  }

  export type CustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    portalId?: StringFilter<"CustomField"> | string
    entityType?: EnumEntityTypeFilter<"CustomField"> | $Enums.EntityType
    name?: StringFilter<"CustomField"> | string
    fieldType?: EnumFieldTypeFilter<"CustomField"> | $Enums.FieldType
    config?: JsonNullableFilter<"CustomField">
    isRequired?: BoolFilter<"CustomField"> | boolean
    order?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomField"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    values?: CustomFieldValueListRelationFilter
  }, "id">

  export type CustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    entityType?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    config?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomFieldCountOrderByAggregateInput
    _avg?: CustomFieldAvgOrderByAggregateInput
    _max?: CustomFieldMaxOrderByAggregateInput
    _min?: CustomFieldMinOrderByAggregateInput
    _sum?: CustomFieldSumOrderByAggregateInput
  }

  export type CustomFieldScalarWhereWithAggregatesInput = {
    AND?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    OR?: CustomFieldScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomField"> | string
    portalId?: StringWithAggregatesFilter<"CustomField"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"CustomField"> | $Enums.EntityType
    name?: StringWithAggregatesFilter<"CustomField"> | string
    fieldType?: EnumFieldTypeWithAggregatesFilter<"CustomField"> | $Enums.FieldType
    config?: JsonNullableWithAggregatesFilter<"CustomField">
    isRequired?: BoolWithAggregatesFilter<"CustomField"> | boolean
    order?: IntWithAggregatesFilter<"CustomField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomField"> | Date | string
  }

  export type CustomFieldValueWhereInput = {
    AND?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    OR?: CustomFieldValueWhereInput[]
    NOT?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    id?: StringFilter<"CustomFieldValue"> | string
    fieldId?: StringFilter<"CustomFieldValue"> | string
    entityType?: EnumEntityTypeFilter<"CustomFieldValue"> | $Enums.EntityType
    entityId?: StringFilter<"CustomFieldValue"> | string
    value?: JsonNullableFilter<"CustomFieldValue">
    createdAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    updatedAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    field?: XOR<CustomFieldScalarRelationFilter, CustomFieldWhereInput>
  }

  export type CustomFieldValueOrderByWithRelationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    field?: CustomFieldOrderByWithRelationInput
    _relevance?: CustomFieldValueOrderByRelevanceInput
  }

  export type CustomFieldValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fieldId_entityType_entityId?: CustomFieldValueFieldIdEntityTypeEntityIdCompoundUniqueInput
    AND?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    OR?: CustomFieldValueWhereInput[]
    NOT?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    fieldId?: StringFilter<"CustomFieldValue"> | string
    entityType?: EnumEntityTypeFilter<"CustomFieldValue"> | $Enums.EntityType
    entityId?: StringFilter<"CustomFieldValue"> | string
    value?: JsonNullableFilter<"CustomFieldValue">
    createdAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    updatedAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    field?: XOR<CustomFieldScalarRelationFilter, CustomFieldWhereInput>
  }, "id" | "fieldId_entityType_entityId">

  export type CustomFieldValueOrderByWithAggregationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomFieldValueCountOrderByAggregateInput
    _max?: CustomFieldValueMaxOrderByAggregateInput
    _min?: CustomFieldValueMinOrderByAggregateInput
  }

  export type CustomFieldValueScalarWhereWithAggregatesInput = {
    AND?: CustomFieldValueScalarWhereWithAggregatesInput | CustomFieldValueScalarWhereWithAggregatesInput[]
    OR?: CustomFieldValueScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldValueScalarWhereWithAggregatesInput | CustomFieldValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    fieldId?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"CustomFieldValue"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    value?: JsonNullableWithAggregatesFilter<"CustomFieldValue">
    createdAt?: DateTimeWithAggregatesFilter<"CustomFieldValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomFieldValue"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    portalId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    portal?: XOR<PortalNullableScalarRelationFilter, PortalWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    portalId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    portal?: XOR<PortalNullableScalarRelationFilter, PortalWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    portalId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SeoKeywordWhereInput = {
    AND?: SeoKeywordWhereInput | SeoKeywordWhereInput[]
    OR?: SeoKeywordWhereInput[]
    NOT?: SeoKeywordWhereInput | SeoKeywordWhereInput[]
    id?: StringFilter<"SeoKeyword"> | string
    portalId?: StringFilter<"SeoKeyword"> | string
    keyword?: StringFilter<"SeoKeyword"> | string
    language?: StringFilter<"SeoKeyword"> | string
    volume?: IntNullableFilter<"SeoKeyword"> | number | null
    difficulty?: IntNullableFilter<"SeoKeyword"> | number | null
    createdAt?: DateTimeFilter<"SeoKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SeoKeyword"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    serpPositions?: SerpPositionListRelationFilter
  }

  export type SeoKeywordOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    keyword?: SortOrder
    language?: SortOrder
    volume?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    serpPositions?: SerpPositionOrderByRelationAggregateInput
    _relevance?: SeoKeywordOrderByRelevanceInput
  }

  export type SeoKeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    portalId_keyword_language?: SeoKeywordPortalIdKeywordLanguageCompoundUniqueInput
    AND?: SeoKeywordWhereInput | SeoKeywordWhereInput[]
    OR?: SeoKeywordWhereInput[]
    NOT?: SeoKeywordWhereInput | SeoKeywordWhereInput[]
    portalId?: StringFilter<"SeoKeyword"> | string
    keyword?: StringFilter<"SeoKeyword"> | string
    language?: StringFilter<"SeoKeyword"> | string
    volume?: IntNullableFilter<"SeoKeyword"> | number | null
    difficulty?: IntNullableFilter<"SeoKeyword"> | number | null
    createdAt?: DateTimeFilter<"SeoKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SeoKeyword"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    serpPositions?: SerpPositionListRelationFilter
  }, "id" | "portalId_keyword_language">

  export type SeoKeywordOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    keyword?: SortOrder
    language?: SortOrder
    volume?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeoKeywordCountOrderByAggregateInput
    _avg?: SeoKeywordAvgOrderByAggregateInput
    _max?: SeoKeywordMaxOrderByAggregateInput
    _min?: SeoKeywordMinOrderByAggregateInput
    _sum?: SeoKeywordSumOrderByAggregateInput
  }

  export type SeoKeywordScalarWhereWithAggregatesInput = {
    AND?: SeoKeywordScalarWhereWithAggregatesInput | SeoKeywordScalarWhereWithAggregatesInput[]
    OR?: SeoKeywordScalarWhereWithAggregatesInput[]
    NOT?: SeoKeywordScalarWhereWithAggregatesInput | SeoKeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeoKeyword"> | string
    portalId?: StringWithAggregatesFilter<"SeoKeyword"> | string
    keyword?: StringWithAggregatesFilter<"SeoKeyword"> | string
    language?: StringWithAggregatesFilter<"SeoKeyword"> | string
    volume?: IntNullableWithAggregatesFilter<"SeoKeyword"> | number | null
    difficulty?: IntNullableWithAggregatesFilter<"SeoKeyword"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SeoKeyword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeoKeyword"> | Date | string
  }

  export type SeoArticleWhereInput = {
    AND?: SeoArticleWhereInput | SeoArticleWhereInput[]
    OR?: SeoArticleWhereInput[]
    NOT?: SeoArticleWhereInput | SeoArticleWhereInput[]
    id?: StringFilter<"SeoArticle"> | string
    portalId?: StringFilter<"SeoArticle"> | string
    title?: StringFilter<"SeoArticle"> | string
    slug?: StringFilter<"SeoArticle"> | string
    content?: StringFilter<"SeoArticle"> | string
    excerpt?: StringNullableFilter<"SeoArticle"> | string | null
    language?: StringFilter<"SeoArticle"> | string
    metaTitle?: StringNullableFilter<"SeoArticle"> | string | null
    metaDescription?: StringNullableFilter<"SeoArticle"> | string | null
    keywords?: JsonNullableFilter<"SeoArticle">
    faqSchema?: JsonNullableFilter<"SeoArticle">
    ogImage?: StringNullableFilter<"SeoArticle"> | string | null
    isPublished?: BoolFilter<"SeoArticle"> | boolean
    aiGenerated?: BoolFilter<"SeoArticle"> | boolean
    createdAt?: DateTimeFilter<"SeoArticle"> | Date | string
    updatedAt?: DateTimeFilter<"SeoArticle"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
  }

  export type SeoArticleOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    language?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    faqSchema?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    _relevance?: SeoArticleOrderByRelevanceInput
  }

  export type SeoArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    portalId_slug_language?: SeoArticlePortalIdSlugLanguageCompoundUniqueInput
    AND?: SeoArticleWhereInput | SeoArticleWhereInput[]
    OR?: SeoArticleWhereInput[]
    NOT?: SeoArticleWhereInput | SeoArticleWhereInput[]
    portalId?: StringFilter<"SeoArticle"> | string
    title?: StringFilter<"SeoArticle"> | string
    slug?: StringFilter<"SeoArticle"> | string
    content?: StringFilter<"SeoArticle"> | string
    excerpt?: StringNullableFilter<"SeoArticle"> | string | null
    language?: StringFilter<"SeoArticle"> | string
    metaTitle?: StringNullableFilter<"SeoArticle"> | string | null
    metaDescription?: StringNullableFilter<"SeoArticle"> | string | null
    keywords?: JsonNullableFilter<"SeoArticle">
    faqSchema?: JsonNullableFilter<"SeoArticle">
    ogImage?: StringNullableFilter<"SeoArticle"> | string | null
    isPublished?: BoolFilter<"SeoArticle"> | boolean
    aiGenerated?: BoolFilter<"SeoArticle"> | boolean
    createdAt?: DateTimeFilter<"SeoArticle"> | Date | string
    updatedAt?: DateTimeFilter<"SeoArticle"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
  }, "id" | "portalId_slug_language">

  export type SeoArticleOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    language?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    faqSchema?: SortOrderInput | SortOrder
    ogImage?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeoArticleCountOrderByAggregateInput
    _max?: SeoArticleMaxOrderByAggregateInput
    _min?: SeoArticleMinOrderByAggregateInput
  }

  export type SeoArticleScalarWhereWithAggregatesInput = {
    AND?: SeoArticleScalarWhereWithAggregatesInput | SeoArticleScalarWhereWithAggregatesInput[]
    OR?: SeoArticleScalarWhereWithAggregatesInput[]
    NOT?: SeoArticleScalarWhereWithAggregatesInput | SeoArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeoArticle"> | string
    portalId?: StringWithAggregatesFilter<"SeoArticle"> | string
    title?: StringWithAggregatesFilter<"SeoArticle"> | string
    slug?: StringWithAggregatesFilter<"SeoArticle"> | string
    content?: StringWithAggregatesFilter<"SeoArticle"> | string
    excerpt?: StringNullableWithAggregatesFilter<"SeoArticle"> | string | null
    language?: StringWithAggregatesFilter<"SeoArticle"> | string
    metaTitle?: StringNullableWithAggregatesFilter<"SeoArticle"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"SeoArticle"> | string | null
    keywords?: JsonNullableWithAggregatesFilter<"SeoArticle">
    faqSchema?: JsonNullableWithAggregatesFilter<"SeoArticle">
    ogImage?: StringNullableWithAggregatesFilter<"SeoArticle"> | string | null
    isPublished?: BoolWithAggregatesFilter<"SeoArticle"> | boolean
    aiGenerated?: BoolWithAggregatesFilter<"SeoArticle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SeoArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeoArticle"> | Date | string
  }

  export type SerpPositionWhereInput = {
    AND?: SerpPositionWhereInput | SerpPositionWhereInput[]
    OR?: SerpPositionWhereInput[]
    NOT?: SerpPositionWhereInput | SerpPositionWhereInput[]
    id?: StringFilter<"SerpPosition"> | string
    portalId?: StringFilter<"SerpPosition"> | string
    keywordId?: StringFilter<"SerpPosition"> | string
    position?: IntNullableFilter<"SerpPosition"> | number | null
    url?: StringNullableFilter<"SerpPosition"> | string | null
    searchEngine?: StringFilter<"SerpPosition"> | string
    country?: StringNullableFilter<"SerpPosition"> | string | null
    createdAt?: DateTimeFilter<"SerpPosition"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    keyword?: XOR<SeoKeywordScalarRelationFilter, SeoKeywordWhereInput>
  }

  export type SerpPositionOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    keywordId?: SortOrder
    position?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    searchEngine?: SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    keyword?: SeoKeywordOrderByWithRelationInput
    _relevance?: SerpPositionOrderByRelevanceInput
  }

  export type SerpPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SerpPositionWhereInput | SerpPositionWhereInput[]
    OR?: SerpPositionWhereInput[]
    NOT?: SerpPositionWhereInput | SerpPositionWhereInput[]
    portalId?: StringFilter<"SerpPosition"> | string
    keywordId?: StringFilter<"SerpPosition"> | string
    position?: IntNullableFilter<"SerpPosition"> | number | null
    url?: StringNullableFilter<"SerpPosition"> | string | null
    searchEngine?: StringFilter<"SerpPosition"> | string
    country?: StringNullableFilter<"SerpPosition"> | string | null
    createdAt?: DateTimeFilter<"SerpPosition"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
    keyword?: XOR<SeoKeywordScalarRelationFilter, SeoKeywordWhereInput>
  }, "id">

  export type SerpPositionOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    keywordId?: SortOrder
    position?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    searchEngine?: SortOrder
    country?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SerpPositionCountOrderByAggregateInput
    _avg?: SerpPositionAvgOrderByAggregateInput
    _max?: SerpPositionMaxOrderByAggregateInput
    _min?: SerpPositionMinOrderByAggregateInput
    _sum?: SerpPositionSumOrderByAggregateInput
  }

  export type SerpPositionScalarWhereWithAggregatesInput = {
    AND?: SerpPositionScalarWhereWithAggregatesInput | SerpPositionScalarWhereWithAggregatesInput[]
    OR?: SerpPositionScalarWhereWithAggregatesInput[]
    NOT?: SerpPositionScalarWhereWithAggregatesInput | SerpPositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SerpPosition"> | string
    portalId?: StringWithAggregatesFilter<"SerpPosition"> | string
    keywordId?: StringWithAggregatesFilter<"SerpPosition"> | string
    position?: IntNullableWithAggregatesFilter<"SerpPosition"> | number | null
    url?: StringNullableWithAggregatesFilter<"SerpPosition"> | string | null
    searchEngine?: StringWithAggregatesFilter<"SerpPosition"> | string
    country?: StringNullableWithAggregatesFilter<"SerpPosition"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SerpPosition"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    portalId?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    portalId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portal?: PortalOrderByWithRelationInput
    _relevance?: IntegrationOrderByRelevanceInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    portalId?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    portal?: XOR<PortalScalarRelationFilter, PortalWhereInput>
  }, "id">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    portalId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    portalId?: StringWithAggregatesFilter<"Integration"> | string
    type?: EnumIntegrationTypeWithAggregatesFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonWithAggregatesFilter<"Integration">
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAccountCreateInput = {
    id?: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiry?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExternalAccountsInput
  }

  export type ExternalAccountUncheckedCreateInput = {
    id?: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiry?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExternalAccountsNestedInput
  }

  export type ExternalAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAccountCreateManyInput = {
    id?: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiry?: number | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationCreateInput = {
    id?: string
    token: string
    expiry?: Date | string | null
    status?: $Enums.EmailVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailVerificationInput
  }

  export type EmailVerificationUncheckedCreateInput = {
    id?: string
    token: string
    expiry?: Date | string | null
    status?: $Enums.EmailVerificationStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmailVerificationStatusFieldUpdateOperationsInput | $Enums.EmailVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailVerificationNestedInput
  }

  export type EmailVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmailVerificationStatusFieldUpdateOperationsInput | $Enums.EmailVerificationStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationCreateManyInput = {
    id?: string
    token: string
    expiry?: Date | string | null
    status?: $Enums.EmailVerificationStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmailVerificationStatusFieldUpdateOperationsInput | $Enums.EmailVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmailVerificationStatusFieldUpdateOperationsInput | $Enums.EmailVerificationStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    id?: string
    token: string
    expiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: string
    token: string
    expiry: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: string
    token: string
    expiry: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiFactorAuthenticationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyCreateNestedManyWithoutMfaInput
    totp?: TotpCreateNestedOneWithoutMfaInput
    user: UserCreateNestedOneWithoutMfaInput
  }

  export type MultiFactorAuthenticationUncheckedCreateInput = {
    id?: string
    totpId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutMfaInput
  }

  export type MultiFactorAuthenticationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUpdateManyWithoutMfaNestedInput
    totp?: TotpUpdateOneWithoutMfaNestedInput
    user?: UserUpdateOneRequiredWithoutMfaNestedInput
  }

  export type MultiFactorAuthenticationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totpId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUncheckedUpdateManyWithoutMfaNestedInput
  }

  export type MultiFactorAuthenticationCreateManyInput = {
    id?: string
    totpId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultiFactorAuthenticationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultiFactorAuthenticationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totpId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotpCreateInput = {
    id?: string
    status?: $Enums.TotpStatus
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutTotpInput
  }

  export type TotpUncheckedCreateInput = {
    id?: string
    status?: $Enums.TotpStatus
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutTotpInput
  }

  export type TotpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTotpStatusFieldUpdateOperationsInput | $Enums.TotpStatus
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mfa?: MultiFactorAuthenticationUpdateOneWithoutTotpNestedInput
  }

  export type TotpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTotpStatusFieldUpdateOperationsInput | $Enums.TotpStatus
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutTotpNestedInput
  }

  export type TotpCreateManyInput = {
    id?: string
    status?: $Enums.TotpStatus
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTotpStatusFieldUpdateOperationsInput | $Enums.TotpStatus
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTotpStatusFieldUpdateOperationsInput | $Enums.TotpStatus
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyCreateInput = {
    id?: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter?: number
    lastUsedAt?: Date | string | null
    ip: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mfa: MultiFactorAuthenticationCreateNestedOneWithoutPasskeysInput
  }

  export type PasskeyUncheckedCreateInput = {
    id?: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter?: number
    lastUsedAt?: Date | string | null
    ip: string
    userAgent: string
    mfaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasskeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mfa?: MultiFactorAuthenticationUpdateOneRequiredWithoutPasskeysNestedInput
  }

  export type PasskeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    mfaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyCreateManyInput = {
    id?: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter?: number
    lastUsedAt?: Date | string | null
    ip: string
    userAgent: string
    mfaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasskeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    mfaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestrictionCreateInput = {
    id?: string
    reason: $Enums.RestrictionReason
    until?: Date | string | null
    status?: $Enums.RestrictionStatus
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRestrictionsInput
  }

  export type RestrictionUncheckedCreateInput = {
    id?: string
    reason: $Enums.RestrictionReason
    until?: Date | string | null
    status?: $Enums.RestrictionStatus
    userId: string
    createdAt?: Date | string
  }

  export type RestrictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRestrictionsNestedInput
  }

  export type RestrictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestrictionCreateManyInput = {
    id?: string
    reason: $Enums.RestrictionReason
    until?: Date | string | null
    status?: $Enums.RestrictionStatus
    userId: string
    createdAt?: Date | string
  }

  export type RestrictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestrictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    title: string
    slug: string
    thumbnail?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    thumbnail?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    title: string
    slug: string
    thumbnail?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    authorId: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    authorId: string
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortalCreateInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type PortalCreateManyInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleCreateInput = {
    id?: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPortalRolesInput
    portal: PortalCreateNestedOneWithoutUserRolesInput
  }

  export type UserPortalRoleUncheckedCreateInput = {
    id?: string
    userId: string
    portalId: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPortalRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPortalRolesNestedInput
    portal?: PortalUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserPortalRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleCreateManyInput = {
    id?: string
    userId: string
    portalId: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPortalRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutClientsInput
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    deals?: DealCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    portalId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutClientsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    portalId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadCreateInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    createdBy?: UserCreateNestedOneWithoutCreatedLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    createdById?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    createdById?: string | null
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealCreateInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutDealsInput
    client?: ClientCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDealsInput
    createdBy?: UserCreateNestedOneWithoutCreatedDealsInput
    appointments?: AppointmentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDealsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedDealsNestedInput
    appointments?: AppointmentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutAppointmentsInput
    client?: ClientCreateNestedOneWithoutAppointmentsInput
    deal?: DealCreateNestedOneWithoutAppointmentsInput
    product?: ProductCreateNestedOneWithoutAppointmentsInput
    assignedTo?: UserCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneWithoutAppointmentsNestedInput
    deal?: DealUpdateOneWithoutAppointmentsNestedInput
    product?: ProductUpdateOneWithoutAppointmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManyInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutProductsInput
    appointments?: AppointmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    portalId: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutProductsNestedInput
    appointments?: AppointmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    portalId: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutCustomFieldsInput
    values?: CustomFieldValueCreateNestedManyWithoutFieldInput
  }

  export type CustomFieldUncheckedCreateInput = {
    id?: string
    portalId: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: CustomFieldValueUncheckedCreateNestedManyWithoutFieldInput
  }

  export type CustomFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutCustomFieldsNestedInput
    values?: CustomFieldValueUpdateManyWithoutFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CustomFieldValueUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type CustomFieldCreateManyInput = {
    id?: string
    portalId: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    field: CustomFieldCreateNestedOneWithoutValuesInput
  }

  export type CustomFieldValueUncheckedCreateInput = {
    id?: string
    fieldId: string
    entityType: $Enums.EntityType
    entityId: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    field?: CustomFieldUpdateOneRequiredWithoutValuesNestedInput
  }

  export type CustomFieldValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueCreateManyInput = {
    id?: string
    fieldId: string
    entityType: $Enums.EntityType
    entityId: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    portal?: PortalCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    portalId?: string | null
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    portalId?: string | null
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoKeywordCreateInput = {
    id?: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutSeoKeywordsInput
    serpPositions?: SerpPositionCreateNestedManyWithoutKeywordInput
  }

  export type SeoKeywordUncheckedCreateInput = {
    id?: string
    portalId: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type SeoKeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutSeoKeywordsNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutKeywordNestedInput
  }

  export type SeoKeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type SeoKeywordCreateManyInput = {
    id?: string
    portalId: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoKeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoKeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoArticleCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    language?: string
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: string | null
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutSeoArticlesInput
  }

  export type SeoArticleUncheckedCreateInput = {
    id?: string
    portalId: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    language?: string
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: string | null
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutSeoArticlesNestedInput
  }

  export type SeoArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoArticleCreateManyInput = {
    id?: string
    portalId: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    language?: string
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: string | null
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionCreateInput = {
    id?: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
    portal: PortalCreateNestedOneWithoutSerpPositionsInput
    keyword: SeoKeywordCreateNestedOneWithoutSerpPositionsInput
  }

  export type SerpPositionUncheckedCreateInput = {
    id?: string
    portalId: string
    keywordId: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
  }

  export type SerpPositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutSerpPositionsNestedInput
    keyword?: SeoKeywordUpdateOneRequiredWithoutSerpPositionsNestedInput
  }

  export type SerpPositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionCreateManyInput = {
    id?: string
    portalId: string
    keywordId: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
  }

  export type SerpPositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    type: $Enums.IntegrationType
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    portalId: string
    type: $Enums.IntegrationType
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    portalId: string
    type: $Enums.IntegrationType
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumAuthMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[]
    notIn?: $Enums.AuthMethod[]
    not?: NestedEnumAuthMethodFilter<$PrismaModel> | $Enums.AuthMethod
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PasswordResetNullableScalarRelationFilter = {
    is?: PasswordResetWhereInput | null
    isNot?: PasswordResetWhereInput | null
  }

  export type ExternalAccountListRelationFilter = {
    every?: ExternalAccountWhereInput
    some?: ExternalAccountWhereInput
    none?: ExternalAccountWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type MultiFactorAuthenticationNullableScalarRelationFilter = {
    is?: MultiFactorAuthenticationWhereInput | null
    isNot?: MultiFactorAuthenticationWhereInput | null
  }

  export type RestrictionListRelationFilter = {
    every?: RestrictionWhereInput
    some?: RestrictionWhereInput
    none?: RestrictionWhereInput
  }

  export type EmailVerificationNullableScalarRelationFilter = {
    is?: EmailVerificationWhereInput | null
    isNot?: EmailVerificationWhereInput | null
  }

  export type UserPortalRoleListRelationFilter = {
    every?: UserPortalRoleWhereInput
    some?: UserPortalRoleWhereInput
    none?: UserPortalRoleWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExternalAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RestrictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPortalRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    points?: SortOrder
    role?: SortOrder
    method?: SortOrder
    emailVerified?: SortOrder
    isEmailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    points?: SortOrder
    role?: SortOrder
    method?: SortOrder
    emailVerified?: SortOrder
    isEmailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    surname?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    points?: SortOrder
    role?: SortOrder
    method?: SortOrder
    emailVerified?: SortOrder
    isEmailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAuthMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[]
    notIn?: $Enums.AuthMethod[]
    not?: NestedEnumAuthMethodWithAggregatesFilter<$PrismaModel> | $Enums.AuthMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthMethodFilter<$PrismaModel>
    _max?: NestedEnumAuthMethodFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAccountProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountProvider | EnumAccountProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AccountProvider[]
    notIn?: $Enums.AccountProvider[]
    not?: NestedEnumAccountProviderFilter<$PrismaModel> | $Enums.AccountProvider
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ExternalAccountOrderByRelevanceInput = {
    fields: ExternalAccountOrderByRelevanceFieldEnum | ExternalAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExternalAccountUserIdProviderCompoundUniqueInput = {
    userId: string
    provider: $Enums.AccountProvider
  }

  export type ExternalAccountCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAccountAvgOrderByAggregateInput = {
    expiry?: SortOrder
  }

  export type ExternalAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAccountMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalAccountSumOrderByAggregateInput = {
    expiry?: SortOrder
  }

  export type EnumAccountProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountProvider | EnumAccountProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AccountProvider[]
    notIn?: $Enums.AccountProvider[]
    not?: NestedEnumAccountProviderWithAggregatesFilter<$PrismaModel> | $Enums.AccountProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountProviderFilter<$PrismaModel>
    _max?: NestedEnumAccountProviderFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEmailVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailVerificationStatus | EnumEmailVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailVerificationStatus[]
    notIn?: $Enums.EmailVerificationStatus[]
    not?: NestedEnumEmailVerificationStatusFilter<$PrismaModel> | $Enums.EmailVerificationStatus
  }

  export type EmailVerificationOrderByRelevanceInput = {
    fields: EmailVerificationOrderByRelevanceFieldEnum | EmailVerificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmailVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmailVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailVerificationStatus | EnumEmailVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailVerificationStatus[]
    notIn?: $Enums.EmailVerificationStatus[]
    not?: NestedEnumEmailVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailVerificationStatusFilter<$PrismaModel>
  }

  export type PasswordResetOrderByRelevanceInput = {
    fields: PasswordResetOrderByRelevanceFieldEnum | PasswordResetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiry?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasskeyListRelationFilter = {
    every?: PasskeyWhereInput
    some?: PasskeyWhereInput
    none?: PasskeyWhereInput
  }

  export type TotpNullableScalarRelationFilter = {
    is?: TotpWhereInput | null
    isNot?: TotpWhereInput | null
  }

  export type PasskeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultiFactorAuthenticationOrderByRelevanceInput = {
    fields: MultiFactorAuthenticationOrderByRelevanceFieldEnum | MultiFactorAuthenticationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MultiFactorAuthenticationCountOrderByAggregateInput = {
    id?: SortOrder
    totpId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultiFactorAuthenticationMaxOrderByAggregateInput = {
    id?: SortOrder
    totpId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultiFactorAuthenticationMinOrderByAggregateInput = {
    id?: SortOrder
    totpId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTotpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TotpStatus | EnumTotpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TotpStatus[]
    notIn?: $Enums.TotpStatus[]
    not?: NestedEnumTotpStatusFilter<$PrismaModel> | $Enums.TotpStatus
  }

  export type TotpOrderByRelevanceInput = {
    fields: TotpOrderByRelevanceFieldEnum | TotpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TotpCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotpMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotpMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTotpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TotpStatus | EnumTotpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TotpStatus[]
    notIn?: $Enums.TotpStatus[]
    not?: NestedEnumTotpStatusWithAggregatesFilter<$PrismaModel> | $Enums.TotpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTotpStatusFilter<$PrismaModel>
    _max?: NestedEnumTotpStatusFilter<$PrismaModel>
  }

  export type MultiFactorAuthenticationScalarRelationFilter = {
    is?: MultiFactorAuthenticationWhereInput
    isNot?: MultiFactorAuthenticationWhereInput
  }

  export type PasskeyOrderByRelevanceInput = {
    fields: PasskeyOrderByRelevanceFieldEnum | PasskeyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PasskeyCountOrderByAggregateInput = {
    id?: SortOrder
    deviceName?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    lastUsedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    mfaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasskeyAvgOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type PasskeyMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceName?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    lastUsedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    mfaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasskeyMinOrderByAggregateInput = {
    id?: SortOrder
    deviceName?: SortOrder
    credentialId?: SortOrder
    publicKey?: SortOrder
    counter?: SortOrder
    lastUsedAt?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    mfaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasskeySumOrderByAggregateInput = {
    counter?: SortOrder
  }

  export type EnumRestrictionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionReason | EnumRestrictionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionReason[]
    notIn?: $Enums.RestrictionReason[]
    not?: NestedEnumRestrictionReasonFilter<$PrismaModel> | $Enums.RestrictionReason
  }

  export type EnumRestrictionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionStatus | EnumRestrictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionStatus[]
    notIn?: $Enums.RestrictionStatus[]
    not?: NestedEnumRestrictionStatusFilter<$PrismaModel> | $Enums.RestrictionStatus
  }

  export type RestrictionOrderByRelevanceInput = {
    fields: RestrictionOrderByRelevanceFieldEnum | RestrictionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RestrictionCountOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    until?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RestrictionMaxOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    until?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RestrictionMinOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    until?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRestrictionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionReason | EnumRestrictionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionReason[]
    notIn?: $Enums.RestrictionReason[]
    not?: NestedEnumRestrictionReasonWithAggregatesFilter<$PrismaModel> | $Enums.RestrictionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRestrictionReasonFilter<$PrismaModel>
    _max?: NestedEnumRestrictionReasonFilter<$PrismaModel>
  }

  export type EnumRestrictionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionStatus | EnumRestrictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionStatus[]
    notIn?: $Enums.RestrictionStatus[]
    not?: NestedEnumRestrictionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RestrictionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRestrictionStatusFilter<$PrismaModel>
    _max?: NestedEnumRestrictionStatusFilter<$PrismaModel>
  }

  export type PostOrderByRelevanceInput = {
    fields: PostOrderByRelevanceFieldEnum | PostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnail?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnail?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnail?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentOrderByRelevanceInput = {
    fields: CommentOrderByRelevanceFieldEnum | CommentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    edited?: SortOrder
    deleted?: SortOrder
    authorId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CustomFieldListRelationFilter = {
    every?: CustomFieldWhereInput
    some?: CustomFieldWhereInput
    none?: CustomFieldWhereInput
  }

  export type SeoKeywordListRelationFilter = {
    every?: SeoKeywordWhereInput
    some?: SeoKeywordWhereInput
    none?: SeoKeywordWhereInput
  }

  export type SeoArticleListRelationFilter = {
    every?: SeoArticleWhereInput
    some?: SeoArticleWhereInput
    none?: SeoArticleWhereInput
  }

  export type SerpPositionListRelationFilter = {
    every?: SerpPositionWhereInput
    some?: SerpPositionWhereInput
    none?: SerpPositionWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeoKeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeoArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SerpPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortalOrderByRelevanceInput = {
    fields: PortalOrderByRelevanceFieldEnum | PortalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PortalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrder
    logo?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    settings?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrder
    logo?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    customDomain?: SortOrder
    logo?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    trialEndsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPortalRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PortalRole | EnumPortalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PortalRole[]
    notIn?: $Enums.PortalRole[]
    not?: NestedEnumPortalRoleFilter<$PrismaModel> | $Enums.PortalRole
  }

  export type PortalScalarRelationFilter = {
    is?: PortalWhereInput
    isNot?: PortalWhereInput
  }

  export type UserPortalRoleOrderByRelevanceInput = {
    fields: UserPortalRoleOrderByRelevanceFieldEnum | UserPortalRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserPortalRoleUserIdPortalIdCompoundUniqueInput = {
    userId: string
    portalId: string
  }

  export type UserPortalRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    portalId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPortalRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    portalId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPortalRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    portalId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPortalRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PortalRole | EnumPortalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PortalRole[]
    notIn?: $Enums.PortalRole[]
    not?: NestedEnumPortalRoleWithAggregatesFilter<$PrismaModel> | $Enums.PortalRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPortalRoleFilter<$PrismaModel>
    _max?: NestedEnumPortalRoleFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumLeadSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[]
    notIn?: $Enums.LeadSource[]
    not?: NestedEnumLeadSourceFilter<$PrismaModel> | $Enums.LeadSource
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[]
    notIn?: $Enums.LeadStatus[]
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type LeadOrderByRelevanceInput = {
    fields: LeadOrderByRelevanceFieldEnum | LeadOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumLeadSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[]
    notIn?: $Enums.LeadSource[]
    not?: NestedEnumLeadSourceWithAggregatesFilter<$PrismaModel> | $Enums.LeadSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadSourceFilter<$PrismaModel>
    _max?: NestedEnumLeadSourceFilter<$PrismaModel>
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[]
    notIn?: $Enums.LeadStatus[]
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type DealOrderByRelevanceInput = {
    fields: DealOrderByRelevanceFieldEnum | DealOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    stage?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    leadId?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    stage?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    leadId?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    stage?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    leadId?: SortOrder
    assignedToId?: SortOrder
    createdById?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type DealNullableScalarRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type AppointmentOrderByRelevanceInput = {
    fields: AppointmentOrderByRelevanceFieldEnum | AppointmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    googleCalendarEventId?: SortOrder
    reminderSent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    dealId?: SortOrder
    productId?: SortOrder
    assignedToId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    googleCalendarEventId?: SortOrder
    reminderSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    dealId?: SortOrder
    productId?: SortOrder
    assignedToId?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    location?: SortOrder
    googleCalendarEventId?: SortOrder
    reminderSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    dealId?: SortOrder
    productId?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    portfolio?: SortOrder
    isActive?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[]
    notIn?: $Enums.EntityType[]
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type EnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type CustomFieldValueListRelationFilter = {
    every?: CustomFieldValueWhereInput
    some?: CustomFieldValueWhereInput
    none?: CustomFieldValueWhereInput
  }

  export type CustomFieldValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldOrderByRelevanceInput = {
    fields: CustomFieldOrderByRelevanceFieldEnum | CustomFieldOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    entityType?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    config?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    entityType?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    entityType?: SortOrder
    name?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[]
    notIn?: $Enums.EntityType[]
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type EnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type CustomFieldScalarRelationFilter = {
    is?: CustomFieldWhereInput
    isNot?: CustomFieldWhereInput
  }

  export type CustomFieldValueOrderByRelevanceInput = {
    fields: CustomFieldValueOrderByRelevanceFieldEnum | CustomFieldValueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomFieldValueFieldIdEntityTypeEntityIdCompoundUniqueInput = {
    fieldId: string
    entityType: $Enums.EntityType
    entityId: string
  }

  export type CustomFieldValueCountOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldValueMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomFieldValueMinOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortalNullableScalarRelationFilter = {
    is?: PortalWhereInput | null
    isNot?: PortalWhereInput | null
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SeoKeywordOrderByRelevanceInput = {
    fields: SeoKeywordOrderByRelevanceFieldEnum | SeoKeywordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeoKeywordPortalIdKeywordLanguageCompoundUniqueInput = {
    portalId: string
    keyword: string
    language: string
  }

  export type SeoKeywordCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    keyword?: SortOrder
    language?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoKeywordAvgOrderByAggregateInput = {
    volume?: SortOrder
    difficulty?: SortOrder
  }

  export type SeoKeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    keyword?: SortOrder
    language?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoKeywordMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    keyword?: SortOrder
    language?: SortOrder
    volume?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoKeywordSumOrderByAggregateInput = {
    volume?: SortOrder
    difficulty?: SortOrder
  }

  export type SeoArticleOrderByRelevanceInput = {
    fields: SeoArticleOrderByRelevanceFieldEnum | SeoArticleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeoArticlePortalIdSlugLanguageCompoundUniqueInput = {
    portalId: string
    slug: string
    language: string
  }

  export type SeoArticleCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    language?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    keywords?: SortOrder
    faqSchema?: SortOrder
    ogImage?: SortOrder
    isPublished?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    language?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    isPublished?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoArticleMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    language?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    ogImage?: SortOrder
    isPublished?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeoKeywordScalarRelationFilter = {
    is?: SeoKeywordWhereInput
    isNot?: SeoKeywordWhereInput
  }

  export type SerpPositionOrderByRelevanceInput = {
    fields: SerpPositionOrderByRelevanceFieldEnum | SerpPositionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SerpPositionCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    keywordId?: SortOrder
    position?: SortOrder
    url?: SortOrder
    searchEngine?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
  }

  export type SerpPositionAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type SerpPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    keywordId?: SortOrder
    position?: SortOrder
    url?: SortOrder
    searchEngine?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
  }

  export type SerpPositionMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    keywordId?: SortOrder
    position?: SortOrder
    url?: SortOrder
    searchEngine?: SortOrder
    country?: SortOrder
    createdAt?: SortOrder
  }

  export type SerpPositionSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[]
    notIn?: $Enums.IntegrationType[]
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntegrationOrderByRelevanceInput = {
    fields: IntegrationOrderByRelevanceFieldEnum | IntegrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    type?: SortOrder
    config?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    portalId?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[]
    notIn?: $Enums.IntegrationType[]
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PasswordResetCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    connect?: PasswordResetWhereUniqueInput
  }

  export type ExternalAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<ExternalAccountCreateWithoutUserInput, ExternalAccountUncheckedCreateWithoutUserInput> | ExternalAccountCreateWithoutUserInput[] | ExternalAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalAccountCreateOrConnectWithoutUserInput | ExternalAccountCreateOrConnectWithoutUserInput[]
    createMany?: ExternalAccountCreateManyUserInputEnvelope
    connect?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MultiFactorAuthenticationCreateNestedOneWithoutUserInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutUserInput, MultiFactorAuthenticationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutUserInput
    connect?: MultiFactorAuthenticationWhereUniqueInput
  }

  export type RestrictionCreateNestedManyWithoutUserInput = {
    create?: XOR<RestrictionCreateWithoutUserInput, RestrictionUncheckedCreateWithoutUserInput> | RestrictionCreateWithoutUserInput[] | RestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutUserInput | RestrictionCreateOrConnectWithoutUserInput[]
    createMany?: RestrictionCreateManyUserInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type EmailVerificationCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    connect?: EmailVerificationWhereUniqueInput
  }

  export type UserPortalRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPortalRoleCreateWithoutUserInput, UserPortalRoleUncheckedCreateWithoutUserInput> | UserPortalRoleCreateWithoutUserInput[] | UserPortalRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutUserInput | UserPortalRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserPortalRoleCreateManyUserInputEnvelope
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LeadCreateWithoutCreatedByInput, LeadUncheckedCreateWithoutCreatedByInput> | LeadCreateWithoutCreatedByInput[] | LeadUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCreatedByInput | LeadCreateOrConnectWithoutCreatedByInput[]
    createMany?: LeadCreateManyCreatedByInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<DealCreateWithoutAssignedToInput, DealUncheckedCreateWithoutAssignedToInput> | DealCreateWithoutAssignedToInput[] | DealUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAssignedToInput | DealCreateOrConnectWithoutAssignedToInput[]
    createMany?: DealCreateManyAssignedToInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DealCreateWithoutCreatedByInput, DealUncheckedCreateWithoutCreatedByInput> | DealCreateWithoutCreatedByInput[] | DealUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DealCreateOrConnectWithoutCreatedByInput | DealCreateOrConnectWithoutCreatedByInput[]
    createMany?: DealCreateManyCreatedByInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<AppointmentCreateWithoutAssignedToInput, AppointmentUncheckedCreateWithoutAssignedToInput> | AppointmentCreateWithoutAssignedToInput[] | AppointmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAssignedToInput | AppointmentCreateOrConnectWithoutAssignedToInput[]
    createMany?: AppointmentCreateManyAssignedToInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PasswordResetUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    connect?: PasswordResetWhereUniqueInput
  }

  export type ExternalAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExternalAccountCreateWithoutUserInput, ExternalAccountUncheckedCreateWithoutUserInput> | ExternalAccountCreateWithoutUserInput[] | ExternalAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalAccountCreateOrConnectWithoutUserInput | ExternalAccountCreateOrConnectWithoutUserInput[]
    createMany?: ExternalAccountCreateManyUserInputEnvelope
    connect?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutUserInput, MultiFactorAuthenticationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutUserInput
    connect?: MultiFactorAuthenticationWhereUniqueInput
  }

  export type RestrictionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RestrictionCreateWithoutUserInput, RestrictionUncheckedCreateWithoutUserInput> | RestrictionCreateWithoutUserInput[] | RestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutUserInput | RestrictionCreateOrConnectWithoutUserInput[]
    createMany?: RestrictionCreateManyUserInputEnvelope
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
  }

  export type EmailVerificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    connect?: EmailVerificationWhereUniqueInput
  }

  export type UserPortalRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPortalRoleCreateWithoutUserInput, UserPortalRoleUncheckedCreateWithoutUserInput> | UserPortalRoleCreateWithoutUserInput[] | UserPortalRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutUserInput | UserPortalRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserPortalRoleCreateManyUserInputEnvelope
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LeadCreateWithoutCreatedByInput, LeadUncheckedCreateWithoutCreatedByInput> | LeadCreateWithoutCreatedByInput[] | LeadUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCreatedByInput | LeadCreateOrConnectWithoutCreatedByInput[]
    createMany?: LeadCreateManyCreatedByInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<DealCreateWithoutAssignedToInput, DealUncheckedCreateWithoutAssignedToInput> | DealCreateWithoutAssignedToInput[] | DealUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAssignedToInput | DealCreateOrConnectWithoutAssignedToInput[]
    createMany?: DealCreateManyAssignedToInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DealCreateWithoutCreatedByInput, DealUncheckedCreateWithoutCreatedByInput> | DealCreateWithoutCreatedByInput[] | DealUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DealCreateOrConnectWithoutCreatedByInput | DealCreateOrConnectWithoutCreatedByInput[]
    createMany?: DealCreateManyCreatedByInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<AppointmentCreateWithoutAssignedToInput, AppointmentUncheckedCreateWithoutAssignedToInput> | AppointmentCreateWithoutAssignedToInput[] | AppointmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAssignedToInput | AppointmentCreateOrConnectWithoutAssignedToInput[]
    createMany?: AppointmentCreateManyAssignedToInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumAuthMethodFieldUpdateOperationsInput = {
    set?: $Enums.AuthMethod
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PasswordResetUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    upsert?: PasswordResetUpsertWithoutUserInput
    disconnect?: PasswordResetWhereInput | boolean
    delete?: PasswordResetWhereInput | boolean
    connect?: PasswordResetWhereUniqueInput
    update?: XOR<XOR<PasswordResetUpdateToOneWithWhereWithoutUserInput, PasswordResetUpdateWithoutUserInput>, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type ExternalAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExternalAccountCreateWithoutUserInput, ExternalAccountUncheckedCreateWithoutUserInput> | ExternalAccountCreateWithoutUserInput[] | ExternalAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalAccountCreateOrConnectWithoutUserInput | ExternalAccountCreateOrConnectWithoutUserInput[]
    upsert?: ExternalAccountUpsertWithWhereUniqueWithoutUserInput | ExternalAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExternalAccountCreateManyUserInputEnvelope
    set?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    disconnect?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    delete?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    connect?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    update?: ExternalAccountUpdateWithWhereUniqueWithoutUserInput | ExternalAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExternalAccountUpdateManyWithWhereWithoutUserInput | ExternalAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExternalAccountScalarWhereInput | ExternalAccountScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MultiFactorAuthenticationUpdateOneWithoutUserNestedInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutUserInput, MultiFactorAuthenticationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutUserInput
    upsert?: MultiFactorAuthenticationUpsertWithoutUserInput
    disconnect?: MultiFactorAuthenticationWhereInput | boolean
    delete?: MultiFactorAuthenticationWhereInput | boolean
    connect?: MultiFactorAuthenticationWhereUniqueInput
    update?: XOR<XOR<MultiFactorAuthenticationUpdateToOneWithWhereWithoutUserInput, MultiFactorAuthenticationUpdateWithoutUserInput>, MultiFactorAuthenticationUncheckedUpdateWithoutUserInput>
  }

  export type RestrictionUpdateManyWithoutUserNestedInput = {
    create?: XOR<RestrictionCreateWithoutUserInput, RestrictionUncheckedCreateWithoutUserInput> | RestrictionCreateWithoutUserInput[] | RestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutUserInput | RestrictionCreateOrConnectWithoutUserInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutUserInput | RestrictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RestrictionCreateManyUserInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutUserInput | RestrictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutUserInput | RestrictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type EmailVerificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    upsert?: EmailVerificationUpsertWithoutUserInput
    disconnect?: EmailVerificationWhereInput | boolean
    delete?: EmailVerificationWhereInput | boolean
    connect?: EmailVerificationWhereUniqueInput
    update?: XOR<XOR<EmailVerificationUpdateToOneWithWhereWithoutUserInput, EmailVerificationUpdateWithoutUserInput>, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type UserPortalRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPortalRoleCreateWithoutUserInput, UserPortalRoleUncheckedCreateWithoutUserInput> | UserPortalRoleCreateWithoutUserInput[] | UserPortalRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutUserInput | UserPortalRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserPortalRoleUpsertWithWhereUniqueWithoutUserInput | UserPortalRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPortalRoleCreateManyUserInputEnvelope
    set?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    disconnect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    delete?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    update?: UserPortalRoleUpdateWithWhereUniqueWithoutUserInput | UserPortalRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPortalRoleUpdateManyWithWhereWithoutUserInput | UserPortalRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPortalRoleScalarWhereInput | UserPortalRoleScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCreatedByInput | ClientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCreatedByInput | ClientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCreatedByInput | ClientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAssignedToInput | LeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAssignedToInput | LeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAssignedToInput | LeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LeadCreateWithoutCreatedByInput, LeadUncheckedCreateWithoutCreatedByInput> | LeadCreateWithoutCreatedByInput[] | LeadUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCreatedByInput | LeadCreateOrConnectWithoutCreatedByInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutCreatedByInput | LeadUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LeadCreateManyCreatedByInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutCreatedByInput | LeadUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutCreatedByInput | LeadUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<DealCreateWithoutAssignedToInput, DealUncheckedCreateWithoutAssignedToInput> | DealCreateWithoutAssignedToInput[] | DealUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAssignedToInput | DealCreateOrConnectWithoutAssignedToInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutAssignedToInput | DealUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: DealCreateManyAssignedToInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutAssignedToInput | DealUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: DealUpdateManyWithWhereWithoutAssignedToInput | DealUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type DealUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DealCreateWithoutCreatedByInput, DealUncheckedCreateWithoutCreatedByInput> | DealCreateWithoutCreatedByInput[] | DealUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DealCreateOrConnectWithoutCreatedByInput | DealCreateOrConnectWithoutCreatedByInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutCreatedByInput | DealUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DealCreateManyCreatedByInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutCreatedByInput | DealUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DealUpdateManyWithWhereWithoutCreatedByInput | DealUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<AppointmentCreateWithoutAssignedToInput, AppointmentUncheckedCreateWithoutAssignedToInput> | AppointmentCreateWithoutAssignedToInput[] | AppointmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAssignedToInput | AppointmentCreateOrConnectWithoutAssignedToInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAssignedToInput | AppointmentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: AppointmentCreateManyAssignedToInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAssignedToInput | AppointmentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAssignedToInput | AppointmentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PasswordResetUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput
    upsert?: PasswordResetUpsertWithoutUserInput
    disconnect?: PasswordResetWhereInput | boolean
    delete?: PasswordResetWhereInput | boolean
    connect?: PasswordResetWhereUniqueInput
    update?: XOR<XOR<PasswordResetUpdateToOneWithWhereWithoutUserInput, PasswordResetUpdateWithoutUserInput>, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type ExternalAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExternalAccountCreateWithoutUserInput, ExternalAccountUncheckedCreateWithoutUserInput> | ExternalAccountCreateWithoutUserInput[] | ExternalAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalAccountCreateOrConnectWithoutUserInput | ExternalAccountCreateOrConnectWithoutUserInput[]
    upsert?: ExternalAccountUpsertWithWhereUniqueWithoutUserInput | ExternalAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExternalAccountCreateManyUserInputEnvelope
    set?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    disconnect?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    delete?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    connect?: ExternalAccountWhereUniqueInput | ExternalAccountWhereUniqueInput[]
    update?: ExternalAccountUpdateWithWhereUniqueWithoutUserInput | ExternalAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExternalAccountUpdateManyWithWhereWithoutUserInput | ExternalAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExternalAccountScalarWhereInput | ExternalAccountScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutUserInput, MultiFactorAuthenticationUncheckedCreateWithoutUserInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutUserInput
    upsert?: MultiFactorAuthenticationUpsertWithoutUserInput
    disconnect?: MultiFactorAuthenticationWhereInput | boolean
    delete?: MultiFactorAuthenticationWhereInput | boolean
    connect?: MultiFactorAuthenticationWhereUniqueInput
    update?: XOR<XOR<MultiFactorAuthenticationUpdateToOneWithWhereWithoutUserInput, MultiFactorAuthenticationUpdateWithoutUserInput>, MultiFactorAuthenticationUncheckedUpdateWithoutUserInput>
  }

  export type RestrictionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RestrictionCreateWithoutUserInput, RestrictionUncheckedCreateWithoutUserInput> | RestrictionCreateWithoutUserInput[] | RestrictionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RestrictionCreateOrConnectWithoutUserInput | RestrictionCreateOrConnectWithoutUserInput[]
    upsert?: RestrictionUpsertWithWhereUniqueWithoutUserInput | RestrictionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RestrictionCreateManyUserInputEnvelope
    set?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    disconnect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    delete?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    connect?: RestrictionWhereUniqueInput | RestrictionWhereUniqueInput[]
    update?: RestrictionUpdateWithWhereUniqueWithoutUserInput | RestrictionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RestrictionUpdateManyWithWhereWithoutUserInput | RestrictionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
  }

  export type EmailVerificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    upsert?: EmailVerificationUpsertWithoutUserInput
    disconnect?: EmailVerificationWhereInput | boolean
    delete?: EmailVerificationWhereInput | boolean
    connect?: EmailVerificationWhereUniqueInput
    update?: XOR<XOR<EmailVerificationUpdateToOneWithWhereWithoutUserInput, EmailVerificationUpdateWithoutUserInput>, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPortalRoleCreateWithoutUserInput, UserPortalRoleUncheckedCreateWithoutUserInput> | UserPortalRoleCreateWithoutUserInput[] | UserPortalRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutUserInput | UserPortalRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserPortalRoleUpsertWithWhereUniqueWithoutUserInput | UserPortalRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPortalRoleCreateManyUserInputEnvelope
    set?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    disconnect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    delete?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    update?: UserPortalRoleUpdateWithWhereUniqueWithoutUserInput | UserPortalRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPortalRoleUpdateManyWithWhereWithoutUserInput | UserPortalRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPortalRoleScalarWhereInput | UserPortalRoleScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput> | ClientCreateWithoutCreatedByInput[] | ClientUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCreatedByInput | ClientCreateOrConnectWithoutCreatedByInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCreatedByInput | ClientUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ClientCreateManyCreatedByInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCreatedByInput | ClientUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCreatedByInput | ClientUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput> | LeadCreateWithoutAssignedToInput[] | LeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutAssignedToInput | LeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutAssignedToInput | LeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: LeadCreateManyAssignedToInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutAssignedToInput | LeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutAssignedToInput | LeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LeadCreateWithoutCreatedByInput, LeadUncheckedCreateWithoutCreatedByInput> | LeadCreateWithoutCreatedByInput[] | LeadUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCreatedByInput | LeadCreateOrConnectWithoutCreatedByInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutCreatedByInput | LeadUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LeadCreateManyCreatedByInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutCreatedByInput | LeadUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutCreatedByInput | LeadUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<DealCreateWithoutAssignedToInput, DealUncheckedCreateWithoutAssignedToInput> | DealCreateWithoutAssignedToInput[] | DealUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: DealCreateOrConnectWithoutAssignedToInput | DealCreateOrConnectWithoutAssignedToInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutAssignedToInput | DealUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: DealCreateManyAssignedToInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutAssignedToInput | DealUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: DealUpdateManyWithWhereWithoutAssignedToInput | DealUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DealCreateWithoutCreatedByInput, DealUncheckedCreateWithoutCreatedByInput> | DealCreateWithoutCreatedByInput[] | DealUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DealCreateOrConnectWithoutCreatedByInput | DealCreateOrConnectWithoutCreatedByInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutCreatedByInput | DealUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DealCreateManyCreatedByInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutCreatedByInput | DealUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DealUpdateManyWithWhereWithoutCreatedByInput | DealUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<AppointmentCreateWithoutAssignedToInput, AppointmentUncheckedCreateWithoutAssignedToInput> | AppointmentCreateWithoutAssignedToInput[] | AppointmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutAssignedToInput | AppointmentCreateOrConnectWithoutAssignedToInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutAssignedToInput | AppointmentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: AppointmentCreateManyAssignedToInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutAssignedToInput | AppointmentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutAssignedToInput | AppointmentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExternalAccountsInput = {
    create?: XOR<UserCreateWithoutExternalAccountsInput, UserUncheckedCreateWithoutExternalAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExternalAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAccountProviderFieldUpdateOperationsInput = {
    set?: $Enums.AccountProvider
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutExternalAccountsNestedInput = {
    create?: XOR<UserCreateWithoutExternalAccountsInput, UserUncheckedCreateWithoutExternalAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExternalAccountsInput
    upsert?: UserUpsertWithoutExternalAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExternalAccountsInput, UserUpdateWithoutExternalAccountsInput>, UserUncheckedUpdateWithoutExternalAccountsInput>
  }

  export type UserCreateNestedOneWithoutEmailVerificationInput = {
    create?: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEmailVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmailVerificationStatus
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationInput
    upsert?: UserUpsertWithoutEmailVerificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationInput, UserUpdateWithoutEmailVerificationInput>, UserUncheckedUpdateWithoutEmailVerificationInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetInput = {
    create?: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetInput
    upsert?: UserUpsertWithoutPasswordResetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetInput, UserUpdateWithoutPasswordResetInput>, UserUncheckedUpdateWithoutPasswordResetInput>
  }

  export type PasskeyCreateNestedManyWithoutMfaInput = {
    create?: XOR<PasskeyCreateWithoutMfaInput, PasskeyUncheckedCreateWithoutMfaInput> | PasskeyCreateWithoutMfaInput[] | PasskeyUncheckedCreateWithoutMfaInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutMfaInput | PasskeyCreateOrConnectWithoutMfaInput[]
    createMany?: PasskeyCreateManyMfaInputEnvelope
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
  }

  export type TotpCreateNestedOneWithoutMfaInput = {
    create?: XOR<TotpCreateWithoutMfaInput, TotpUncheckedCreateWithoutMfaInput>
    connectOrCreate?: TotpCreateOrConnectWithoutMfaInput
    connect?: TotpWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMfaInput = {
    create?: XOR<UserCreateWithoutMfaInput, UserUncheckedCreateWithoutMfaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaInput
    connect?: UserWhereUniqueInput
  }

  export type PasskeyUncheckedCreateNestedManyWithoutMfaInput = {
    create?: XOR<PasskeyCreateWithoutMfaInput, PasskeyUncheckedCreateWithoutMfaInput> | PasskeyCreateWithoutMfaInput[] | PasskeyUncheckedCreateWithoutMfaInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutMfaInput | PasskeyCreateOrConnectWithoutMfaInput[]
    createMany?: PasskeyCreateManyMfaInputEnvelope
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
  }

  export type PasskeyUpdateManyWithoutMfaNestedInput = {
    create?: XOR<PasskeyCreateWithoutMfaInput, PasskeyUncheckedCreateWithoutMfaInput> | PasskeyCreateWithoutMfaInput[] | PasskeyUncheckedCreateWithoutMfaInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutMfaInput | PasskeyCreateOrConnectWithoutMfaInput[]
    upsert?: PasskeyUpsertWithWhereUniqueWithoutMfaInput | PasskeyUpsertWithWhereUniqueWithoutMfaInput[]
    createMany?: PasskeyCreateManyMfaInputEnvelope
    set?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    disconnect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    delete?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    update?: PasskeyUpdateWithWhereUniqueWithoutMfaInput | PasskeyUpdateWithWhereUniqueWithoutMfaInput[]
    updateMany?: PasskeyUpdateManyWithWhereWithoutMfaInput | PasskeyUpdateManyWithWhereWithoutMfaInput[]
    deleteMany?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
  }

  export type TotpUpdateOneWithoutMfaNestedInput = {
    create?: XOR<TotpCreateWithoutMfaInput, TotpUncheckedCreateWithoutMfaInput>
    connectOrCreate?: TotpCreateOrConnectWithoutMfaInput
    upsert?: TotpUpsertWithoutMfaInput
    disconnect?: TotpWhereInput | boolean
    delete?: TotpWhereInput | boolean
    connect?: TotpWhereUniqueInput
    update?: XOR<XOR<TotpUpdateToOneWithWhereWithoutMfaInput, TotpUpdateWithoutMfaInput>, TotpUncheckedUpdateWithoutMfaInput>
  }

  export type UserUpdateOneRequiredWithoutMfaNestedInput = {
    create?: XOR<UserCreateWithoutMfaInput, UserUncheckedCreateWithoutMfaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaInput
    upsert?: UserUpsertWithoutMfaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMfaInput, UserUpdateWithoutMfaInput>, UserUncheckedUpdateWithoutMfaInput>
  }

  export type PasskeyUncheckedUpdateManyWithoutMfaNestedInput = {
    create?: XOR<PasskeyCreateWithoutMfaInput, PasskeyUncheckedCreateWithoutMfaInput> | PasskeyCreateWithoutMfaInput[] | PasskeyUncheckedCreateWithoutMfaInput[]
    connectOrCreate?: PasskeyCreateOrConnectWithoutMfaInput | PasskeyCreateOrConnectWithoutMfaInput[]
    upsert?: PasskeyUpsertWithWhereUniqueWithoutMfaInput | PasskeyUpsertWithWhereUniqueWithoutMfaInput[]
    createMany?: PasskeyCreateManyMfaInputEnvelope
    set?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    disconnect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    delete?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    connect?: PasskeyWhereUniqueInput | PasskeyWhereUniqueInput[]
    update?: PasskeyUpdateWithWhereUniqueWithoutMfaInput | PasskeyUpdateWithWhereUniqueWithoutMfaInput[]
    updateMany?: PasskeyUpdateManyWithWhereWithoutMfaInput | PasskeyUpdateManyWithWhereWithoutMfaInput[]
    deleteMany?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
  }

  export type MultiFactorAuthenticationCreateNestedOneWithoutTotpInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutTotpInput, MultiFactorAuthenticationUncheckedCreateWithoutTotpInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutTotpInput
    connect?: MultiFactorAuthenticationWhereUniqueInput
  }

  export type MultiFactorAuthenticationUncheckedCreateNestedOneWithoutTotpInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutTotpInput, MultiFactorAuthenticationUncheckedCreateWithoutTotpInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutTotpInput
    connect?: MultiFactorAuthenticationWhereUniqueInput
  }

  export type EnumTotpStatusFieldUpdateOperationsInput = {
    set?: $Enums.TotpStatus
  }

  export type MultiFactorAuthenticationUpdateOneWithoutTotpNestedInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutTotpInput, MultiFactorAuthenticationUncheckedCreateWithoutTotpInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutTotpInput
    upsert?: MultiFactorAuthenticationUpsertWithoutTotpInput
    disconnect?: MultiFactorAuthenticationWhereInput | boolean
    delete?: MultiFactorAuthenticationWhereInput | boolean
    connect?: MultiFactorAuthenticationWhereUniqueInput
    update?: XOR<XOR<MultiFactorAuthenticationUpdateToOneWithWhereWithoutTotpInput, MultiFactorAuthenticationUpdateWithoutTotpInput>, MultiFactorAuthenticationUncheckedUpdateWithoutTotpInput>
  }

  export type MultiFactorAuthenticationUncheckedUpdateOneWithoutTotpNestedInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutTotpInput, MultiFactorAuthenticationUncheckedCreateWithoutTotpInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutTotpInput
    upsert?: MultiFactorAuthenticationUpsertWithoutTotpInput
    disconnect?: MultiFactorAuthenticationWhereInput | boolean
    delete?: MultiFactorAuthenticationWhereInput | boolean
    connect?: MultiFactorAuthenticationWhereUniqueInput
    update?: XOR<XOR<MultiFactorAuthenticationUpdateToOneWithWhereWithoutTotpInput, MultiFactorAuthenticationUpdateWithoutTotpInput>, MultiFactorAuthenticationUncheckedUpdateWithoutTotpInput>
  }

  export type MultiFactorAuthenticationCreateNestedOneWithoutPasskeysInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutPasskeysInput, MultiFactorAuthenticationUncheckedCreateWithoutPasskeysInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutPasskeysInput
    connect?: MultiFactorAuthenticationWhereUniqueInput
  }

  export type MultiFactorAuthenticationUpdateOneRequiredWithoutPasskeysNestedInput = {
    create?: XOR<MultiFactorAuthenticationCreateWithoutPasskeysInput, MultiFactorAuthenticationUncheckedCreateWithoutPasskeysInput>
    connectOrCreate?: MultiFactorAuthenticationCreateOrConnectWithoutPasskeysInput
    upsert?: MultiFactorAuthenticationUpsertWithoutPasskeysInput
    connect?: MultiFactorAuthenticationWhereUniqueInput
    update?: XOR<XOR<MultiFactorAuthenticationUpdateToOneWithWhereWithoutPasskeysInput, MultiFactorAuthenticationUpdateWithoutPasskeysInput>, MultiFactorAuthenticationUncheckedUpdateWithoutPasskeysInput>
  }

  export type UserCreateNestedOneWithoutRestrictionsInput = {
    create?: XOR<UserCreateWithoutRestrictionsInput, UserUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRestrictionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRestrictionReasonFieldUpdateOperationsInput = {
    set?: $Enums.RestrictionReason
  }

  export type EnumRestrictionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RestrictionStatus
  }

  export type UserUpdateOneRequiredWithoutRestrictionsNestedInput = {
    create?: XOR<UserCreateWithoutRestrictionsInput, UserUncheckedCreateWithoutRestrictionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRestrictionsInput
    upsert?: UserUpsertWithoutRestrictionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRestrictionsInput, UserUpdateWithoutRestrictionsInput>, UserUncheckedUpdateWithoutRestrictionsInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserPortalRoleCreateNestedManyWithoutPortalInput = {
    create?: XOR<UserPortalRoleCreateWithoutPortalInput, UserPortalRoleUncheckedCreateWithoutPortalInput> | UserPortalRoleCreateWithoutPortalInput[] | UserPortalRoleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutPortalInput | UserPortalRoleCreateOrConnectWithoutPortalInput[]
    createMany?: UserPortalRoleCreateManyPortalInputEnvelope
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutPortalInput = {
    create?: XOR<ClientCreateWithoutPortalInput, ClientUncheckedCreateWithoutPortalInput> | ClientCreateWithoutPortalInput[] | ClientUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutPortalInput | ClientCreateOrConnectWithoutPortalInput[]
    createMany?: ClientCreateManyPortalInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutPortalInput = {
    create?: XOR<LeadCreateWithoutPortalInput, LeadUncheckedCreateWithoutPortalInput> | LeadCreateWithoutPortalInput[] | LeadUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutPortalInput | LeadCreateOrConnectWithoutPortalInput[]
    createMany?: LeadCreateManyPortalInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutPortalInput = {
    create?: XOR<DealCreateWithoutPortalInput, DealUncheckedCreateWithoutPortalInput> | DealCreateWithoutPortalInput[] | DealUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPortalInput | DealCreateOrConnectWithoutPortalInput[]
    createMany?: DealCreateManyPortalInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPortalInput = {
    create?: XOR<AppointmentCreateWithoutPortalInput, AppointmentUncheckedCreateWithoutPortalInput> | AppointmentCreateWithoutPortalInput[] | AppointmentUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPortalInput | AppointmentCreateOrConnectWithoutPortalInput[]
    createMany?: AppointmentCreateManyPortalInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutPortalInput = {
    create?: XOR<ProductCreateWithoutPortalInput, ProductUncheckedCreateWithoutPortalInput> | ProductCreateWithoutPortalInput[] | ProductUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPortalInput | ProductCreateOrConnectWithoutPortalInput[]
    createMany?: ProductCreateManyPortalInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CustomFieldCreateNestedManyWithoutPortalInput = {
    create?: XOR<CustomFieldCreateWithoutPortalInput, CustomFieldUncheckedCreateWithoutPortalInput> | CustomFieldCreateWithoutPortalInput[] | CustomFieldUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutPortalInput | CustomFieldCreateOrConnectWithoutPortalInput[]
    createMany?: CustomFieldCreateManyPortalInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutPortalInput = {
    create?: XOR<AuditLogCreateWithoutPortalInput, AuditLogUncheckedCreateWithoutPortalInput> | AuditLogCreateWithoutPortalInput[] | AuditLogUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPortalInput | AuditLogCreateOrConnectWithoutPortalInput[]
    createMany?: AuditLogCreateManyPortalInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SeoKeywordCreateNestedManyWithoutPortalInput = {
    create?: XOR<SeoKeywordCreateWithoutPortalInput, SeoKeywordUncheckedCreateWithoutPortalInput> | SeoKeywordCreateWithoutPortalInput[] | SeoKeywordUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoKeywordCreateOrConnectWithoutPortalInput | SeoKeywordCreateOrConnectWithoutPortalInput[]
    createMany?: SeoKeywordCreateManyPortalInputEnvelope
    connect?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
  }

  export type SeoArticleCreateNestedManyWithoutPortalInput = {
    create?: XOR<SeoArticleCreateWithoutPortalInput, SeoArticleUncheckedCreateWithoutPortalInput> | SeoArticleCreateWithoutPortalInput[] | SeoArticleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoArticleCreateOrConnectWithoutPortalInput | SeoArticleCreateOrConnectWithoutPortalInput[]
    createMany?: SeoArticleCreateManyPortalInputEnvelope
    connect?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
  }

  export type SerpPositionCreateNestedManyWithoutPortalInput = {
    create?: XOR<SerpPositionCreateWithoutPortalInput, SerpPositionUncheckedCreateWithoutPortalInput> | SerpPositionCreateWithoutPortalInput[] | SerpPositionUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutPortalInput | SerpPositionCreateOrConnectWithoutPortalInput[]
    createMany?: SerpPositionCreateManyPortalInputEnvelope
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutPortalInput = {
    create?: XOR<IntegrationCreateWithoutPortalInput, IntegrationUncheckedCreateWithoutPortalInput> | IntegrationCreateWithoutPortalInput[] | IntegrationUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutPortalInput | IntegrationCreateOrConnectWithoutPortalInput[]
    createMany?: IntegrationCreateManyPortalInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<UserPortalRoleCreateWithoutPortalInput, UserPortalRoleUncheckedCreateWithoutPortalInput> | UserPortalRoleCreateWithoutPortalInput[] | UserPortalRoleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutPortalInput | UserPortalRoleCreateOrConnectWithoutPortalInput[]
    createMany?: UserPortalRoleCreateManyPortalInputEnvelope
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<ClientCreateWithoutPortalInput, ClientUncheckedCreateWithoutPortalInput> | ClientCreateWithoutPortalInput[] | ClientUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutPortalInput | ClientCreateOrConnectWithoutPortalInput[]
    createMany?: ClientCreateManyPortalInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<LeadCreateWithoutPortalInput, LeadUncheckedCreateWithoutPortalInput> | LeadCreateWithoutPortalInput[] | LeadUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutPortalInput | LeadCreateOrConnectWithoutPortalInput[]
    createMany?: LeadCreateManyPortalInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<DealCreateWithoutPortalInput, DealUncheckedCreateWithoutPortalInput> | DealCreateWithoutPortalInput[] | DealUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPortalInput | DealCreateOrConnectWithoutPortalInput[]
    createMany?: DealCreateManyPortalInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<AppointmentCreateWithoutPortalInput, AppointmentUncheckedCreateWithoutPortalInput> | AppointmentCreateWithoutPortalInput[] | AppointmentUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPortalInput | AppointmentCreateOrConnectWithoutPortalInput[]
    createMany?: AppointmentCreateManyPortalInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<ProductCreateWithoutPortalInput, ProductUncheckedCreateWithoutPortalInput> | ProductCreateWithoutPortalInput[] | ProductUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPortalInput | ProductCreateOrConnectWithoutPortalInput[]
    createMany?: ProductCreateManyPortalInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CustomFieldUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<CustomFieldCreateWithoutPortalInput, CustomFieldUncheckedCreateWithoutPortalInput> | CustomFieldCreateWithoutPortalInput[] | CustomFieldUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutPortalInput | CustomFieldCreateOrConnectWithoutPortalInput[]
    createMany?: CustomFieldCreateManyPortalInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<AuditLogCreateWithoutPortalInput, AuditLogUncheckedCreateWithoutPortalInput> | AuditLogCreateWithoutPortalInput[] | AuditLogUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPortalInput | AuditLogCreateOrConnectWithoutPortalInput[]
    createMany?: AuditLogCreateManyPortalInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type SeoKeywordUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<SeoKeywordCreateWithoutPortalInput, SeoKeywordUncheckedCreateWithoutPortalInput> | SeoKeywordCreateWithoutPortalInput[] | SeoKeywordUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoKeywordCreateOrConnectWithoutPortalInput | SeoKeywordCreateOrConnectWithoutPortalInput[]
    createMany?: SeoKeywordCreateManyPortalInputEnvelope
    connect?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
  }

  export type SeoArticleUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<SeoArticleCreateWithoutPortalInput, SeoArticleUncheckedCreateWithoutPortalInput> | SeoArticleCreateWithoutPortalInput[] | SeoArticleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoArticleCreateOrConnectWithoutPortalInput | SeoArticleCreateOrConnectWithoutPortalInput[]
    createMany?: SeoArticleCreateManyPortalInputEnvelope
    connect?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
  }

  export type SerpPositionUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<SerpPositionCreateWithoutPortalInput, SerpPositionUncheckedCreateWithoutPortalInput> | SerpPositionCreateWithoutPortalInput[] | SerpPositionUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutPortalInput | SerpPositionCreateOrConnectWithoutPortalInput[]
    createMany?: SerpPositionCreateManyPortalInputEnvelope
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutPortalInput = {
    create?: XOR<IntegrationCreateWithoutPortalInput, IntegrationUncheckedCreateWithoutPortalInput> | IntegrationCreateWithoutPortalInput[] | IntegrationUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutPortalInput | IntegrationCreateOrConnectWithoutPortalInput[]
    createMany?: IntegrationCreateManyPortalInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserPortalRoleUpdateManyWithoutPortalNestedInput = {
    create?: XOR<UserPortalRoleCreateWithoutPortalInput, UserPortalRoleUncheckedCreateWithoutPortalInput> | UserPortalRoleCreateWithoutPortalInput[] | UserPortalRoleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutPortalInput | UserPortalRoleCreateOrConnectWithoutPortalInput[]
    upsert?: UserPortalRoleUpsertWithWhereUniqueWithoutPortalInput | UserPortalRoleUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: UserPortalRoleCreateManyPortalInputEnvelope
    set?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    disconnect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    delete?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    update?: UserPortalRoleUpdateWithWhereUniqueWithoutPortalInput | UserPortalRoleUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: UserPortalRoleUpdateManyWithWhereWithoutPortalInput | UserPortalRoleUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: UserPortalRoleScalarWhereInput | UserPortalRoleScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutPortalNestedInput = {
    create?: XOR<ClientCreateWithoutPortalInput, ClientUncheckedCreateWithoutPortalInput> | ClientCreateWithoutPortalInput[] | ClientUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutPortalInput | ClientCreateOrConnectWithoutPortalInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutPortalInput | ClientUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: ClientCreateManyPortalInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutPortalInput | ClientUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutPortalInput | ClientUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutPortalNestedInput = {
    create?: XOR<LeadCreateWithoutPortalInput, LeadUncheckedCreateWithoutPortalInput> | LeadCreateWithoutPortalInput[] | LeadUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutPortalInput | LeadCreateOrConnectWithoutPortalInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutPortalInput | LeadUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: LeadCreateManyPortalInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutPortalInput | LeadUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutPortalInput | LeadUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUpdateManyWithoutPortalNestedInput = {
    create?: XOR<DealCreateWithoutPortalInput, DealUncheckedCreateWithoutPortalInput> | DealCreateWithoutPortalInput[] | DealUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPortalInput | DealCreateOrConnectWithoutPortalInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutPortalInput | DealUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: DealCreateManyPortalInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutPortalInput | DealUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: DealUpdateManyWithWhereWithoutPortalInput | DealUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPortalNestedInput = {
    create?: XOR<AppointmentCreateWithoutPortalInput, AppointmentUncheckedCreateWithoutPortalInput> | AppointmentCreateWithoutPortalInput[] | AppointmentUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPortalInput | AppointmentCreateOrConnectWithoutPortalInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPortalInput | AppointmentUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: AppointmentCreateManyPortalInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPortalInput | AppointmentUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPortalInput | AppointmentUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutPortalNestedInput = {
    create?: XOR<ProductCreateWithoutPortalInput, ProductUncheckedCreateWithoutPortalInput> | ProductCreateWithoutPortalInput[] | ProductUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPortalInput | ProductCreateOrConnectWithoutPortalInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPortalInput | ProductUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: ProductCreateManyPortalInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPortalInput | ProductUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPortalInput | ProductUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CustomFieldUpdateManyWithoutPortalNestedInput = {
    create?: XOR<CustomFieldCreateWithoutPortalInput, CustomFieldUncheckedCreateWithoutPortalInput> | CustomFieldCreateWithoutPortalInput[] | CustomFieldUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutPortalInput | CustomFieldCreateOrConnectWithoutPortalInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutPortalInput | CustomFieldUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: CustomFieldCreateManyPortalInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutPortalInput | CustomFieldUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutPortalInput | CustomFieldUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutPortalNestedInput = {
    create?: XOR<AuditLogCreateWithoutPortalInput, AuditLogUncheckedCreateWithoutPortalInput> | AuditLogCreateWithoutPortalInput[] | AuditLogUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPortalInput | AuditLogCreateOrConnectWithoutPortalInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutPortalInput | AuditLogUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: AuditLogCreateManyPortalInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutPortalInput | AuditLogUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutPortalInput | AuditLogUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SeoKeywordUpdateManyWithoutPortalNestedInput = {
    create?: XOR<SeoKeywordCreateWithoutPortalInput, SeoKeywordUncheckedCreateWithoutPortalInput> | SeoKeywordCreateWithoutPortalInput[] | SeoKeywordUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoKeywordCreateOrConnectWithoutPortalInput | SeoKeywordCreateOrConnectWithoutPortalInput[]
    upsert?: SeoKeywordUpsertWithWhereUniqueWithoutPortalInput | SeoKeywordUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: SeoKeywordCreateManyPortalInputEnvelope
    set?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    disconnect?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    delete?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    connect?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    update?: SeoKeywordUpdateWithWhereUniqueWithoutPortalInput | SeoKeywordUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: SeoKeywordUpdateManyWithWhereWithoutPortalInput | SeoKeywordUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: SeoKeywordScalarWhereInput | SeoKeywordScalarWhereInput[]
  }

  export type SeoArticleUpdateManyWithoutPortalNestedInput = {
    create?: XOR<SeoArticleCreateWithoutPortalInput, SeoArticleUncheckedCreateWithoutPortalInput> | SeoArticleCreateWithoutPortalInput[] | SeoArticleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoArticleCreateOrConnectWithoutPortalInput | SeoArticleCreateOrConnectWithoutPortalInput[]
    upsert?: SeoArticleUpsertWithWhereUniqueWithoutPortalInput | SeoArticleUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: SeoArticleCreateManyPortalInputEnvelope
    set?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    disconnect?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    delete?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    connect?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    update?: SeoArticleUpdateWithWhereUniqueWithoutPortalInput | SeoArticleUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: SeoArticleUpdateManyWithWhereWithoutPortalInput | SeoArticleUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: SeoArticleScalarWhereInput | SeoArticleScalarWhereInput[]
  }

  export type SerpPositionUpdateManyWithoutPortalNestedInput = {
    create?: XOR<SerpPositionCreateWithoutPortalInput, SerpPositionUncheckedCreateWithoutPortalInput> | SerpPositionCreateWithoutPortalInput[] | SerpPositionUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutPortalInput | SerpPositionCreateOrConnectWithoutPortalInput[]
    upsert?: SerpPositionUpsertWithWhereUniqueWithoutPortalInput | SerpPositionUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: SerpPositionCreateManyPortalInputEnvelope
    set?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    disconnect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    delete?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    update?: SerpPositionUpdateWithWhereUniqueWithoutPortalInput | SerpPositionUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: SerpPositionUpdateManyWithWhereWithoutPortalInput | SerpPositionUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: SerpPositionScalarWhereInput | SerpPositionScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutPortalNestedInput = {
    create?: XOR<IntegrationCreateWithoutPortalInput, IntegrationUncheckedCreateWithoutPortalInput> | IntegrationCreateWithoutPortalInput[] | IntegrationUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutPortalInput | IntegrationCreateOrConnectWithoutPortalInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutPortalInput | IntegrationUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: IntegrationCreateManyPortalInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutPortalInput | IntegrationUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutPortalInput | IntegrationUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<UserPortalRoleCreateWithoutPortalInput, UserPortalRoleUncheckedCreateWithoutPortalInput> | UserPortalRoleCreateWithoutPortalInput[] | UserPortalRoleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: UserPortalRoleCreateOrConnectWithoutPortalInput | UserPortalRoleCreateOrConnectWithoutPortalInput[]
    upsert?: UserPortalRoleUpsertWithWhereUniqueWithoutPortalInput | UserPortalRoleUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: UserPortalRoleCreateManyPortalInputEnvelope
    set?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    disconnect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    delete?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    connect?: UserPortalRoleWhereUniqueInput | UserPortalRoleWhereUniqueInput[]
    update?: UserPortalRoleUpdateWithWhereUniqueWithoutPortalInput | UserPortalRoleUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: UserPortalRoleUpdateManyWithWhereWithoutPortalInput | UserPortalRoleUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: UserPortalRoleScalarWhereInput | UserPortalRoleScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<ClientCreateWithoutPortalInput, ClientUncheckedCreateWithoutPortalInput> | ClientCreateWithoutPortalInput[] | ClientUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutPortalInput | ClientCreateOrConnectWithoutPortalInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutPortalInput | ClientUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: ClientCreateManyPortalInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutPortalInput | ClientUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutPortalInput | ClientUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<LeadCreateWithoutPortalInput, LeadUncheckedCreateWithoutPortalInput> | LeadCreateWithoutPortalInput[] | LeadUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutPortalInput | LeadCreateOrConnectWithoutPortalInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutPortalInput | LeadUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: LeadCreateManyPortalInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutPortalInput | LeadUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutPortalInput | LeadUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<DealCreateWithoutPortalInput, DealUncheckedCreateWithoutPortalInput> | DealCreateWithoutPortalInput[] | DealUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPortalInput | DealCreateOrConnectWithoutPortalInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutPortalInput | DealUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: DealCreateManyPortalInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutPortalInput | DealUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: DealUpdateManyWithWhereWithoutPortalInput | DealUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<AppointmentCreateWithoutPortalInput, AppointmentUncheckedCreateWithoutPortalInput> | AppointmentCreateWithoutPortalInput[] | AppointmentUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPortalInput | AppointmentCreateOrConnectWithoutPortalInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPortalInput | AppointmentUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: AppointmentCreateManyPortalInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPortalInput | AppointmentUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPortalInput | AppointmentUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<ProductCreateWithoutPortalInput, ProductUncheckedCreateWithoutPortalInput> | ProductCreateWithoutPortalInput[] | ProductUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutPortalInput | ProductCreateOrConnectWithoutPortalInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutPortalInput | ProductUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: ProductCreateManyPortalInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutPortalInput | ProductUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutPortalInput | ProductUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CustomFieldUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<CustomFieldCreateWithoutPortalInput, CustomFieldUncheckedCreateWithoutPortalInput> | CustomFieldCreateWithoutPortalInput[] | CustomFieldUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutPortalInput | CustomFieldCreateOrConnectWithoutPortalInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutPortalInput | CustomFieldUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: CustomFieldCreateManyPortalInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutPortalInput | CustomFieldUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutPortalInput | CustomFieldUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<AuditLogCreateWithoutPortalInput, AuditLogUncheckedCreateWithoutPortalInput> | AuditLogCreateWithoutPortalInput[] | AuditLogUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutPortalInput | AuditLogCreateOrConnectWithoutPortalInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutPortalInput | AuditLogUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: AuditLogCreateManyPortalInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutPortalInput | AuditLogUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutPortalInput | AuditLogUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<SeoKeywordCreateWithoutPortalInput, SeoKeywordUncheckedCreateWithoutPortalInput> | SeoKeywordCreateWithoutPortalInput[] | SeoKeywordUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoKeywordCreateOrConnectWithoutPortalInput | SeoKeywordCreateOrConnectWithoutPortalInput[]
    upsert?: SeoKeywordUpsertWithWhereUniqueWithoutPortalInput | SeoKeywordUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: SeoKeywordCreateManyPortalInputEnvelope
    set?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    disconnect?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    delete?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    connect?: SeoKeywordWhereUniqueInput | SeoKeywordWhereUniqueInput[]
    update?: SeoKeywordUpdateWithWhereUniqueWithoutPortalInput | SeoKeywordUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: SeoKeywordUpdateManyWithWhereWithoutPortalInput | SeoKeywordUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: SeoKeywordScalarWhereInput | SeoKeywordScalarWhereInput[]
  }

  export type SeoArticleUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<SeoArticleCreateWithoutPortalInput, SeoArticleUncheckedCreateWithoutPortalInput> | SeoArticleCreateWithoutPortalInput[] | SeoArticleUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SeoArticleCreateOrConnectWithoutPortalInput | SeoArticleCreateOrConnectWithoutPortalInput[]
    upsert?: SeoArticleUpsertWithWhereUniqueWithoutPortalInput | SeoArticleUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: SeoArticleCreateManyPortalInputEnvelope
    set?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    disconnect?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    delete?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    connect?: SeoArticleWhereUniqueInput | SeoArticleWhereUniqueInput[]
    update?: SeoArticleUpdateWithWhereUniqueWithoutPortalInput | SeoArticleUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: SeoArticleUpdateManyWithWhereWithoutPortalInput | SeoArticleUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: SeoArticleScalarWhereInput | SeoArticleScalarWhereInput[]
  }

  export type SerpPositionUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<SerpPositionCreateWithoutPortalInput, SerpPositionUncheckedCreateWithoutPortalInput> | SerpPositionCreateWithoutPortalInput[] | SerpPositionUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutPortalInput | SerpPositionCreateOrConnectWithoutPortalInput[]
    upsert?: SerpPositionUpsertWithWhereUniqueWithoutPortalInput | SerpPositionUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: SerpPositionCreateManyPortalInputEnvelope
    set?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    disconnect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    delete?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    update?: SerpPositionUpdateWithWhereUniqueWithoutPortalInput | SerpPositionUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: SerpPositionUpdateManyWithWhereWithoutPortalInput | SerpPositionUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: SerpPositionScalarWhereInput | SerpPositionScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutPortalNestedInput = {
    create?: XOR<IntegrationCreateWithoutPortalInput, IntegrationUncheckedCreateWithoutPortalInput> | IntegrationCreateWithoutPortalInput[] | IntegrationUncheckedCreateWithoutPortalInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutPortalInput | IntegrationCreateOrConnectWithoutPortalInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutPortalInput | IntegrationUpsertWithWhereUniqueWithoutPortalInput[]
    createMany?: IntegrationCreateManyPortalInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutPortalInput | IntegrationUpdateWithWhereUniqueWithoutPortalInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutPortalInput | IntegrationUpdateManyWithWhereWithoutPortalInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPortalRolesInput = {
    create?: XOR<UserCreateWithoutPortalRolesInput, UserUncheckedCreateWithoutPortalRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortalRolesInput
    connect?: UserWhereUniqueInput
  }

  export type PortalCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<PortalCreateWithoutUserRolesInput, PortalUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: PortalCreateOrConnectWithoutUserRolesInput
    connect?: PortalWhereUniqueInput
  }

  export type EnumPortalRoleFieldUpdateOperationsInput = {
    set?: $Enums.PortalRole
  }

  export type UserUpdateOneRequiredWithoutPortalRolesNestedInput = {
    create?: XOR<UserCreateWithoutPortalRolesInput, UserUncheckedCreateWithoutPortalRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPortalRolesInput
    upsert?: UserUpsertWithoutPortalRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPortalRolesInput, UserUpdateWithoutPortalRolesInput>, UserUncheckedUpdateWithoutPortalRolesInput>
  }

  export type PortalUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<PortalCreateWithoutUserRolesInput, PortalUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: PortalCreateOrConnectWithoutUserRolesInput
    upsert?: PortalUpsertWithoutUserRolesInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutUserRolesInput, PortalUpdateWithoutUserRolesInput>, PortalUncheckedUpdateWithoutUserRolesInput>
  }

  export type PortalCreateNestedOneWithoutClientsInput = {
    create?: XOR<PortalCreateWithoutClientsInput, PortalUncheckedCreateWithoutClientsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutClientsInput
    connect?: PortalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedClientsInput = {
    create?: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClientsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedManyWithoutClientInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutClientInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type PortalUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<PortalCreateWithoutClientsInput, PortalUncheckedCreateWithoutClientsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutClientsInput
    upsert?: PortalUpsertWithoutClientsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutClientsInput, PortalUpdateWithoutClientsInput>, PortalUncheckedUpdateWithoutClientsInput>
  }

  export type UserUpdateOneWithoutCreatedClientsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClientsInput
    upsert?: UserUpsertWithoutCreatedClientsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedClientsInput, UserUpdateWithoutCreatedClientsInput>, UserUncheckedUpdateWithoutCreatedClientsInput>
  }

  export type DealUpdateManyWithoutClientNestedInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutClientInput | DealUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutClientInput | DealUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DealUpdateManyWithWhereWithoutClientInput | DealUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClientInput | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClientInput | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClientInput | AppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput> | DealCreateWithoutClientInput[] | DealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DealCreateOrConnectWithoutClientInput | DealCreateOrConnectWithoutClientInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutClientInput | DealUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DealCreateManyClientInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutClientInput | DealUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DealUpdateManyWithWhereWithoutClientInput | DealUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClientInput | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClientInput | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClientInput | AppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PortalCreateNestedOneWithoutLeadsInput = {
    create?: XOR<PortalCreateWithoutLeadsInput, PortalUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutLeadsInput
    connect?: PortalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedLeadsInput = {
    create?: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedLeadsInput = {
    create?: XOR<UserCreateWithoutCreatedLeadsInput, UserUncheckedCreateWithoutCreatedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedManyWithoutLeadInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type EnumLeadSourceFieldUpdateOperationsInput = {
    set?: $Enums.LeadSource
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type PortalUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<PortalCreateWithoutLeadsInput, PortalUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutLeadsInput
    upsert?: PortalUpsertWithoutLeadsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutLeadsInput, PortalUpdateWithoutLeadsInput>, PortalUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateOneWithoutAssignedLeadsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedLeadsInput
    upsert?: UserUpsertWithoutAssignedLeadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedLeadsInput, UserUpdateWithoutAssignedLeadsInput>, UserUncheckedUpdateWithoutAssignedLeadsInput>
  }

  export type UserUpdateOneWithoutCreatedLeadsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLeadsInput, UserUncheckedCreateWithoutCreatedLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLeadsInput
    upsert?: UserUpsertWithoutCreatedLeadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLeadsInput, UserUpdateWithoutCreatedLeadsInput>, UserUncheckedUpdateWithoutCreatedLeadsInput>
  }

  export type DealUpdateManyWithoutLeadNestedInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutLeadInput | DealUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutLeadInput | DealUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: DealUpdateManyWithWhereWithoutLeadInput | DealUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutLeadInput | DealUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutLeadInput | DealUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: DealUpdateManyWithWhereWithoutLeadInput | DealUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type PortalCreateNestedOneWithoutDealsInput = {
    create?: XOR<PortalCreateWithoutDealsInput, PortalUncheckedCreateWithoutDealsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutDealsInput
    connect?: PortalWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutDealsInput = {
    create?: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDealsInput
    connect?: ClientWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutDealsInput = {
    create?: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealsInput
    connect?: LeadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedDealsInput = {
    create?: XOR<UserCreateWithoutAssignedDealsInput, UserUncheckedCreateWithoutAssignedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedDealsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedDealsInput = {
    create?: XOR<UserCreateWithoutCreatedDealsInput, UserUncheckedCreateWithoutCreatedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDealsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutDealInput = {
    create?: XOR<AppointmentCreateWithoutDealInput, AppointmentUncheckedCreateWithoutDealInput> | AppointmentCreateWithoutDealInput[] | AppointmentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDealInput | AppointmentCreateOrConnectWithoutDealInput[]
    createMany?: AppointmentCreateManyDealInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<AppointmentCreateWithoutDealInput, AppointmentUncheckedCreateWithoutDealInput> | AppointmentCreateWithoutDealInput[] | AppointmentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDealInput | AppointmentCreateOrConnectWithoutDealInput[]
    createMany?: AppointmentCreateManyDealInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PortalUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<PortalCreateWithoutDealsInput, PortalUncheckedCreateWithoutDealsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutDealsInput
    upsert?: PortalUpsertWithoutDealsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutDealsInput, PortalUpdateWithoutDealsInput>, PortalUncheckedUpdateWithoutDealsInput>
  }

  export type ClientUpdateOneWithoutDealsNestedInput = {
    create?: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDealsInput
    upsert?: ClientUpsertWithoutDealsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDealsInput, ClientUpdateWithoutDealsInput>, ClientUncheckedUpdateWithoutDealsInput>
  }

  export type LeadUpdateOneWithoutDealsNestedInput = {
    create?: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealsInput
    upsert?: LeadUpsertWithoutDealsInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutDealsInput, LeadUpdateWithoutDealsInput>, LeadUncheckedUpdateWithoutDealsInput>
  }

  export type UserUpdateOneWithoutAssignedDealsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedDealsInput, UserUncheckedCreateWithoutAssignedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedDealsInput
    upsert?: UserUpsertWithoutAssignedDealsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedDealsInput, UserUpdateWithoutAssignedDealsInput>, UserUncheckedUpdateWithoutAssignedDealsInput>
  }

  export type UserUpdateOneWithoutCreatedDealsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedDealsInput, UserUncheckedCreateWithoutCreatedDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDealsInput
    upsert?: UserUpsertWithoutCreatedDealsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedDealsInput, UserUpdateWithoutCreatedDealsInput>, UserUncheckedUpdateWithoutCreatedDealsInput>
  }

  export type AppointmentUpdateManyWithoutDealNestedInput = {
    create?: XOR<AppointmentCreateWithoutDealInput, AppointmentUncheckedCreateWithoutDealInput> | AppointmentCreateWithoutDealInput[] | AppointmentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDealInput | AppointmentCreateOrConnectWithoutDealInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDealInput | AppointmentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: AppointmentCreateManyDealInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDealInput | AppointmentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDealInput | AppointmentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<AppointmentCreateWithoutDealInput, AppointmentUncheckedCreateWithoutDealInput> | AppointmentCreateWithoutDealInput[] | AppointmentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDealInput | AppointmentCreateOrConnectWithoutDealInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDealInput | AppointmentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: AppointmentCreateManyDealInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDealInput | AppointmentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDealInput | AppointmentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PortalCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PortalCreateWithoutAppointmentsInput, PortalUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutAppointmentsInput
    connect?: PortalWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAppointmentsInput
    connect?: ClientWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DealCreateWithoutAppointmentsInput, DealUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutAppointmentsInput
    connect?: DealWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ProductCreateWithoutAppointmentsInput, ProductUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAppointmentsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type PortalUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PortalCreateWithoutAppointmentsInput, PortalUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutAppointmentsInput
    upsert?: PortalUpsertWithoutAppointmentsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutAppointmentsInput, PortalUpdateWithoutAppointmentsInput>, PortalUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAppointmentsInput
    upsert?: ClientUpsertWithoutAppointmentsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAppointmentsInput, ClientUpdateWithoutAppointmentsInput>, ClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DealUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<DealCreateWithoutAppointmentsInput, DealUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutAppointmentsInput
    upsert?: DealUpsertWithoutAppointmentsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutAppointmentsInput, DealUpdateWithoutAppointmentsInput>, DealUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProductUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<ProductCreateWithoutAppointmentsInput, ProductUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAppointmentsInput
    upsert?: ProductUpsertWithoutAppointmentsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAppointmentsInput, ProductUpdateWithoutAppointmentsInput>, ProductUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PortalCreateNestedOneWithoutProductsInput = {
    create?: XOR<PortalCreateWithoutProductsInput, PortalUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutProductsInput
    connect?: PortalWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutProductInput = {
    create?: XOR<AppointmentCreateWithoutProductInput, AppointmentUncheckedCreateWithoutProductInput> | AppointmentCreateWithoutProductInput[] | AppointmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProductInput | AppointmentCreateOrConnectWithoutProductInput[]
    createMany?: AppointmentCreateManyProductInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AppointmentCreateWithoutProductInput, AppointmentUncheckedCreateWithoutProductInput> | AppointmentCreateWithoutProductInput[] | AppointmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProductInput | AppointmentCreateOrConnectWithoutProductInput[]
    createMany?: AppointmentCreateManyProductInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PortalUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<PortalCreateWithoutProductsInput, PortalUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutProductsInput
    upsert?: PortalUpsertWithoutProductsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutProductsInput, PortalUpdateWithoutProductsInput>, PortalUncheckedUpdateWithoutProductsInput>
  }

  export type AppointmentUpdateManyWithoutProductNestedInput = {
    create?: XOR<AppointmentCreateWithoutProductInput, AppointmentUncheckedCreateWithoutProductInput> | AppointmentCreateWithoutProductInput[] | AppointmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProductInput | AppointmentCreateOrConnectWithoutProductInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProductInput | AppointmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AppointmentCreateManyProductInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProductInput | AppointmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProductInput | AppointmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AppointmentCreateWithoutProductInput, AppointmentUncheckedCreateWithoutProductInput> | AppointmentCreateWithoutProductInput[] | AppointmentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutProductInput | AppointmentCreateOrConnectWithoutProductInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutProductInput | AppointmentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AppointmentCreateManyProductInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutProductInput | AppointmentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutProductInput | AppointmentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type PortalCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<PortalCreateWithoutCustomFieldsInput, PortalUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutCustomFieldsInput
    connect?: PortalWhereUniqueInput
  }

  export type CustomFieldValueCreateNestedManyWithoutFieldInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type CustomFieldValueUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType
  }

  export type EnumFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.FieldType
  }

  export type PortalUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<PortalCreateWithoutCustomFieldsInput, PortalUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutCustomFieldsInput
    upsert?: PortalUpsertWithoutCustomFieldsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutCustomFieldsInput, PortalUpdateWithoutCustomFieldsInput>, PortalUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type CustomFieldValueUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput | CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput | CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutFieldInput | CustomFieldValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput> | CustomFieldValueCreateWithoutFieldInput[] | CustomFieldValueUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutFieldInput | CustomFieldValueCreateOrConnectWithoutFieldInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput | CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: CustomFieldValueCreateManyFieldInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput | CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutFieldInput | CustomFieldValueUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CustomFieldCreateNestedOneWithoutValuesInput = {
    create?: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutValuesInput
    connect?: CustomFieldWhereUniqueInput
  }

  export type CustomFieldUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutValuesInput
    upsert?: CustomFieldUpsertWithoutValuesInput
    connect?: CustomFieldWhereUniqueInput
    update?: XOR<XOR<CustomFieldUpdateToOneWithWhereWithoutValuesInput, CustomFieldUpdateWithoutValuesInput>, CustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type PortalCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<PortalCreateWithoutAuditLogsInput, PortalUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutAuditLogsInput
    connect?: PortalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type PortalUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<PortalCreateWithoutAuditLogsInput, PortalUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutAuditLogsInput
    upsert?: PortalUpsertWithoutAuditLogsInput
    disconnect?: PortalWhereInput | boolean
    delete?: PortalWhereInput | boolean
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutAuditLogsInput, PortalUpdateWithoutAuditLogsInput>, PortalUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type PortalCreateNestedOneWithoutSeoKeywordsInput = {
    create?: XOR<PortalCreateWithoutSeoKeywordsInput, PortalUncheckedCreateWithoutSeoKeywordsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutSeoKeywordsInput
    connect?: PortalWhereUniqueInput
  }

  export type SerpPositionCreateNestedManyWithoutKeywordInput = {
    create?: XOR<SerpPositionCreateWithoutKeywordInput, SerpPositionUncheckedCreateWithoutKeywordInput> | SerpPositionCreateWithoutKeywordInput[] | SerpPositionUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutKeywordInput | SerpPositionCreateOrConnectWithoutKeywordInput[]
    createMany?: SerpPositionCreateManyKeywordInputEnvelope
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
  }

  export type SerpPositionUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<SerpPositionCreateWithoutKeywordInput, SerpPositionUncheckedCreateWithoutKeywordInput> | SerpPositionCreateWithoutKeywordInput[] | SerpPositionUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutKeywordInput | SerpPositionCreateOrConnectWithoutKeywordInput[]
    createMany?: SerpPositionCreateManyKeywordInputEnvelope
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
  }

  export type PortalUpdateOneRequiredWithoutSeoKeywordsNestedInput = {
    create?: XOR<PortalCreateWithoutSeoKeywordsInput, PortalUncheckedCreateWithoutSeoKeywordsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutSeoKeywordsInput
    upsert?: PortalUpsertWithoutSeoKeywordsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutSeoKeywordsInput, PortalUpdateWithoutSeoKeywordsInput>, PortalUncheckedUpdateWithoutSeoKeywordsInput>
  }

  export type SerpPositionUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<SerpPositionCreateWithoutKeywordInput, SerpPositionUncheckedCreateWithoutKeywordInput> | SerpPositionCreateWithoutKeywordInput[] | SerpPositionUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutKeywordInput | SerpPositionCreateOrConnectWithoutKeywordInput[]
    upsert?: SerpPositionUpsertWithWhereUniqueWithoutKeywordInput | SerpPositionUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: SerpPositionCreateManyKeywordInputEnvelope
    set?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    disconnect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    delete?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    update?: SerpPositionUpdateWithWhereUniqueWithoutKeywordInput | SerpPositionUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: SerpPositionUpdateManyWithWhereWithoutKeywordInput | SerpPositionUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: SerpPositionScalarWhereInput | SerpPositionScalarWhereInput[]
  }

  export type SerpPositionUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<SerpPositionCreateWithoutKeywordInput, SerpPositionUncheckedCreateWithoutKeywordInput> | SerpPositionCreateWithoutKeywordInput[] | SerpPositionUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: SerpPositionCreateOrConnectWithoutKeywordInput | SerpPositionCreateOrConnectWithoutKeywordInput[]
    upsert?: SerpPositionUpsertWithWhereUniqueWithoutKeywordInput | SerpPositionUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: SerpPositionCreateManyKeywordInputEnvelope
    set?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    disconnect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    delete?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    connect?: SerpPositionWhereUniqueInput | SerpPositionWhereUniqueInput[]
    update?: SerpPositionUpdateWithWhereUniqueWithoutKeywordInput | SerpPositionUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: SerpPositionUpdateManyWithWhereWithoutKeywordInput | SerpPositionUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: SerpPositionScalarWhereInput | SerpPositionScalarWhereInput[]
  }

  export type PortalCreateNestedOneWithoutSeoArticlesInput = {
    create?: XOR<PortalCreateWithoutSeoArticlesInput, PortalUncheckedCreateWithoutSeoArticlesInput>
    connectOrCreate?: PortalCreateOrConnectWithoutSeoArticlesInput
    connect?: PortalWhereUniqueInput
  }

  export type PortalUpdateOneRequiredWithoutSeoArticlesNestedInput = {
    create?: XOR<PortalCreateWithoutSeoArticlesInput, PortalUncheckedCreateWithoutSeoArticlesInput>
    connectOrCreate?: PortalCreateOrConnectWithoutSeoArticlesInput
    upsert?: PortalUpsertWithoutSeoArticlesInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutSeoArticlesInput, PortalUpdateWithoutSeoArticlesInput>, PortalUncheckedUpdateWithoutSeoArticlesInput>
  }

  export type PortalCreateNestedOneWithoutSerpPositionsInput = {
    create?: XOR<PortalCreateWithoutSerpPositionsInput, PortalUncheckedCreateWithoutSerpPositionsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutSerpPositionsInput
    connect?: PortalWhereUniqueInput
  }

  export type SeoKeywordCreateNestedOneWithoutSerpPositionsInput = {
    create?: XOR<SeoKeywordCreateWithoutSerpPositionsInput, SeoKeywordUncheckedCreateWithoutSerpPositionsInput>
    connectOrCreate?: SeoKeywordCreateOrConnectWithoutSerpPositionsInput
    connect?: SeoKeywordWhereUniqueInput
  }

  export type PortalUpdateOneRequiredWithoutSerpPositionsNestedInput = {
    create?: XOR<PortalCreateWithoutSerpPositionsInput, PortalUncheckedCreateWithoutSerpPositionsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutSerpPositionsInput
    upsert?: PortalUpsertWithoutSerpPositionsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutSerpPositionsInput, PortalUpdateWithoutSerpPositionsInput>, PortalUncheckedUpdateWithoutSerpPositionsInput>
  }

  export type SeoKeywordUpdateOneRequiredWithoutSerpPositionsNestedInput = {
    create?: XOR<SeoKeywordCreateWithoutSerpPositionsInput, SeoKeywordUncheckedCreateWithoutSerpPositionsInput>
    connectOrCreate?: SeoKeywordCreateOrConnectWithoutSerpPositionsInput
    upsert?: SeoKeywordUpsertWithoutSerpPositionsInput
    connect?: SeoKeywordWhereUniqueInput
    update?: XOR<XOR<SeoKeywordUpdateToOneWithWhereWithoutSerpPositionsInput, SeoKeywordUpdateWithoutSerpPositionsInput>, SeoKeywordUncheckedUpdateWithoutSerpPositionsInput>
  }

  export type PortalCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<PortalCreateWithoutIntegrationsInput, PortalUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutIntegrationsInput
    connect?: PortalWhereUniqueInput
  }

  export type EnumIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationType
  }

  export type PortalUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<PortalCreateWithoutIntegrationsInput, PortalUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: PortalCreateOrConnectWithoutIntegrationsInput
    upsert?: PortalUpsertWithoutIntegrationsInput
    connect?: PortalWhereUniqueInput
    update?: XOR<XOR<PortalUpdateToOneWithWhereWithoutIntegrationsInput, PortalUpdateWithoutIntegrationsInput>, PortalUncheckedUpdateWithoutIntegrationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumAuthMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[]
    notIn?: $Enums.AuthMethod[]
    not?: NestedEnumAuthMethodFilter<$PrismaModel> | $Enums.AuthMethod
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuthMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[]
    notIn?: $Enums.AuthMethod[]
    not?: NestedEnumAuthMethodWithAggregatesFilter<$PrismaModel> | $Enums.AuthMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthMethodFilter<$PrismaModel>
    _max?: NestedEnumAuthMethodFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAccountProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountProvider | EnumAccountProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AccountProvider[]
    notIn?: $Enums.AccountProvider[]
    not?: NestedEnumAccountProviderFilter<$PrismaModel> | $Enums.AccountProvider
  }

  export type NestedEnumAccountProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountProvider | EnumAccountProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AccountProvider[]
    notIn?: $Enums.AccountProvider[]
    not?: NestedEnumAccountProviderWithAggregatesFilter<$PrismaModel> | $Enums.AccountProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountProviderFilter<$PrismaModel>
    _max?: NestedEnumAccountProviderFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEmailVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailVerificationStatus | EnumEmailVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailVerificationStatus[]
    notIn?: $Enums.EmailVerificationStatus[]
    not?: NestedEnumEmailVerificationStatusFilter<$PrismaModel> | $Enums.EmailVerificationStatus
  }

  export type NestedEnumEmailVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailVerificationStatus | EnumEmailVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailVerificationStatus[]
    notIn?: $Enums.EmailVerificationStatus[]
    not?: NestedEnumEmailVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTotpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TotpStatus | EnumTotpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TotpStatus[]
    notIn?: $Enums.TotpStatus[]
    not?: NestedEnumTotpStatusFilter<$PrismaModel> | $Enums.TotpStatus
  }

  export type NestedEnumTotpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TotpStatus | EnumTotpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TotpStatus[]
    notIn?: $Enums.TotpStatus[]
    not?: NestedEnumTotpStatusWithAggregatesFilter<$PrismaModel> | $Enums.TotpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTotpStatusFilter<$PrismaModel>
    _max?: NestedEnumTotpStatusFilter<$PrismaModel>
  }

  export type NestedEnumRestrictionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionReason | EnumRestrictionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionReason[]
    notIn?: $Enums.RestrictionReason[]
    not?: NestedEnumRestrictionReasonFilter<$PrismaModel> | $Enums.RestrictionReason
  }

  export type NestedEnumRestrictionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionStatus | EnumRestrictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionStatus[]
    notIn?: $Enums.RestrictionStatus[]
    not?: NestedEnumRestrictionStatusFilter<$PrismaModel> | $Enums.RestrictionStatus
  }

  export type NestedEnumRestrictionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionReason | EnumRestrictionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionReason[]
    notIn?: $Enums.RestrictionReason[]
    not?: NestedEnumRestrictionReasonWithAggregatesFilter<$PrismaModel> | $Enums.RestrictionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRestrictionReasonFilter<$PrismaModel>
    _max?: NestedEnumRestrictionReasonFilter<$PrismaModel>
  }

  export type NestedEnumRestrictionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RestrictionStatus | EnumRestrictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RestrictionStatus[]
    notIn?: $Enums.RestrictionStatus[]
    not?: NestedEnumRestrictionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RestrictionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRestrictionStatusFilter<$PrismaModel>
    _max?: NestedEnumRestrictionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPortalRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PortalRole | EnumPortalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PortalRole[]
    notIn?: $Enums.PortalRole[]
    not?: NestedEnumPortalRoleFilter<$PrismaModel> | $Enums.PortalRole
  }

  export type NestedEnumPortalRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PortalRole | EnumPortalRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PortalRole[]
    notIn?: $Enums.PortalRole[]
    not?: NestedEnumPortalRoleWithAggregatesFilter<$PrismaModel> | $Enums.PortalRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPortalRoleFilter<$PrismaModel>
    _max?: NestedEnumPortalRoleFilter<$PrismaModel>
  }

  export type NestedEnumLeadSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[]
    notIn?: $Enums.LeadSource[]
    not?: NestedEnumLeadSourceFilter<$PrismaModel> | $Enums.LeadSource
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[]
    notIn?: $Enums.LeadStatus[]
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadSource | EnumLeadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.LeadSource[]
    notIn?: $Enums.LeadSource[]
    not?: NestedEnumLeadSourceWithAggregatesFilter<$PrismaModel> | $Enums.LeadSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadSourceFilter<$PrismaModel>
    _max?: NestedEnumLeadSourceFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[]
    notIn?: $Enums.LeadStatus[]
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[]
    notIn?: $Enums.AppointmentStatus[]
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[]
    notIn?: $Enums.EntityType[]
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type NestedEnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[]
    notIn?: $Enums.EntityType[]
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[]
    notIn?: $Enums.FieldType[]
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type NestedEnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[]
    notIn?: $Enums.IntegrationType[]
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[]
    notIn?: $Enums.IntegrationType[]
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PasswordResetCreateWithoutUserInput = {
    id?: string
    token: string
    expiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type ExternalAccountCreateWithoutUserInput = {
    id?: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiry?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiry?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalAccountCreateOrConnectWithoutUserInput = {
    where: ExternalAccountWhereUniqueInput
    create: XOR<ExternalAccountCreateWithoutUserInput, ExternalAccountUncheckedCreateWithoutUserInput>
  }

  export type ExternalAccountCreateManyUserInputEnvelope = {
    data: ExternalAccountCreateManyUserInput | ExternalAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MultiFactorAuthenticationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyCreateNestedManyWithoutMfaInput
    totp?: TotpCreateNestedOneWithoutMfaInput
  }

  export type MultiFactorAuthenticationUncheckedCreateWithoutUserInput = {
    id?: string
    totpId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutMfaInput
  }

  export type MultiFactorAuthenticationCreateOrConnectWithoutUserInput = {
    where: MultiFactorAuthenticationWhereUniqueInput
    create: XOR<MultiFactorAuthenticationCreateWithoutUserInput, MultiFactorAuthenticationUncheckedCreateWithoutUserInput>
  }

  export type RestrictionCreateWithoutUserInput = {
    id?: string
    reason: $Enums.RestrictionReason
    until?: Date | string | null
    status?: $Enums.RestrictionStatus
    createdAt?: Date | string
  }

  export type RestrictionUncheckedCreateWithoutUserInput = {
    id?: string
    reason: $Enums.RestrictionReason
    until?: Date | string | null
    status?: $Enums.RestrictionStatus
    createdAt?: Date | string
  }

  export type RestrictionCreateOrConnectWithoutUserInput = {
    where: RestrictionWhereUniqueInput
    create: XOR<RestrictionCreateWithoutUserInput, RestrictionUncheckedCreateWithoutUserInput>
  }

  export type RestrictionCreateManyUserInputEnvelope = {
    data: RestrictionCreateManyUserInput | RestrictionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailVerificationCreateWithoutUserInput = {
    id?: string
    token: string
    expiry?: Date | string | null
    status?: $Enums.EmailVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiry?: Date | string | null
    status?: $Enums.EmailVerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailVerificationCreateOrConnectWithoutUserInput = {
    where: EmailVerificationWhereUniqueInput
    create: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
  }

  export type UserPortalRoleCreateWithoutUserInput = {
    id?: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutUserRolesInput
  }

  export type UserPortalRoleUncheckedCreateWithoutUserInput = {
    id?: string
    portalId: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPortalRoleCreateOrConnectWithoutUserInput = {
    where: UserPortalRoleWhereUniqueInput
    create: XOR<UserPortalRoleCreateWithoutUserInput, UserPortalRoleUncheckedCreateWithoutUserInput>
  }

  export type UserPortalRoleCreateManyUserInputEnvelope = {
    data: UserPortalRoleCreateManyUserInput | UserPortalRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutCreatedByInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutClientsInput
    deals?: DealCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCreatedByInput = {
    id?: string
    portalId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCreatedByInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput>
  }

  export type ClientCreateManyCreatedByInputEnvelope = {
    data: ClientCreateManyCreatedByInput | ClientCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutAssignedToInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutLeadsInput
    createdBy?: UserCreateNestedOneWithoutCreatedLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutAssignedToInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutAssignedToInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput>
  }

  export type LeadCreateManyAssignedToInputEnvelope = {
    data: LeadCreateManyAssignedToInput | LeadCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutCreatedByInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutCreatedByInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCreatedByInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCreatedByInput, LeadUncheckedCreateWithoutCreatedByInput>
  }

  export type LeadCreateManyCreatedByInputEnvelope = {
    data: LeadCreateManyCreatedByInput | LeadCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutAssignedToInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutDealsInput
    client?: ClientCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    createdBy?: UserCreateNestedOneWithoutCreatedDealsInput
    appointments?: AppointmentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutAssignedToInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    createdById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutAssignedToInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutAssignedToInput, DealUncheckedCreateWithoutAssignedToInput>
  }

  export type DealCreateManyAssignedToInputEnvelope = {
    data: DealCreateManyAssignedToInput | DealCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutCreatedByInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutDealsInput
    client?: ClientCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDealsInput
    appointments?: AppointmentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutCreatedByInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutCreatedByInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutCreatedByInput, DealUncheckedCreateWithoutCreatedByInput>
  }

  export type DealCreateManyCreatedByInputEnvelope = {
    data: DealCreateManyCreatedByInput | DealCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutAppointmentsInput
    client?: ClientCreateNestedOneWithoutAppointmentsInput
    deal?: DealCreateNestedOneWithoutAppointmentsInput
    product?: ProductCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutAssignedToInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    productId?: string | null
  }

  export type AppointmentCreateOrConnectWithoutAssignedToInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutAssignedToInput, AppointmentUncheckedCreateWithoutAssignedToInput>
  }

  export type AppointmentCreateManyAssignedToInputEnvelope = {
    data: AppointmentCreateManyAssignedToInput | AppointmentCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    portal?: PortalCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    portalId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetUpsertWithoutUserInput = {
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
    where?: PasswordResetWhereInput
  }

  export type PasswordResetUpdateToOneWithWhereWithoutUserInput = {
    where?: PasswordResetWhereInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: ExternalAccountWhereUniqueInput
    update: XOR<ExternalAccountUpdateWithoutUserInput, ExternalAccountUncheckedUpdateWithoutUserInput>
    create: XOR<ExternalAccountCreateWithoutUserInput, ExternalAccountUncheckedCreateWithoutUserInput>
  }

  export type ExternalAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: ExternalAccountWhereUniqueInput
    data: XOR<ExternalAccountUpdateWithoutUserInput, ExternalAccountUncheckedUpdateWithoutUserInput>
  }

  export type ExternalAccountUpdateManyWithWhereWithoutUserInput = {
    where: ExternalAccountScalarWhereInput
    data: XOR<ExternalAccountUpdateManyMutationInput, ExternalAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type ExternalAccountScalarWhereInput = {
    AND?: ExternalAccountScalarWhereInput | ExternalAccountScalarWhereInput[]
    OR?: ExternalAccountScalarWhereInput[]
    NOT?: ExternalAccountScalarWhereInput | ExternalAccountScalarWhereInput[]
    id?: StringFilter<"ExternalAccount"> | string
    provider?: EnumAccountProviderFilter<"ExternalAccount"> | $Enums.AccountProvider
    providerAccountId?: StringFilter<"ExternalAccount"> | string
    refreshToken?: StringNullableFilter<"ExternalAccount"> | string | null
    accessToken?: StringNullableFilter<"ExternalAccount"> | string | null
    expiry?: IntNullableFilter<"ExternalAccount"> | number | null
    userId?: StringFilter<"ExternalAccount"> | string
    createdAt?: DateTimeFilter<"ExternalAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalAccount"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    edited?: BoolFilter<"Comment"> | boolean
    deleted?: BoolFilter<"Comment"> | boolean
    authorId?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type MultiFactorAuthenticationUpsertWithoutUserInput = {
    update: XOR<MultiFactorAuthenticationUpdateWithoutUserInput, MultiFactorAuthenticationUncheckedUpdateWithoutUserInput>
    create: XOR<MultiFactorAuthenticationCreateWithoutUserInput, MultiFactorAuthenticationUncheckedCreateWithoutUserInput>
    where?: MultiFactorAuthenticationWhereInput
  }

  export type MultiFactorAuthenticationUpdateToOneWithWhereWithoutUserInput = {
    where?: MultiFactorAuthenticationWhereInput
    data: XOR<MultiFactorAuthenticationUpdateWithoutUserInput, MultiFactorAuthenticationUncheckedUpdateWithoutUserInput>
  }

  export type MultiFactorAuthenticationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUpdateManyWithoutMfaNestedInput
    totp?: TotpUpdateOneWithoutMfaNestedInput
  }

  export type MultiFactorAuthenticationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totpId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUncheckedUpdateManyWithoutMfaNestedInput
  }

  export type RestrictionUpsertWithWhereUniqueWithoutUserInput = {
    where: RestrictionWhereUniqueInput
    update: XOR<RestrictionUpdateWithoutUserInput, RestrictionUncheckedUpdateWithoutUserInput>
    create: XOR<RestrictionCreateWithoutUserInput, RestrictionUncheckedCreateWithoutUserInput>
  }

  export type RestrictionUpdateWithWhereUniqueWithoutUserInput = {
    where: RestrictionWhereUniqueInput
    data: XOR<RestrictionUpdateWithoutUserInput, RestrictionUncheckedUpdateWithoutUserInput>
  }

  export type RestrictionUpdateManyWithWhereWithoutUserInput = {
    where: RestrictionScalarWhereInput
    data: XOR<RestrictionUpdateManyMutationInput, RestrictionUncheckedUpdateManyWithoutUserInput>
  }

  export type RestrictionScalarWhereInput = {
    AND?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
    OR?: RestrictionScalarWhereInput[]
    NOT?: RestrictionScalarWhereInput | RestrictionScalarWhereInput[]
    id?: StringFilter<"Restriction"> | string
    reason?: EnumRestrictionReasonFilter<"Restriction"> | $Enums.RestrictionReason
    until?: DateTimeNullableFilter<"Restriction"> | Date | string | null
    status?: EnumRestrictionStatusFilter<"Restriction"> | $Enums.RestrictionStatus
    userId?: StringFilter<"Restriction"> | string
    createdAt?: DateTimeFilter<"Restriction"> | Date | string
  }

  export type EmailVerificationUpsertWithoutUserInput = {
    update: XOR<EmailVerificationUpdateWithoutUserInput, EmailVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    where?: EmailVerificationWhereInput
  }

  export type EmailVerificationUpdateToOneWithWhereWithoutUserInput = {
    where?: EmailVerificationWhereInput
    data: XOR<EmailVerificationUpdateWithoutUserInput, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmailVerificationStatusFieldUpdateOperationsInput | $Enums.EmailVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmailVerificationStatusFieldUpdateOperationsInput | $Enums.EmailVerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPortalRoleWhereUniqueInput
    update: XOR<UserPortalRoleUpdateWithoutUserInput, UserPortalRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserPortalRoleCreateWithoutUserInput, UserPortalRoleUncheckedCreateWithoutUserInput>
  }

  export type UserPortalRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPortalRoleWhereUniqueInput
    data: XOR<UserPortalRoleUpdateWithoutUserInput, UserPortalRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserPortalRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserPortalRoleScalarWhereInput
    data: XOR<UserPortalRoleUpdateManyMutationInput, UserPortalRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPortalRoleScalarWhereInput = {
    AND?: UserPortalRoleScalarWhereInput | UserPortalRoleScalarWhereInput[]
    OR?: UserPortalRoleScalarWhereInput[]
    NOT?: UserPortalRoleScalarWhereInput | UserPortalRoleScalarWhereInput[]
    id?: StringFilter<"UserPortalRole"> | string
    userId?: StringFilter<"UserPortalRole"> | string
    portalId?: StringFilter<"UserPortalRole"> | string
    role?: EnumPortalRoleFilter<"UserPortalRole"> | $Enums.PortalRole
    createdAt?: DateTimeFilter<"UserPortalRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserPortalRole"> | Date | string
  }

  export type ClientUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutCreatedByInput, ClientUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ClientCreateWithoutCreatedByInput, ClientUncheckedCreateWithoutCreatedByInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutCreatedByInput, ClientUncheckedUpdateWithoutCreatedByInput>
  }

  export type ClientUpdateManyWithWhereWithoutCreatedByInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    portalId?: StringFilter<"Client"> | string
    firstName?: StringNullableFilter<"Client"> | string | null
    lastName?: StringNullableFilter<"Client"> | string | null
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    avatar?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    metadata?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    createdById?: StringNullableFilter<"Client"> | string | null
  }

  export type LeadUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutAssignedToInput, LeadUncheckedUpdateWithoutAssignedToInput>
    create: XOR<LeadCreateWithoutAssignedToInput, LeadUncheckedCreateWithoutAssignedToInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutAssignedToInput, LeadUncheckedUpdateWithoutAssignedToInput>
  }

  export type LeadUpdateManyWithWhereWithoutAssignedToInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    portalId?: StringFilter<"Lead"> | string
    source?: EnumLeadSourceFilter<"Lead"> | $Enums.LeadSource
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    firstName?: StringNullableFilter<"Lead"> | string | null
    lastName?: StringNullableFilter<"Lead"> | string | null
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    metadata?: JsonNullableFilter<"Lead">
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    assignedToId?: StringNullableFilter<"Lead"> | string | null
    createdById?: StringNullableFilter<"Lead"> | string | null
  }

  export type LeadUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutCreatedByInput, LeadUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LeadCreateWithoutCreatedByInput, LeadUncheckedCreateWithoutCreatedByInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutCreatedByInput, LeadUncheckedUpdateWithoutCreatedByInput>
  }

  export type LeadUpdateManyWithWhereWithoutCreatedByInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DealUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutAssignedToInput, DealUncheckedUpdateWithoutAssignedToInput>
    create: XOR<DealCreateWithoutAssignedToInput, DealUncheckedCreateWithoutAssignedToInput>
  }

  export type DealUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutAssignedToInput, DealUncheckedUpdateWithoutAssignedToInput>
  }

  export type DealUpdateManyWithWhereWithoutAssignedToInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    portalId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    stage?: StringFilter<"Deal"> | string
    value?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Deal"> | string
    probability?: IntNullableFilter<"Deal"> | number | null
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    notes?: StringNullableFilter<"Deal"> | string | null
    metadata?: JsonNullableFilter<"Deal">
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    clientId?: StringNullableFilter<"Deal"> | string | null
    leadId?: StringNullableFilter<"Deal"> | string | null
    assignedToId?: StringNullableFilter<"Deal"> | string | null
    createdById?: StringNullableFilter<"Deal"> | string | null
  }

  export type DealUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutCreatedByInput, DealUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DealCreateWithoutCreatedByInput, DealUncheckedCreateWithoutCreatedByInput>
  }

  export type DealUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutCreatedByInput, DealUncheckedUpdateWithoutCreatedByInput>
  }

  export type DealUpdateManyWithWhereWithoutCreatedByInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutAssignedToInput, AppointmentUncheckedUpdateWithoutAssignedToInput>
    create: XOR<AppointmentCreateWithoutAssignedToInput, AppointmentUncheckedCreateWithoutAssignedToInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutAssignedToInput, AppointmentUncheckedUpdateWithoutAssignedToInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutAssignedToInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    portalId?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableFilter<"Appointment"> | string | null
    googleCalendarEventId?: StringNullableFilter<"Appointment"> | string | null
    reminderSent?: BoolFilter<"Appointment"> | boolean
    metadata?: JsonNullableFilter<"Appointment">
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    clientId?: StringNullableFilter<"Appointment"> | string | null
    dealId?: StringNullableFilter<"Appointment"> | string | null
    productId?: StringNullableFilter<"Appointment"> | string | null
    assignedToId?: StringNullableFilter<"Appointment"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    portalId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutExternalAccountsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExternalAccountsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExternalAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExternalAccountsInput, UserUncheckedCreateWithoutExternalAccountsInput>
  }

  export type UserUpsertWithoutExternalAccountsInput = {
    update: XOR<UserUpdateWithoutExternalAccountsInput, UserUncheckedUpdateWithoutExternalAccountsInput>
    create: XOR<UserCreateWithoutExternalAccountsInput, UserUncheckedCreateWithoutExternalAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExternalAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExternalAccountsInput, UserUncheckedUpdateWithoutExternalAccountsInput>
  }

  export type UserUpdateWithoutExternalAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExternalAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEmailVerificationInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailVerificationInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
  }

  export type UserUpsertWithoutEmailVerificationInput = {
    update: XOR<UserUpdateWithoutEmailVerificationInput, UserUncheckedUpdateWithoutEmailVerificationInput>
    create: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailVerificationInput, UserUncheckedUpdateWithoutEmailVerificationInput>
  }

  export type UserUpdateWithoutEmailVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
  }

  export type UserUpsertWithoutPasswordResetInput = {
    update: XOR<UserUpdateWithoutPasswordResetInput, UserUncheckedUpdateWithoutPasswordResetInput>
    create: XOR<UserCreateWithoutPasswordResetInput, UserUncheckedCreateWithoutPasswordResetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetInput, UserUncheckedUpdateWithoutPasswordResetInput>
  }

  export type UserUpdateWithoutPasswordResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PasskeyCreateWithoutMfaInput = {
    id?: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter?: number
    lastUsedAt?: Date | string | null
    ip: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasskeyUncheckedCreateWithoutMfaInput = {
    id?: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter?: number
    lastUsedAt?: Date | string | null
    ip: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasskeyCreateOrConnectWithoutMfaInput = {
    where: PasskeyWhereUniqueInput
    create: XOR<PasskeyCreateWithoutMfaInput, PasskeyUncheckedCreateWithoutMfaInput>
  }

  export type PasskeyCreateManyMfaInputEnvelope = {
    data: PasskeyCreateManyMfaInput | PasskeyCreateManyMfaInput[]
    skipDuplicates?: boolean
  }

  export type TotpCreateWithoutMfaInput = {
    id?: string
    status?: $Enums.TotpStatus
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotpUncheckedCreateWithoutMfaInput = {
    id?: string
    status?: $Enums.TotpStatus
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotpCreateOrConnectWithoutMfaInput = {
    where: TotpWhereUniqueInput
    create: XOR<TotpCreateWithoutMfaInput, TotpUncheckedCreateWithoutMfaInput>
  }

  export type UserCreateWithoutMfaInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMfaInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMfaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMfaInput, UserUncheckedCreateWithoutMfaInput>
  }

  export type PasskeyUpsertWithWhereUniqueWithoutMfaInput = {
    where: PasskeyWhereUniqueInput
    update: XOR<PasskeyUpdateWithoutMfaInput, PasskeyUncheckedUpdateWithoutMfaInput>
    create: XOR<PasskeyCreateWithoutMfaInput, PasskeyUncheckedCreateWithoutMfaInput>
  }

  export type PasskeyUpdateWithWhereUniqueWithoutMfaInput = {
    where: PasskeyWhereUniqueInput
    data: XOR<PasskeyUpdateWithoutMfaInput, PasskeyUncheckedUpdateWithoutMfaInput>
  }

  export type PasskeyUpdateManyWithWhereWithoutMfaInput = {
    where: PasskeyScalarWhereInput
    data: XOR<PasskeyUpdateManyMutationInput, PasskeyUncheckedUpdateManyWithoutMfaInput>
  }

  export type PasskeyScalarWhereInput = {
    AND?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
    OR?: PasskeyScalarWhereInput[]
    NOT?: PasskeyScalarWhereInput | PasskeyScalarWhereInput[]
    id?: StringFilter<"Passkey"> | string
    deviceName?: StringFilter<"Passkey"> | string
    credentialId?: StringFilter<"Passkey"> | string
    publicKey?: StringFilter<"Passkey"> | string
    counter?: IntFilter<"Passkey"> | number
    lastUsedAt?: DateTimeNullableFilter<"Passkey"> | Date | string | null
    ip?: StringFilter<"Passkey"> | string
    userAgent?: StringFilter<"Passkey"> | string
    mfaId?: StringFilter<"Passkey"> | string
    createdAt?: DateTimeFilter<"Passkey"> | Date | string
    updatedAt?: DateTimeFilter<"Passkey"> | Date | string
  }

  export type TotpUpsertWithoutMfaInput = {
    update: XOR<TotpUpdateWithoutMfaInput, TotpUncheckedUpdateWithoutMfaInput>
    create: XOR<TotpCreateWithoutMfaInput, TotpUncheckedCreateWithoutMfaInput>
    where?: TotpWhereInput
  }

  export type TotpUpdateToOneWithWhereWithoutMfaInput = {
    where?: TotpWhereInput
    data: XOR<TotpUpdateWithoutMfaInput, TotpUncheckedUpdateWithoutMfaInput>
  }

  export type TotpUpdateWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTotpStatusFieldUpdateOperationsInput | $Enums.TotpStatus
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotpUncheckedUpdateWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTotpStatusFieldUpdateOperationsInput | $Enums.TotpStatus
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMfaInput = {
    update: XOR<UserUpdateWithoutMfaInput, UserUncheckedUpdateWithoutMfaInput>
    create: XOR<UserCreateWithoutMfaInput, UserUncheckedCreateWithoutMfaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMfaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMfaInput, UserUncheckedUpdateWithoutMfaInput>
  }

  export type UserUpdateWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MultiFactorAuthenticationCreateWithoutTotpInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyCreateNestedManyWithoutMfaInput
    user: UserCreateNestedOneWithoutMfaInput
  }

  export type MultiFactorAuthenticationUncheckedCreateWithoutTotpInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    passkeys?: PasskeyUncheckedCreateNestedManyWithoutMfaInput
  }

  export type MultiFactorAuthenticationCreateOrConnectWithoutTotpInput = {
    where: MultiFactorAuthenticationWhereUniqueInput
    create: XOR<MultiFactorAuthenticationCreateWithoutTotpInput, MultiFactorAuthenticationUncheckedCreateWithoutTotpInput>
  }

  export type MultiFactorAuthenticationUpsertWithoutTotpInput = {
    update: XOR<MultiFactorAuthenticationUpdateWithoutTotpInput, MultiFactorAuthenticationUncheckedUpdateWithoutTotpInput>
    create: XOR<MultiFactorAuthenticationCreateWithoutTotpInput, MultiFactorAuthenticationUncheckedCreateWithoutTotpInput>
    where?: MultiFactorAuthenticationWhereInput
  }

  export type MultiFactorAuthenticationUpdateToOneWithWhereWithoutTotpInput = {
    where?: MultiFactorAuthenticationWhereInput
    data: XOR<MultiFactorAuthenticationUpdateWithoutTotpInput, MultiFactorAuthenticationUncheckedUpdateWithoutTotpInput>
  }

  export type MultiFactorAuthenticationUpdateWithoutTotpInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUpdateManyWithoutMfaNestedInput
    user?: UserUpdateOneRequiredWithoutMfaNestedInput
  }

  export type MultiFactorAuthenticationUncheckedUpdateWithoutTotpInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passkeys?: PasskeyUncheckedUpdateManyWithoutMfaNestedInput
  }

  export type MultiFactorAuthenticationCreateWithoutPasskeysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totp?: TotpCreateNestedOneWithoutMfaInput
    user: UserCreateNestedOneWithoutMfaInput
  }

  export type MultiFactorAuthenticationUncheckedCreateWithoutPasskeysInput = {
    id?: string
    totpId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultiFactorAuthenticationCreateOrConnectWithoutPasskeysInput = {
    where: MultiFactorAuthenticationWhereUniqueInput
    create: XOR<MultiFactorAuthenticationCreateWithoutPasskeysInput, MultiFactorAuthenticationUncheckedCreateWithoutPasskeysInput>
  }

  export type MultiFactorAuthenticationUpsertWithoutPasskeysInput = {
    update: XOR<MultiFactorAuthenticationUpdateWithoutPasskeysInput, MultiFactorAuthenticationUncheckedUpdateWithoutPasskeysInput>
    create: XOR<MultiFactorAuthenticationCreateWithoutPasskeysInput, MultiFactorAuthenticationUncheckedCreateWithoutPasskeysInput>
    where?: MultiFactorAuthenticationWhereInput
  }

  export type MultiFactorAuthenticationUpdateToOneWithWhereWithoutPasskeysInput = {
    where?: MultiFactorAuthenticationWhereInput
    data: XOR<MultiFactorAuthenticationUpdateWithoutPasskeysInput, MultiFactorAuthenticationUncheckedUpdateWithoutPasskeysInput>
  }

  export type MultiFactorAuthenticationUpdateWithoutPasskeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totp?: TotpUpdateOneWithoutMfaNestedInput
    user?: UserUpdateOneRequiredWithoutMfaNestedInput
  }

  export type MultiFactorAuthenticationUncheckedUpdateWithoutPasskeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    totpId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRestrictionsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRestrictionsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRestrictionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRestrictionsInput, UserUncheckedCreateWithoutRestrictionsInput>
  }

  export type UserUpsertWithoutRestrictionsInput = {
    update: XOR<UserUpdateWithoutRestrictionsInput, UserUncheckedUpdateWithoutRestrictionsInput>
    create: XOR<UserCreateWithoutRestrictionsInput, UserUncheckedCreateWithoutRestrictionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRestrictionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRestrictionsInput, UserUncheckedUpdateWithoutRestrictionsInput>
  }

  export type UserUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    title: string
    slug: string
    thumbnail?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    slug: string
    thumbnail?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleCreateWithoutPortalInput = {
    id?: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPortalRolesInput
  }

  export type UserPortalRoleUncheckedCreateWithoutPortalInput = {
    id?: string
    userId: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPortalRoleCreateOrConnectWithoutPortalInput = {
    where: UserPortalRoleWhereUniqueInput
    create: XOR<UserPortalRoleCreateWithoutPortalInput, UserPortalRoleUncheckedCreateWithoutPortalInput>
  }

  export type UserPortalRoleCreateManyPortalInputEnvelope = {
    data: UserPortalRoleCreateManyPortalInput | UserPortalRoleCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutPortalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    deals?: DealCreateNestedManyWithoutClientInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPortalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPortalInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPortalInput, ClientUncheckedCreateWithoutPortalInput>
  }

  export type ClientCreateManyPortalInputEnvelope = {
    data: ClientCreateManyPortalInput | ClientCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutPortalInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    createdBy?: UserCreateNestedOneWithoutCreatedLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutPortalInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    createdById?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutPortalInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutPortalInput, LeadUncheckedCreateWithoutPortalInput>
  }

  export type LeadCreateManyPortalInputEnvelope = {
    data: LeadCreateManyPortalInput | LeadCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutPortalInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDealsInput
    createdBy?: UserCreateNestedOneWithoutCreatedDealsInput
    appointments?: AppointmentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutPortalInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutPortalInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutPortalInput, DealUncheckedCreateWithoutPortalInput>
  }

  export type DealCreateManyPortalInputEnvelope = {
    data: DealCreateManyPortalInput | DealCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutPortalInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutAppointmentsInput
    deal?: DealCreateNestedOneWithoutAppointmentsInput
    product?: ProductCreateNestedOneWithoutAppointmentsInput
    assignedTo?: UserCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPortalInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentCreateOrConnectWithoutPortalInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPortalInput, AppointmentUncheckedCreateWithoutPortalInput>
  }

  export type AppointmentCreateManyPortalInputEnvelope = {
    data: AppointmentCreateManyPortalInput | AppointmentCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutPortalInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPortalInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPortalInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPortalInput, ProductUncheckedCreateWithoutPortalInput>
  }

  export type ProductCreateManyPortalInputEnvelope = {
    data: ProductCreateManyPortalInput | ProductCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type CustomFieldCreateWithoutPortalInput = {
    id?: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: CustomFieldValueCreateNestedManyWithoutFieldInput
  }

  export type CustomFieldUncheckedCreateWithoutPortalInput = {
    id?: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    values?: CustomFieldValueUncheckedCreateNestedManyWithoutFieldInput
  }

  export type CustomFieldCreateOrConnectWithoutPortalInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutPortalInput, CustomFieldUncheckedCreateWithoutPortalInput>
  }

  export type CustomFieldCreateManyPortalInputEnvelope = {
    data: CustomFieldCreateManyPortalInput | CustomFieldCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutPortalInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutPortalInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutPortalInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutPortalInput, AuditLogUncheckedCreateWithoutPortalInput>
  }

  export type AuditLogCreateManyPortalInputEnvelope = {
    data: AuditLogCreateManyPortalInput | AuditLogCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type SeoKeywordCreateWithoutPortalInput = {
    id?: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serpPositions?: SerpPositionCreateNestedManyWithoutKeywordInput
  }

  export type SeoKeywordUncheckedCreateWithoutPortalInput = {
    id?: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type SeoKeywordCreateOrConnectWithoutPortalInput = {
    where: SeoKeywordWhereUniqueInput
    create: XOR<SeoKeywordCreateWithoutPortalInput, SeoKeywordUncheckedCreateWithoutPortalInput>
  }

  export type SeoKeywordCreateManyPortalInputEnvelope = {
    data: SeoKeywordCreateManyPortalInput | SeoKeywordCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type SeoArticleCreateWithoutPortalInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    language?: string
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: string | null
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoArticleUncheckedCreateWithoutPortalInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    language?: string
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: string | null
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoArticleCreateOrConnectWithoutPortalInput = {
    where: SeoArticleWhereUniqueInput
    create: XOR<SeoArticleCreateWithoutPortalInput, SeoArticleUncheckedCreateWithoutPortalInput>
  }

  export type SeoArticleCreateManyPortalInputEnvelope = {
    data: SeoArticleCreateManyPortalInput | SeoArticleCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type SerpPositionCreateWithoutPortalInput = {
    id?: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
    keyword: SeoKeywordCreateNestedOneWithoutSerpPositionsInput
  }

  export type SerpPositionUncheckedCreateWithoutPortalInput = {
    id?: string
    keywordId: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
  }

  export type SerpPositionCreateOrConnectWithoutPortalInput = {
    where: SerpPositionWhereUniqueInput
    create: XOR<SerpPositionCreateWithoutPortalInput, SerpPositionUncheckedCreateWithoutPortalInput>
  }

  export type SerpPositionCreateManyPortalInputEnvelope = {
    data: SerpPositionCreateManyPortalInput | SerpPositionCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutPortalInput = {
    id?: string
    type: $Enums.IntegrationType
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutPortalInput = {
    id?: string
    type: $Enums.IntegrationType
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutPortalInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutPortalInput, IntegrationUncheckedCreateWithoutPortalInput>
  }

  export type IntegrationCreateManyPortalInputEnvelope = {
    data: IntegrationCreateManyPortalInput | IntegrationCreateManyPortalInput[]
    skipDuplicates?: boolean
  }

  export type UserPortalRoleUpsertWithWhereUniqueWithoutPortalInput = {
    where: UserPortalRoleWhereUniqueInput
    update: XOR<UserPortalRoleUpdateWithoutPortalInput, UserPortalRoleUncheckedUpdateWithoutPortalInput>
    create: XOR<UserPortalRoleCreateWithoutPortalInput, UserPortalRoleUncheckedCreateWithoutPortalInput>
  }

  export type UserPortalRoleUpdateWithWhereUniqueWithoutPortalInput = {
    where: UserPortalRoleWhereUniqueInput
    data: XOR<UserPortalRoleUpdateWithoutPortalInput, UserPortalRoleUncheckedUpdateWithoutPortalInput>
  }

  export type UserPortalRoleUpdateManyWithWhereWithoutPortalInput = {
    where: UserPortalRoleScalarWhereInput
    data: XOR<UserPortalRoleUpdateManyMutationInput, UserPortalRoleUncheckedUpdateManyWithoutPortalInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutPortalInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutPortalInput, ClientUncheckedUpdateWithoutPortalInput>
    create: XOR<ClientCreateWithoutPortalInput, ClientUncheckedCreateWithoutPortalInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutPortalInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutPortalInput, ClientUncheckedUpdateWithoutPortalInput>
  }

  export type ClientUpdateManyWithWhereWithoutPortalInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutPortalInput>
  }

  export type LeadUpsertWithWhereUniqueWithoutPortalInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutPortalInput, LeadUncheckedUpdateWithoutPortalInput>
    create: XOR<LeadCreateWithoutPortalInput, LeadUncheckedCreateWithoutPortalInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutPortalInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutPortalInput, LeadUncheckedUpdateWithoutPortalInput>
  }

  export type LeadUpdateManyWithWhereWithoutPortalInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutPortalInput>
  }

  export type DealUpsertWithWhereUniqueWithoutPortalInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutPortalInput, DealUncheckedUpdateWithoutPortalInput>
    create: XOR<DealCreateWithoutPortalInput, DealUncheckedCreateWithoutPortalInput>
  }

  export type DealUpdateWithWhereUniqueWithoutPortalInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutPortalInput, DealUncheckedUpdateWithoutPortalInput>
  }

  export type DealUpdateManyWithWhereWithoutPortalInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutPortalInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPortalInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPortalInput, AppointmentUncheckedUpdateWithoutPortalInput>
    create: XOR<AppointmentCreateWithoutPortalInput, AppointmentUncheckedCreateWithoutPortalInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPortalInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPortalInput, AppointmentUncheckedUpdateWithoutPortalInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPortalInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPortalInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutPortalInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutPortalInput, ProductUncheckedUpdateWithoutPortalInput>
    create: XOR<ProductCreateWithoutPortalInput, ProductUncheckedCreateWithoutPortalInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutPortalInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutPortalInput, ProductUncheckedUpdateWithoutPortalInput>
  }

  export type ProductUpdateManyWithWhereWithoutPortalInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutPortalInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    portalId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    category?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Product"> | string
    duration?: IntNullableFilter<"Product"> | number | null
    portfolio?: JsonNullableFilter<"Product">
    isActive?: BoolFilter<"Product"> | boolean
    metadata?: JsonNullableFilter<"Product">
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type CustomFieldUpsertWithWhereUniqueWithoutPortalInput = {
    where: CustomFieldWhereUniqueInput
    update: XOR<CustomFieldUpdateWithoutPortalInput, CustomFieldUncheckedUpdateWithoutPortalInput>
    create: XOR<CustomFieldCreateWithoutPortalInput, CustomFieldUncheckedCreateWithoutPortalInput>
  }

  export type CustomFieldUpdateWithWhereUniqueWithoutPortalInput = {
    where: CustomFieldWhereUniqueInput
    data: XOR<CustomFieldUpdateWithoutPortalInput, CustomFieldUncheckedUpdateWithoutPortalInput>
  }

  export type CustomFieldUpdateManyWithWhereWithoutPortalInput = {
    where: CustomFieldScalarWhereInput
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyWithoutPortalInput>
  }

  export type CustomFieldScalarWhereInput = {
    AND?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    OR?: CustomFieldScalarWhereInput[]
    NOT?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    id?: StringFilter<"CustomField"> | string
    portalId?: StringFilter<"CustomField"> | string
    entityType?: EnumEntityTypeFilter<"CustomField"> | $Enums.EntityType
    name?: StringFilter<"CustomField"> | string
    fieldType?: EnumFieldTypeFilter<"CustomField"> | $Enums.FieldType
    config?: JsonNullableFilter<"CustomField">
    isRequired?: BoolFilter<"CustomField"> | boolean
    order?: IntFilter<"CustomField"> | number
    createdAt?: DateTimeFilter<"CustomField"> | Date | string
    updatedAt?: DateTimeFilter<"CustomField"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutPortalInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutPortalInput, AuditLogUncheckedUpdateWithoutPortalInput>
    create: XOR<AuditLogCreateWithoutPortalInput, AuditLogUncheckedCreateWithoutPortalInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutPortalInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutPortalInput, AuditLogUncheckedUpdateWithoutPortalInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutPortalInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutPortalInput>
  }

  export type SeoKeywordUpsertWithWhereUniqueWithoutPortalInput = {
    where: SeoKeywordWhereUniqueInput
    update: XOR<SeoKeywordUpdateWithoutPortalInput, SeoKeywordUncheckedUpdateWithoutPortalInput>
    create: XOR<SeoKeywordCreateWithoutPortalInput, SeoKeywordUncheckedCreateWithoutPortalInput>
  }

  export type SeoKeywordUpdateWithWhereUniqueWithoutPortalInput = {
    where: SeoKeywordWhereUniqueInput
    data: XOR<SeoKeywordUpdateWithoutPortalInput, SeoKeywordUncheckedUpdateWithoutPortalInput>
  }

  export type SeoKeywordUpdateManyWithWhereWithoutPortalInput = {
    where: SeoKeywordScalarWhereInput
    data: XOR<SeoKeywordUpdateManyMutationInput, SeoKeywordUncheckedUpdateManyWithoutPortalInput>
  }

  export type SeoKeywordScalarWhereInput = {
    AND?: SeoKeywordScalarWhereInput | SeoKeywordScalarWhereInput[]
    OR?: SeoKeywordScalarWhereInput[]
    NOT?: SeoKeywordScalarWhereInput | SeoKeywordScalarWhereInput[]
    id?: StringFilter<"SeoKeyword"> | string
    portalId?: StringFilter<"SeoKeyword"> | string
    keyword?: StringFilter<"SeoKeyword"> | string
    language?: StringFilter<"SeoKeyword"> | string
    volume?: IntNullableFilter<"SeoKeyword"> | number | null
    difficulty?: IntNullableFilter<"SeoKeyword"> | number | null
    createdAt?: DateTimeFilter<"SeoKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SeoKeyword"> | Date | string
  }

  export type SeoArticleUpsertWithWhereUniqueWithoutPortalInput = {
    where: SeoArticleWhereUniqueInput
    update: XOR<SeoArticleUpdateWithoutPortalInput, SeoArticleUncheckedUpdateWithoutPortalInput>
    create: XOR<SeoArticleCreateWithoutPortalInput, SeoArticleUncheckedCreateWithoutPortalInput>
  }

  export type SeoArticleUpdateWithWhereUniqueWithoutPortalInput = {
    where: SeoArticleWhereUniqueInput
    data: XOR<SeoArticleUpdateWithoutPortalInput, SeoArticleUncheckedUpdateWithoutPortalInput>
  }

  export type SeoArticleUpdateManyWithWhereWithoutPortalInput = {
    where: SeoArticleScalarWhereInput
    data: XOR<SeoArticleUpdateManyMutationInput, SeoArticleUncheckedUpdateManyWithoutPortalInput>
  }

  export type SeoArticleScalarWhereInput = {
    AND?: SeoArticleScalarWhereInput | SeoArticleScalarWhereInput[]
    OR?: SeoArticleScalarWhereInput[]
    NOT?: SeoArticleScalarWhereInput | SeoArticleScalarWhereInput[]
    id?: StringFilter<"SeoArticle"> | string
    portalId?: StringFilter<"SeoArticle"> | string
    title?: StringFilter<"SeoArticle"> | string
    slug?: StringFilter<"SeoArticle"> | string
    content?: StringFilter<"SeoArticle"> | string
    excerpt?: StringNullableFilter<"SeoArticle"> | string | null
    language?: StringFilter<"SeoArticle"> | string
    metaTitle?: StringNullableFilter<"SeoArticle"> | string | null
    metaDescription?: StringNullableFilter<"SeoArticle"> | string | null
    keywords?: JsonNullableFilter<"SeoArticle">
    faqSchema?: JsonNullableFilter<"SeoArticle">
    ogImage?: StringNullableFilter<"SeoArticle"> | string | null
    isPublished?: BoolFilter<"SeoArticle"> | boolean
    aiGenerated?: BoolFilter<"SeoArticle"> | boolean
    createdAt?: DateTimeFilter<"SeoArticle"> | Date | string
    updatedAt?: DateTimeFilter<"SeoArticle"> | Date | string
  }

  export type SerpPositionUpsertWithWhereUniqueWithoutPortalInput = {
    where: SerpPositionWhereUniqueInput
    update: XOR<SerpPositionUpdateWithoutPortalInput, SerpPositionUncheckedUpdateWithoutPortalInput>
    create: XOR<SerpPositionCreateWithoutPortalInput, SerpPositionUncheckedCreateWithoutPortalInput>
  }

  export type SerpPositionUpdateWithWhereUniqueWithoutPortalInput = {
    where: SerpPositionWhereUniqueInput
    data: XOR<SerpPositionUpdateWithoutPortalInput, SerpPositionUncheckedUpdateWithoutPortalInput>
  }

  export type SerpPositionUpdateManyWithWhereWithoutPortalInput = {
    where: SerpPositionScalarWhereInput
    data: XOR<SerpPositionUpdateManyMutationInput, SerpPositionUncheckedUpdateManyWithoutPortalInput>
  }

  export type SerpPositionScalarWhereInput = {
    AND?: SerpPositionScalarWhereInput | SerpPositionScalarWhereInput[]
    OR?: SerpPositionScalarWhereInput[]
    NOT?: SerpPositionScalarWhereInput | SerpPositionScalarWhereInput[]
    id?: StringFilter<"SerpPosition"> | string
    portalId?: StringFilter<"SerpPosition"> | string
    keywordId?: StringFilter<"SerpPosition"> | string
    position?: IntNullableFilter<"SerpPosition"> | number | null
    url?: StringNullableFilter<"SerpPosition"> | string | null
    searchEngine?: StringFilter<"SerpPosition"> | string
    country?: StringNullableFilter<"SerpPosition"> | string | null
    createdAt?: DateTimeFilter<"SerpPosition"> | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutPortalInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutPortalInput, IntegrationUncheckedUpdateWithoutPortalInput>
    create: XOR<IntegrationCreateWithoutPortalInput, IntegrationUncheckedCreateWithoutPortalInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutPortalInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutPortalInput, IntegrationUncheckedUpdateWithoutPortalInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutPortalInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutPortalInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    portalId?: StringFilter<"Integration"> | string
    type?: EnumIntegrationTypeFilter<"Integration"> | $Enums.IntegrationType
    config?: JsonFilter<"Integration">
    isActive?: BoolFilter<"Integration"> | boolean
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type UserCreateWithoutPortalRolesInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPortalRolesInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPortalRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPortalRolesInput, UserUncheckedCreateWithoutPortalRolesInput>
  }

  export type PortalCreateWithoutUserRolesInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutUserRolesInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutUserRolesInput, PortalUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutPortalRolesInput = {
    update: XOR<UserUpdateWithoutPortalRolesInput, UserUncheckedUpdateWithoutPortalRolesInput>
    create: XOR<UserCreateWithoutPortalRolesInput, UserUncheckedCreateWithoutPortalRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPortalRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPortalRolesInput, UserUncheckedUpdateWithoutPortalRolesInput>
  }

  export type UserUpdateWithoutPortalRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPortalRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PortalUpsertWithoutUserRolesInput = {
    update: XOR<PortalUpdateWithoutUserRolesInput, PortalUncheckedUpdateWithoutUserRolesInput>
    create: XOR<PortalCreateWithoutUserRolesInput, PortalUncheckedCreateWithoutUserRolesInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutUserRolesInput, PortalUncheckedUpdateWithoutUserRolesInput>
  }

  export type PortalUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type PortalCreateWithoutClientsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutClientsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutClientsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutClientsInput, PortalUncheckedCreateWithoutClientsInput>
  }

  export type UserCreateWithoutCreatedClientsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedClientsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
  }

  export type DealCreateWithoutClientInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDealsInput
    createdBy?: UserCreateNestedOneWithoutCreatedDealsInput
    appointments?: AppointmentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutClientInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutClientInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput>
  }

  export type DealCreateManyClientInputEnvelope = {
    data: DealCreateManyClientInput | DealCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutClientInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutAppointmentsInput
    deal?: DealCreateNestedOneWithoutAppointmentsInput
    product?: ProductCreateNestedOneWithoutAppointmentsInput
    assignedTo?: UserCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutClientInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentCreateOrConnectWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput>
  }

  export type AppointmentCreateManyClientInputEnvelope = {
    data: AppointmentCreateManyClientInput | AppointmentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PortalUpsertWithoutClientsInput = {
    update: XOR<PortalUpdateWithoutClientsInput, PortalUncheckedUpdateWithoutClientsInput>
    create: XOR<PortalCreateWithoutClientsInput, PortalUncheckedCreateWithoutClientsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutClientsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutClientsInput, PortalUncheckedUpdateWithoutClientsInput>
  }

  export type PortalUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type UserUpsertWithoutCreatedClientsInput = {
    update: XOR<UserUpdateWithoutCreatedClientsInput, UserUncheckedUpdateWithoutCreatedClientsInput>
    create: XOR<UserCreateWithoutCreatedClientsInput, UserUncheckedCreateWithoutCreatedClientsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedClientsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedClientsInput, UserUncheckedUpdateWithoutCreatedClientsInput>
  }

  export type UserUpdateWithoutCreatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithWhereUniqueWithoutClientInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutClientInput, DealUncheckedUpdateWithoutClientInput>
    create: XOR<DealCreateWithoutClientInput, DealUncheckedCreateWithoutClientInput>
  }

  export type DealUpdateWithWhereUniqueWithoutClientInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutClientInput, DealUncheckedUpdateWithoutClientInput>
  }

  export type DealUpdateManyWithWhereWithoutClientInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutClientInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutClientInput, AppointmentUncheckedUpdateWithoutClientInput>
    create: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutClientInput, AppointmentUncheckedUpdateWithoutClientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutClientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutClientInput>
  }

  export type PortalCreateWithoutLeadsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutLeadsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutLeadsInput, PortalUncheckedCreateWithoutLeadsInput>
  }

  export type UserCreateWithoutAssignedLeadsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedLeadsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
  }

  export type UserCreateWithoutCreatedLeadsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedLeadsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLeadsInput, UserUncheckedCreateWithoutCreatedLeadsInput>
  }

  export type DealCreateWithoutLeadInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutDealsInput
    client?: ClientCreateNestedOneWithoutDealsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDealsInput
    createdBy?: UserCreateNestedOneWithoutCreatedDealsInput
    appointments?: AppointmentCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutLeadInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    assignedToId?: string | null
    createdById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutLeadInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
  }

  export type DealCreateManyLeadInputEnvelope = {
    data: DealCreateManyLeadInput | DealCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type PortalUpsertWithoutLeadsInput = {
    update: XOR<PortalUpdateWithoutLeadsInput, PortalUncheckedUpdateWithoutLeadsInput>
    create: XOR<PortalCreateWithoutLeadsInput, PortalUncheckedCreateWithoutLeadsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutLeadsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutLeadsInput, PortalUncheckedUpdateWithoutLeadsInput>
  }

  export type PortalUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type UserUpsertWithoutAssignedLeadsInput = {
    update: XOR<UserUpdateWithoutAssignedLeadsInput, UserUncheckedUpdateWithoutAssignedLeadsInput>
    create: XOR<UserCreateWithoutAssignedLeadsInput, UserUncheckedCreateWithoutAssignedLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedLeadsInput, UserUncheckedUpdateWithoutAssignedLeadsInput>
  }

  export type UserUpdateWithoutAssignedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedLeadsInput = {
    update: XOR<UserUpdateWithoutCreatedLeadsInput, UserUncheckedUpdateWithoutCreatedLeadsInput>
    create: XOR<UserCreateWithoutCreatedLeadsInput, UserUncheckedCreateWithoutCreatedLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLeadsInput, UserUncheckedUpdateWithoutCreatedLeadsInput>
  }

  export type UserUpdateWithoutCreatedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithWhereUniqueWithoutLeadInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutLeadInput, DealUncheckedUpdateWithoutLeadInput>
    create: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
  }

  export type DealUpdateWithWhereUniqueWithoutLeadInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutLeadInput, DealUncheckedUpdateWithoutLeadInput>
  }

  export type DealUpdateManyWithWhereWithoutLeadInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutLeadInput>
  }

  export type PortalCreateWithoutDealsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutDealsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutDealsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutDealsInput, PortalUncheckedCreateWithoutDealsInput>
  }

  export type ClientCreateWithoutDealsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutClientsInput
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutDealsInput = {
    id?: string
    portalId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutDealsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
  }

  export type LeadCreateWithoutDealsInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutLeadsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedLeadsInput
    createdBy?: UserCreateNestedOneWithoutCreatedLeadsInput
  }

  export type LeadUncheckedCreateWithoutDealsInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    createdById?: string | null
  }

  export type LeadCreateOrConnectWithoutDealsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
  }

  export type UserCreateWithoutAssignedDealsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedDealsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedDealsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedDealsInput, UserUncheckedCreateWithoutAssignedDealsInput>
  }

  export type UserCreateWithoutCreatedDealsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedDealsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedDealsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedDealsInput, UserUncheckedCreateWithoutCreatedDealsInput>
  }

  export type AppointmentCreateWithoutDealInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutAppointmentsInput
    client?: ClientCreateNestedOneWithoutAppointmentsInput
    product?: ProductCreateNestedOneWithoutAppointmentsInput
    assignedTo?: UserCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutDealInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentCreateOrConnectWithoutDealInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDealInput, AppointmentUncheckedCreateWithoutDealInput>
  }

  export type AppointmentCreateManyDealInputEnvelope = {
    data: AppointmentCreateManyDealInput | AppointmentCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type PortalUpsertWithoutDealsInput = {
    update: XOR<PortalUpdateWithoutDealsInput, PortalUncheckedUpdateWithoutDealsInput>
    create: XOR<PortalCreateWithoutDealsInput, PortalUncheckedCreateWithoutDealsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutDealsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutDealsInput, PortalUncheckedUpdateWithoutDealsInput>
  }

  export type PortalUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type ClientUpsertWithoutDealsInput = {
    update: XOR<ClientUpdateWithoutDealsInput, ClientUncheckedUpdateWithoutDealsInput>
    create: XOR<ClientCreateWithoutDealsInput, ClientUncheckedCreateWithoutDealsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDealsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDealsInput, ClientUncheckedUpdateWithoutDealsInput>
  }

  export type ClientUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutClientsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LeadUpsertWithoutDealsInput = {
    update: XOR<LeadUpdateWithoutDealsInput, LeadUncheckedUpdateWithoutDealsInput>
    create: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutDealsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutDealsInput, LeadUncheckedUpdateWithoutDealsInput>
  }

  export type LeadUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutAssignedDealsInput = {
    update: XOR<UserUpdateWithoutAssignedDealsInput, UserUncheckedUpdateWithoutAssignedDealsInput>
    create: XOR<UserCreateWithoutAssignedDealsInput, UserUncheckedCreateWithoutAssignedDealsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedDealsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedDealsInput, UserUncheckedUpdateWithoutAssignedDealsInput>
  }

  export type UserUpdateWithoutAssignedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedDealsInput = {
    update: XOR<UserUpdateWithoutCreatedDealsInput, UserUncheckedUpdateWithoutCreatedDealsInput>
    create: XOR<UserCreateWithoutCreatedDealsInput, UserUncheckedCreateWithoutCreatedDealsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedDealsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedDealsInput, UserUncheckedUpdateWithoutCreatedDealsInput>
  }

  export type UserUpdateWithoutCreatedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDealInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDealInput, AppointmentUncheckedUpdateWithoutDealInput>
    create: XOR<AppointmentCreateWithoutDealInput, AppointmentUncheckedCreateWithoutDealInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDealInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDealInput, AppointmentUncheckedUpdateWithoutDealInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDealInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDealInput>
  }

  export type PortalCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutAppointmentsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutAppointmentsInput, PortalUncheckedCreateWithoutAppointmentsInput>
  }

  export type ClientCreateWithoutAppointmentsInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutClientsInput
    createdBy?: UserCreateNestedOneWithoutCreatedClientsInput
    deals?: DealCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    portalId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    deals?: DealUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAppointmentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
  }

  export type DealCreateWithoutAppointmentsInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutDealsInput
    client?: ClientCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    assignedTo?: UserCreateNestedOneWithoutAssignedDealsInput
    createdBy?: UserCreateNestedOneWithoutCreatedDealsInput
  }

  export type DealUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
  }

  export type DealCreateOrConnectWithoutAppointmentsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutAppointmentsInput, DealUncheckedCreateWithoutAppointmentsInput>
  }

  export type ProductCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    portalId: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutAppointmentsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAppointmentsInput, ProductUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type PortalUpsertWithoutAppointmentsInput = {
    update: XOR<PortalUpdateWithoutAppointmentsInput, PortalUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PortalCreateWithoutAppointmentsInput, PortalUncheckedCreateWithoutAppointmentsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutAppointmentsInput, PortalUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PortalUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type ClientUpsertWithoutAppointmentsInput = {
    update: XOR<ClientUpdateWithoutAppointmentsInput, ClientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAppointmentsInput, ClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutClientsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DealUpsertWithoutAppointmentsInput = {
    update: XOR<DealUpdateWithoutAppointmentsInput, DealUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DealCreateWithoutAppointmentsInput, DealUncheckedCreateWithoutAppointmentsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutAppointmentsInput, DealUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DealUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDealsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedDealsNestedInput
  }

  export type DealUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutAppointmentsInput = {
    update: XOR<ProductUpdateWithoutAppointmentsInput, ProductUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ProductCreateWithoutAppointmentsInput, ProductUncheckedCreateWithoutAppointmentsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAppointmentsInput, ProductUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ProductUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PortalCreateWithoutProductsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutProductsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutProductsInput, PortalUncheckedCreateWithoutProductsInput>
  }

  export type AppointmentCreateWithoutProductInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutAppointmentsInput
    client?: ClientCreateNestedOneWithoutAppointmentsInput
    deal?: DealCreateNestedOneWithoutAppointmentsInput
    assignedTo?: UserCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutProductInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentCreateOrConnectWithoutProductInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutProductInput, AppointmentUncheckedCreateWithoutProductInput>
  }

  export type AppointmentCreateManyProductInputEnvelope = {
    data: AppointmentCreateManyProductInput | AppointmentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PortalUpsertWithoutProductsInput = {
    update: XOR<PortalUpdateWithoutProductsInput, PortalUncheckedUpdateWithoutProductsInput>
    create: XOR<PortalCreateWithoutProductsInput, PortalUncheckedCreateWithoutProductsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutProductsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutProductsInput, PortalUncheckedUpdateWithoutProductsInput>
  }

  export type PortalUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutProductInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutProductInput, AppointmentUncheckedUpdateWithoutProductInput>
    create: XOR<AppointmentCreateWithoutProductInput, AppointmentUncheckedCreateWithoutProductInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutProductInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutProductInput, AppointmentUncheckedUpdateWithoutProductInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutProductInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutProductInput>
  }

  export type PortalCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutCustomFieldsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutCustomFieldsInput, PortalUncheckedCreateWithoutCustomFieldsInput>
  }

  export type CustomFieldValueCreateWithoutFieldInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldValueUncheckedCreateWithoutFieldInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldValueCreateOrConnectWithoutFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    create: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput>
  }

  export type CustomFieldValueCreateManyFieldInputEnvelope = {
    data: CustomFieldValueCreateManyFieldInput | CustomFieldValueCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type PortalUpsertWithoutCustomFieldsInput = {
    update: XOR<PortalUpdateWithoutCustomFieldsInput, PortalUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<PortalCreateWithoutCustomFieldsInput, PortalUncheckedCreateWithoutCustomFieldsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutCustomFieldsInput, PortalUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type PortalUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type CustomFieldValueUpsertWithWhereUniqueWithoutFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    update: XOR<CustomFieldValueUpdateWithoutFieldInput, CustomFieldValueUncheckedUpdateWithoutFieldInput>
    create: XOR<CustomFieldValueCreateWithoutFieldInput, CustomFieldValueUncheckedCreateWithoutFieldInput>
  }

  export type CustomFieldValueUpdateWithWhereUniqueWithoutFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    data: XOR<CustomFieldValueUpdateWithoutFieldInput, CustomFieldValueUncheckedUpdateWithoutFieldInput>
  }

  export type CustomFieldValueUpdateManyWithWhereWithoutFieldInput = {
    where: CustomFieldValueScalarWhereInput
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyWithoutFieldInput>
  }

  export type CustomFieldValueScalarWhereInput = {
    AND?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
    OR?: CustomFieldValueScalarWhereInput[]
    NOT?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
    id?: StringFilter<"CustomFieldValue"> | string
    fieldId?: StringFilter<"CustomFieldValue"> | string
    entityType?: EnumEntityTypeFilter<"CustomFieldValue"> | $Enums.EntityType
    entityId?: StringFilter<"CustomFieldValue"> | string
    value?: JsonNullableFilter<"CustomFieldValue">
    createdAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
    updatedAt?: DateTimeFilter<"CustomFieldValue"> | Date | string
  }

  export type CustomFieldCreateWithoutValuesInput = {
    id?: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutCustomFieldsInput
  }

  export type CustomFieldUncheckedCreateWithoutValuesInput = {
    id?: string
    portalId: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldCreateOrConnectWithoutValuesInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
  }

  export type CustomFieldUpsertWithoutValuesInput = {
    update: XOR<CustomFieldUpdateWithoutValuesInput, CustomFieldUncheckedUpdateWithoutValuesInput>
    create: XOR<CustomFieldCreateWithoutValuesInput, CustomFieldUncheckedCreateWithoutValuesInput>
    where?: CustomFieldWhereInput
  }

  export type CustomFieldUpdateToOneWithWhereWithoutValuesInput = {
    where?: CustomFieldWhereInput
    data: XOR<CustomFieldUpdateWithoutValuesInput, CustomFieldUncheckedUpdateWithoutValuesInput>
  }

  export type CustomFieldUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type CustomFieldUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortalCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutAuditLogsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutAuditLogsInput, PortalUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationCreateNestedOneWithoutUserInput
    restrictions?: RestrictionCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleCreateNestedManyWithoutUserInput
    createdClients?: ClientCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    surname?: string | null
    password?: string | null
    displayName: string
    avatar?: string | null
    points?: number
    role?: $Enums.UserRole
    method?: $Enums.AuthMethod
    emailVerified?: Date | string | null
    isEmailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordReset?: PasswordResetUncheckedCreateNestedOneWithoutUserInput
    externalAccounts?: ExternalAccountUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    mfa?: MultiFactorAuthenticationUncheckedCreateNestedOneWithoutUserInput
    restrictions?: RestrictionUncheckedCreateNestedManyWithoutUserInput
    emailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    portalRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutUserInput
    createdClients?: ClientUncheckedCreateNestedManyWithoutCreatedByInput
    assignedLeads?: LeadUncheckedCreateNestedManyWithoutAssignedToInput
    createdLeads?: LeadUncheckedCreateNestedManyWithoutCreatedByInput
    assignedDeals?: DealUncheckedCreateNestedManyWithoutAssignedToInput
    createdDeals?: DealUncheckedCreateNestedManyWithoutCreatedByInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type PortalUpsertWithoutAuditLogsInput = {
    update: XOR<PortalUpdateWithoutAuditLogsInput, PortalUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<PortalCreateWithoutAuditLogsInput, PortalUncheckedCreateWithoutAuditLogsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutAuditLogsInput, PortalUncheckedUpdateWithoutAuditLogsInput>
  }

  export type PortalUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUpdateManyWithoutUserNestedInput
    createdClients?: ClientUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    method?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordReset?: PasswordResetUncheckedUpdateOneWithoutUserNestedInput
    externalAccounts?: ExternalAccountUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    mfa?: MultiFactorAuthenticationUncheckedUpdateOneWithoutUserNestedInput
    restrictions?: RestrictionUncheckedUpdateManyWithoutUserNestedInput
    emailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    portalRoles?: UserPortalRoleUncheckedUpdateManyWithoutUserNestedInput
    createdClients?: ClientUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedLeads?: LeadUncheckedUpdateManyWithoutAssignedToNestedInput
    createdLeads?: LeadUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedDeals?: DealUncheckedUpdateManyWithoutAssignedToNestedInput
    createdDeals?: DealUncheckedUpdateManyWithoutCreatedByNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type PortalCreateWithoutSeoKeywordsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutSeoKeywordsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutSeoKeywordsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutSeoKeywordsInput, PortalUncheckedCreateWithoutSeoKeywordsInput>
  }

  export type SerpPositionCreateWithoutKeywordInput = {
    id?: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
    portal: PortalCreateNestedOneWithoutSerpPositionsInput
  }

  export type SerpPositionUncheckedCreateWithoutKeywordInput = {
    id?: string
    portalId: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
  }

  export type SerpPositionCreateOrConnectWithoutKeywordInput = {
    where: SerpPositionWhereUniqueInput
    create: XOR<SerpPositionCreateWithoutKeywordInput, SerpPositionUncheckedCreateWithoutKeywordInput>
  }

  export type SerpPositionCreateManyKeywordInputEnvelope = {
    data: SerpPositionCreateManyKeywordInput | SerpPositionCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type PortalUpsertWithoutSeoKeywordsInput = {
    update: XOR<PortalUpdateWithoutSeoKeywordsInput, PortalUncheckedUpdateWithoutSeoKeywordsInput>
    create: XOR<PortalCreateWithoutSeoKeywordsInput, PortalUncheckedCreateWithoutSeoKeywordsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutSeoKeywordsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutSeoKeywordsInput, PortalUncheckedUpdateWithoutSeoKeywordsInput>
  }

  export type PortalUpdateWithoutSeoKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutSeoKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type SerpPositionUpsertWithWhereUniqueWithoutKeywordInput = {
    where: SerpPositionWhereUniqueInput
    update: XOR<SerpPositionUpdateWithoutKeywordInput, SerpPositionUncheckedUpdateWithoutKeywordInput>
    create: XOR<SerpPositionCreateWithoutKeywordInput, SerpPositionUncheckedCreateWithoutKeywordInput>
  }

  export type SerpPositionUpdateWithWhereUniqueWithoutKeywordInput = {
    where: SerpPositionWhereUniqueInput
    data: XOR<SerpPositionUpdateWithoutKeywordInput, SerpPositionUncheckedUpdateWithoutKeywordInput>
  }

  export type SerpPositionUpdateManyWithWhereWithoutKeywordInput = {
    where: SerpPositionScalarWhereInput
    data: XOR<SerpPositionUpdateManyMutationInput, SerpPositionUncheckedUpdateManyWithoutKeywordInput>
  }

  export type PortalCreateWithoutSeoArticlesInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutSeoArticlesInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutSeoArticlesInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutSeoArticlesInput, PortalUncheckedCreateWithoutSeoArticlesInput>
  }

  export type PortalUpsertWithoutSeoArticlesInput = {
    update: XOR<PortalUpdateWithoutSeoArticlesInput, PortalUncheckedUpdateWithoutSeoArticlesInput>
    create: XOR<PortalCreateWithoutSeoArticlesInput, PortalUncheckedCreateWithoutSeoArticlesInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutSeoArticlesInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutSeoArticlesInput, PortalUncheckedUpdateWithoutSeoArticlesInput>
  }

  export type PortalUpdateWithoutSeoArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutSeoArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type PortalCreateWithoutSerpPositionsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    integrations?: IntegrationCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutSerpPositionsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutSerpPositionsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutSerpPositionsInput, PortalUncheckedCreateWithoutSerpPositionsInput>
  }

  export type SeoKeywordCreateWithoutSerpPositionsInput = {
    id?: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    portal: PortalCreateNestedOneWithoutSeoKeywordsInput
  }

  export type SeoKeywordUncheckedCreateWithoutSerpPositionsInput = {
    id?: string
    portalId: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoKeywordCreateOrConnectWithoutSerpPositionsInput = {
    where: SeoKeywordWhereUniqueInput
    create: XOR<SeoKeywordCreateWithoutSerpPositionsInput, SeoKeywordUncheckedCreateWithoutSerpPositionsInput>
  }

  export type PortalUpsertWithoutSerpPositionsInput = {
    update: XOR<PortalUpdateWithoutSerpPositionsInput, PortalUncheckedUpdateWithoutSerpPositionsInput>
    create: XOR<PortalCreateWithoutSerpPositionsInput, PortalUncheckedCreateWithoutSerpPositionsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutSerpPositionsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutSerpPositionsInput, PortalUncheckedUpdateWithoutSerpPositionsInput>
  }

  export type PortalUpdateWithoutSerpPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutSerpPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type SeoKeywordUpsertWithoutSerpPositionsInput = {
    update: XOR<SeoKeywordUpdateWithoutSerpPositionsInput, SeoKeywordUncheckedUpdateWithoutSerpPositionsInput>
    create: XOR<SeoKeywordCreateWithoutSerpPositionsInput, SeoKeywordUncheckedCreateWithoutSerpPositionsInput>
    where?: SeoKeywordWhereInput
  }

  export type SeoKeywordUpdateToOneWithWhereWithoutSerpPositionsInput = {
    where?: SeoKeywordWhereInput
    data: XOR<SeoKeywordUpdateWithoutSerpPositionsInput, SeoKeywordUncheckedUpdateWithoutSerpPositionsInput>
  }

  export type SeoKeywordUpdateWithoutSerpPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutSeoKeywordsNestedInput
  }

  export type SeoKeywordUncheckedUpdateWithoutSerpPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortalCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleCreateNestedManyWithoutPortalInput
    clients?: ClientCreateNestedManyWithoutPortalInput
    leads?: LeadCreateNestedManyWithoutPortalInput
    deals?: DealCreateNestedManyWithoutPortalInput
    appointments?: AppointmentCreateNestedManyWithoutPortalInput
    products?: ProductCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionCreateNestedManyWithoutPortalInput
  }

  export type PortalUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    subdomain?: string | null
    customDomain?: string | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    subscriptionStatus?: $Enums.SubscriptionStatus
    trialEndsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserPortalRoleUncheckedCreateNestedManyWithoutPortalInput
    clients?: ClientUncheckedCreateNestedManyWithoutPortalInput
    leads?: LeadUncheckedCreateNestedManyWithoutPortalInput
    deals?: DealUncheckedCreateNestedManyWithoutPortalInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPortalInput
    products?: ProductUncheckedCreateNestedManyWithoutPortalInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutPortalInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutPortalInput
    seoKeywords?: SeoKeywordUncheckedCreateNestedManyWithoutPortalInput
    seoArticles?: SeoArticleUncheckedCreateNestedManyWithoutPortalInput
    serpPositions?: SerpPositionUncheckedCreateNestedManyWithoutPortalInput
  }

  export type PortalCreateOrConnectWithoutIntegrationsInput = {
    where: PortalWhereUniqueInput
    create: XOR<PortalCreateWithoutIntegrationsInput, PortalUncheckedCreateWithoutIntegrationsInput>
  }

  export type PortalUpsertWithoutIntegrationsInput = {
    update: XOR<PortalUpdateWithoutIntegrationsInput, PortalUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<PortalCreateWithoutIntegrationsInput, PortalUncheckedCreateWithoutIntegrationsInput>
    where?: PortalWhereInput
  }

  export type PortalUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: PortalWhereInput
    data: XOR<PortalUpdateWithoutIntegrationsInput, PortalUncheckedUpdateWithoutIntegrationsInput>
  }

  export type PortalUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUpdateManyWithoutPortalNestedInput
    clients?: ClientUpdateManyWithoutPortalNestedInput
    leads?: LeadUpdateManyWithoutPortalNestedInput
    deals?: DealUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUpdateManyWithoutPortalNestedInput
    products?: ProductUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUpdateManyWithoutPortalNestedInput
  }

  export type PortalUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    customDomain?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserPortalRoleUncheckedUpdateManyWithoutPortalNestedInput
    clients?: ClientUncheckedUpdateManyWithoutPortalNestedInput
    leads?: LeadUncheckedUpdateManyWithoutPortalNestedInput
    deals?: DealUncheckedUpdateManyWithoutPortalNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPortalNestedInput
    products?: ProductUncheckedUpdateManyWithoutPortalNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutPortalNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutPortalNestedInput
    seoKeywords?: SeoKeywordUncheckedUpdateManyWithoutPortalNestedInput
    seoArticles?: SeoArticleUncheckedUpdateManyWithoutPortalNestedInput
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutPortalNestedInput
  }

  export type ExternalAccountCreateManyUserInput = {
    id?: string
    provider: $Enums.AccountProvider
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiry?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    postId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RestrictionCreateManyUserInput = {
    id?: string
    reason: $Enums.RestrictionReason
    until?: Date | string | null
    status?: $Enums.RestrictionStatus
    createdAt?: Date | string
  }

  export type UserPortalRoleCreateManyUserInput = {
    id?: string
    portalId: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateManyCreatedByInput = {
    id?: string
    portalId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyAssignedToInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type LeadCreateManyCreatedByInput = {
    id?: string
    portalId: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
  }

  export type DealCreateManyAssignedToInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    createdById?: string | null
  }

  export type DealCreateManyCreatedByInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentCreateManyAssignedToInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    productId?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    portalId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ExternalAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAccountProviderFieldUpdateOperationsInput | $Enums.AccountProvider
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestrictionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestrictionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RestrictionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumRestrictionReasonFieldUpdateOperationsInput | $Enums.RestrictionReason
    until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumRestrictionStatusFieldUpdateOperationsInput | $Enums.RestrictionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserPortalRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutClientsNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutLeadsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutLeadsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedDealsNestedInput
    appointments?: AppointmentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDealsNestedInput
    appointments?: AppointmentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneWithoutAppointmentsNestedInput
    deal?: DealUpdateOneWithoutAppointmentsNestedInput
    product?: ProductUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyCreateManyMfaInput = {
    id?: string
    deviceName: string
    credentialId: string
    publicKey: string
    counter?: number
    lastUsedAt?: Date | string | null
    ip: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasskeyUpdateWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyUncheckedUpdateWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasskeyUncheckedUpdateManyWithoutMfaInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    publicKey?: StringFieldUpdateOperationsInput | string
    counter?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    content: string
    edited?: boolean
    deleted?: boolean
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    edited?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleCreateManyPortalInput = {
    id?: string
    userId: string
    role?: $Enums.PortalRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateManyPortalInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    avatar?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type LeadCreateManyPortalInput = {
    id?: string
    source?: $Enums.LeadSource
    status?: $Enums.LeadStatus
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToId?: string | null
    createdById?: string | null
  }

  export type DealCreateManyPortalInput = {
    id?: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
  }

  export type AppointmentCreateManyPortalInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type ProductCreateManyPortalInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    duration?: number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldCreateManyPortalInput = {
    id?: string
    entityType: $Enums.EntityType
    name: string
    fieldType: $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyPortalInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SeoKeywordCreateManyPortalInput = {
    id?: string
    keyword: string
    language?: string
    volume?: number | null
    difficulty?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeoArticleCreateManyPortalInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    language?: string
    metaTitle?: string | null
    metaDescription?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: string | null
    isPublished?: boolean
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SerpPositionCreateManyPortalInput = {
    id?: string
    keywordId: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
  }

  export type IntegrationCreateManyPortalInput = {
    id?: string
    type: $Enums.IntegrationType
    config: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPortalRoleUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPortalRolesNestedInput
  }

  export type UserPortalRoleUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPortalRoleUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumPortalRoleFieldUpdateOperationsInput | $Enums.PortalRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedClientsNestedInput
    deals?: DealUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutClientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedLeadsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumLeadSourceFieldUpdateOperationsInput | $Enums.LeadSource
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDealsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedDealsNestedInput
    appointments?: AppointmentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutAppointmentsNestedInput
    deal?: DealUpdateOneWithoutAppointmentsNestedInput
    product?: ProductUpdateOneWithoutAppointmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CustomFieldValueUpdateManyWithoutFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CustomFieldValueUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    name?: StringFieldUpdateOperationsInput | string
    fieldType?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    config?: NullableJsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoKeywordUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serpPositions?: SerpPositionUpdateManyWithoutKeywordNestedInput
  }

  export type SeoKeywordUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serpPositions?: SerpPositionUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type SeoKeywordUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    volume?: NullableIntFieldUpdateOperationsInput | number | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoArticleUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoArticleUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoArticleUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    faqSchema?: NullableJsonNullValueInput | InputJsonValue
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyword?: SeoKeywordUpdateOneRequiredWithoutSerpPositionsNestedInput
  }

  export type SerpPositionUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutPortalInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    config?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateManyClientInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leadId?: string | null
    assignedToId?: string | null
    createdById?: string | null
  }

  export type AppointmentCreateManyClientInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    dealId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type DealUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDealsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedDealsNestedInput
    appointments?: AppointmentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutAppointmentsNestedInput
    deal?: DealUpdateOneWithoutAppointmentsNestedInput
    product?: ProductUpdateOneWithoutAppointmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealCreateManyLeadInput = {
    id?: string
    portalId: string
    title: string
    stage: string
    value?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    probability?: number | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    assignedToId?: string | null
    createdById?: string | null
  }

  export type DealUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutDealsNestedInput
    client?: ClientUpdateOneWithoutDealsNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedDealsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedDealsNestedInput
    appointments?: AppointmentUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    stage?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    probability?: NullableIntFieldUpdateOperationsInput | number | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManyDealInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    productId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneWithoutAppointmentsNestedInput
    product?: ProductUpdateOneWithoutAppointmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManyProductInput = {
    id?: string
    portalId: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.AppointmentStatus
    location?: string | null
    googleCalendarEventId?: string | null
    reminderSent?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: string | null
    dealId?: string | null
    assignedToId?: string | null
  }

  export type AppointmentUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneWithoutAppointmentsNestedInput
    deal?: DealUpdateOneWithoutAppointmentsNestedInput
    assignedTo?: UserUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    googleCalendarEventId?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomFieldValueCreateManyFieldInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomFieldValueUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    value?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionCreateManyKeywordInput = {
    id?: string
    portalId: string
    position?: number | null
    url?: string | null
    searchEngine?: string
    country?: string | null
    createdAt?: Date | string
  }

  export type SerpPositionUpdateWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portal?: PortalUpdateOneRequiredWithoutSerpPositionsNestedInput
  }

  export type SerpPositionUncheckedUpdateWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SerpPositionUncheckedUpdateManyWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    searchEngine?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}